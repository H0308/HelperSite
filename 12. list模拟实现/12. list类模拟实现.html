
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../index.html">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.31">
    
    
      
        <title>list类模拟实现 - 日常学习帮助网站</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.3cba04c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#12-list" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="日常学习帮助网站" class="md-header__button md-logo" aria-label="日常学习帮助网站" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            日常学习帮助网站
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              list类模拟实现
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="日常学习帮助网站" class="md-nav__button md-logo" aria-label="日常学习帮助网站" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    日常学习帮助网站
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    C++教程
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            C++教程
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="12.%20list%E7%B1%BB%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    list类模拟实现
  </span>
  

      </a>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="12-list">12. list类模拟实现<a class="headerlink" href="#12-list" title="Permanent link">&para;</a></h1>
<h1 id="list">list类模拟实现<a class="headerlink" href="#list" title="Permanent link">&para;</a></h1>
<h2 id="list_1">list类节点结构设计<a class="headerlink" href="#list_1" title="Permanent link">&para;</a></h2>
<p>因为list类为本质是带头双向循环链表，所以在设计list类时，需要先设计节点的结构，并且因为每一个节点是一个整体，所以可以考虑将每一个节点的初始化构造放在结构体中，如下代码所示：</p>
<pre><code class="language-C++">//节点结构
template&lt;class T&gt;
struct _list_node
{
    T data;// 数据类型
    _list_node* prev;// 前驱指针
    _list_node* next;// 后继指针

    //节点构造函数
    _list_node(const T&amp; x = T())
        :data(x)
        ,prev(nullptr)
        ,next(nullptr)
    {}
};
</code></pre>
<h2 id="listconst">list类非<code>const</code>迭代器结构设计<a class="headerlink" href="#listconst" title="Permanent link">&para;</a></h2>
<p>因为list类是带头双向循环链表，所以迭代器不能单单使用普通指针来代替，因为普通指针可以指针的<code>++</code>/<code>--</code>等操作可以作用到连续空间，链表两个节点空间不一定连续，所以额外重载<code>++</code>/<code>--</code>等运算符</p>
<h3 id="_1">迭代器基本结构设计<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<pre><code class="language-C++">//迭代器结构
template&lt;class T&gt;
struct _list_iterator
{
    typedef _list_node&lt;T&gt; Node;
    typedef _list_iterator&lt;T&gt; self;

    Node* _node;//迭代器节点
};
</code></pre>
<h3 id="_2">迭代器构造函数<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>为了可以将普通指针看作迭代器，需要构造函数使用普通指针进行构造</p>
<pre><code class="language-C++">//迭代器构造函数
_list_iterator(Node* node)
    :_node(node)
{}
</code></pre>
<p>考虑下面的代码</p>
<pre><code class="language-C++">void test()
{
    sim_list::list&lt;int&gt;::iterator it = ls.begin();
    while (it != ls.end())
    {
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
        ++it;
    }
}
</code></pre>
<p>在上面的测试代码中，当使用迭代器遍历时，需要使用到3个运算符</p>
<ol>
<li><code>!=</code>：不等于运算符</li>
<li><code>*</code>：解引用运算符</li>
<li><code>++</code>：前置自增运算符</li>
</ol>
<p>但是由于<code>it</code>不是原生指针（内置类型的指针），所以需要额外重载这三个运算符</p>
<h3 id="operator"><code>operator++()</code>函数<a class="headerlink" href="#operator" title="Permanent link">&para;</a></h3>
<p>重载前置<code>++</code>运算符的本意是让迭代器可以从当前节点移动到下一个节点，所以只需要移动节点类型的指针指向下一个节点即可</p>
<pre><code class="language-C++">//迭代器前置++运算符重载
self&amp; operator++()
{
    _node = _node-&gt;next;
    return *this;
}
</code></pre>
<h3 id="operator_1"><code>operator*()</code>函数<a class="headerlink" href="#operator_1" title="Permanent link">&para;</a></h3>
<p>重载<code>*</code>运算符本意是为了获取当前有效数据节点数据域中的值，所以返回当前节点数据域的值即可</p>
<pre><code class="language-C++">//迭代器*运算符重载
T&amp; operator*()
{
    return _node-&gt;data;
}
</code></pre>
<h3 id="operator_2"><code>operator!=()</code>函数<a class="headerlink" href="#operator_2" title="Permanent link">&para;</a></h3>
<p>重载!=运算符本意是为了判断迭代器指向的当前节点是end()迭代器的位置（即是否已经遍历完链表）</p>
<pre><code class="language-C++">//迭代器!=运算符重载
//注意end()返回值是个临时对象，具有常性，不能忘记const
bool operator!=(const self&amp; cur)
{
    return _node != cur._node;
}
</code></pre>
<h3 id="operatorint"><code>operator++(int)</code>函数<a class="headerlink" href="#operatorint" title="Permanent link">&para;</a></h3>
<p>后置<code>++</code>运算符重载需要满足先使用再自增，所以需要提前记录当前节点再改变当前节点指向为下一个节点</p>
<pre><code class="language-c++">//迭代器后置++运算符重载
self operator++(int)
{
    Node* cur = _node;
    _node = _node-&gt;next;
    return cur;
}
</code></pre>
<h3 id="operator-"><code>operator--()</code>函数<a class="headerlink" href="#operator-" title="Permanent link">&para;</a></h3>
<p>前置<code>--</code>运算符重载直接返回上一个节点的位置即可</p>
<pre><code class="language-C++">//迭代器前置--运算符重载
self&amp; operator--()
{
    node = node-&gt;prev;
    return *this;
}
</code></pre>
<h3 id="operator-int"><code>operator--(int)</code>函数<a class="headerlink" href="#operator-int" title="Permanent link">&para;</a></h3>
<p>后置<code>--</code>运算符重载需要满足先使用再自增，所以需要提前记录当前节点再改变当前节点指向为下一个节点</p>
<pre><code class="language-C++">//迭代器后置--运算符重载
self operator--(int)
{
    Node* cur = node;
    node = node-&gt;prev;
    return cur;
}
</code></pre>
<h3 id="operator_3"><code>operator==()</code>函数<a class="headerlink" href="#operator_3" title="Permanent link">&para;</a></h3>
<p>重载<code>==</code>运算符为了判断当前节点是否等于指定节点</p>
<pre><code class="language-c++">//迭代器==运算符重载
bool operator==(const self&amp; cur)
{
    return node == cur.node;
}
</code></pre>
<h3 id="operator-_1"><code>operator-&gt;()</code>函数<a class="headerlink" href="#operator-_1" title="Permanent link">&para;</a></h3>
<p>如果模板参数为自定义类型时，访问自定义类型的成员变量时除了可以解引用之后通过<code>.成员变量</code>的方式以外，还有<code>-&gt;成员变量</code>的方式，但是对于list类来说不存在原生指针，只有迭代器，所以迭代器需要重载<code>-&gt;</code>运算符，考虑下面的代码</p>
<pre><code class="language-C++">struct test
{
    int num1;
    int num2;
};

void test_operatorTo()
{
    sim_list::list&lt;struct test&gt; ls;
    sim_list::list&lt;struct test&gt;::iterator it = ls.begin();
    //使用直接访问
    cout &lt;&lt; (*it).num1 &lt;&lt; &quot; &quot; &lt;&lt; (*it).num2 &lt;&lt; endl;

    //使用间接访问
    cout &lt;&lt; it-&gt;num1 &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num2 &lt;&lt; endl;
}
</code></pre>
<p>为了可以使用<code>-&gt;</code>运算符，需要重载<code>-&gt;</code>运算符</p>
<pre><code class="language-C++">//迭代器-&gt;运算符重载
T* operator-&gt;()//返回对应类型的指针
{
    return &amp;(node-&gt;data);//获取当前数据域的地址
}
</code></pre>
<p><img src="image\image.png"></p>
<p>所以上面的代码可以转化为</p>
<pre><code class="language-C++">cout &lt;&lt; it.operator-&gt;()-&gt;num1 &lt;&lt; &quot; &quot; &lt;&lt; it.operator-&gt;()-&gt;num2 &lt;&lt; endl;
//其中it.operator-&gt;()返回自定义类型变量的地址
</code></pre>
<h2 id="listconst_1">list类<code>const</code>迭代器结构设计<a class="headerlink" href="#listconst_1" title="Permanent link">&para;</a></h2>
<p>设计<code>const</code>迭代器的思路和非<code>const</code>迭代器思路基本一致，但是设计<code>const</code>迭代器不可以单单是在已有的<code>iterator</code>前面加上<code>const</code>改为<code>const iterator</code>，这种写法会使编译器认为是<code>T* const</code>，此时实现的效果是，迭代器指向的内容可以修改，但是指向不可以修改，而需要的<code>const</code>迭代器实现的效果是迭代器指向的内容不可以修改，但是指向可以修改，即<code>const T*</code>，所以需要单独设计一个<code>const_iterator</code>类来解决这个问题</p>
<h3 id="_3">迭代器基本结构设计<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<pre><code class="language-C++">template&lt;class T&gt;
struct _list_iterator_const 
{
    typedef _list_node&lt;T&gt; Node;
    typedef _list_iterator_const&lt;T&gt; self;

    Node* node;
};
</code></pre>
<h3 id="_4">迭代器构造函数<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<pre><code class="language-C++">//构造函数
//同非const版本一样，使用指针构造迭代器
_list_iterator_const(Node* node)
    :_node(node)
{}
</code></pre>
<h3 id="operator_4"><code>operator++()</code>函数<a class="headerlink" href="#operator_4" title="Permanent link">&para;</a></h3>
<p>因为是改变迭代器指针的指向，所以设计<code>operator++()</code>函数和非<code>const</code>版本的方式相同</p>
<pre><code class="language-C++">//operator++()函数
self&amp; operator++()
{
    _node = _node-&gt;next;
    return *this;
}
</code></pre>
<h3 id="operator_5"><code>operator*()</code>函数<a class="headerlink" href="#operator_5" title="Permanent link">&para;</a></h3>
<p>因为<code>const</code>版本迭代器不可以通过解引用修改指针指向的内容，所以需要使用<code>const</code>修饰返回值</p>
<pre><code class="language-C++">//operator*()函数
const T&amp; operator*() const
{
    return _node-&gt;data;
}
</code></pre>
<h3 id="operator_6"><code>operator!=()</code>函数<a class="headerlink" href="#operator_6" title="Permanent link">&para;</a></h3>
<p>对于<code>!=</code>运算符来说，和非<code>const</code>版本思路相同</p>
<pre><code class="language-C++">//operator!=()函数
bool operator!=(const self&amp; cur)
{
    return _node != cur._node;
}
</code></pre>
<h3 id="operatorint_1"><code>operator++(int)</code>函数<a class="headerlink" href="#operatorint_1" title="Permanent link">&para;</a></h3>
<p>对于后置<code>++</code>来说与<code>const</code>版本同理</p>
<pre><code class="language-C++">//operator++(int)函数
self&amp; operator++(int)
{
    Node* cur = _node;
    _node = _node-&gt;next;
    return cur;
}
</code></pre>
<h3 id="operator-_2"><code>operator--()</code>函数<a class="headerlink" href="#operator-_2" title="Permanent link">&para;</a></h3>
<p>因为<code>--</code>改变的是迭代器指向的内容，所以与非<code>const</code>版本迭代器思路相同</p>
<pre><code class="language-C++">self&amp; operator--()
{
    _node = _node-&gt;prev;
    return *this;
}
</code></pre>
<h3 id="operator-int_1"><code>operator--(int)</code>函数<a class="headerlink" href="#operator-int_1" title="Permanent link">&para;</a></h3>
<p>设计后置<code>--</code>的思路与非<code>const</code>版本相同</p>
<pre><code class="language-C++">//operator--(int)函数
self&amp; operator--(int)
{
    Node* cur = _node;
    _node = _node-&gt;prev;
    return cur;
}
</code></pre>
<h3 id="operator_7"><code>operator==()</code>函数<a class="headerlink" href="#operator_7" title="Permanent link">&para;</a></h3>
<p>设计<code>==</code>运算符重载函数思路和非<code>const</code>版本相同</p>
<pre><code class="language-C++">//operator==()函数
bool operator==(const self&amp; cur)
{
    return _node = cur._node;
}
</code></pre>
<h3 id="operator-_3"><code>operator-&gt;()</code>函数<a class="headerlink" href="#operator-_3" title="Permanent link">&para;</a></h3>
<p>需要满足返回值为<code>const</code>类型即可</p>
<pre><code class="language-c++">const T* operator-&gt;()
{
    return &amp;_node-&gt;data;
}
</code></pre>
<h2 id="const"><code>const</code>版本的迭代器使用问题<a class="headerlink" href="#const" title="Permanent link">&para;</a></h2>
<p>上面的<code>const</code>版本迭代器实现方式可以应用于对象为<code>const</code>类型时，例如下面的测试代码</p>
<pre><code class="language-c++">void test_const_iterator()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);
    const sim_list::list&lt;int&gt; ls1(ls);// const对象

    sim_list::list&lt;int&gt;::const_iterator cit = ls1.begin();// 编译器自动识别const类型的迭代器

    while (cit != ls1.end())
    {
        //*cit = 2;
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p>但是如果对象不是<code>const</code>类型，此时上面的代码就会出现错误，例如下面的测试代码</p>
<pre><code class="language-C++">void test_const_iterator()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt;::const_iterator cit = ls.begin();// 编译器无法自动识别const类型的迭代器


    while (cit != ls.end())
    {
        //*cit = 2;
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<p>在第二个测试代码中，因为<code>cit</code>为<code>const</code>类型的迭代器，所以不可以使用非<code>const</code>版本的迭代器，但是此时的<code>begin()</code>和<code>end()</code>均为非<code>const</code>版本迭代器，因为对象<code>ls</code>为非<code>const</code>对象</p>
<p>这里提出两种解决方案：</p>
<ol>
<li>将<code>const</code>版本的<code>begin()</code>和<code>end()</code>改为<code>cbegin()</code>和<code>cend()</code>，此时显式使ls调用const版本的<code>cbegin()</code>和<code>cend()</code></li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<p>缺点：没有使用到函数重载的优势</p>
</blockquote>
<pre><code class="language-C++">//修改const版本的迭代器
//begin()函数——const版本
const_iterator cbegin() const
{
    return _head-&gt;next;
}

//begin()函数——const版本
const_iterator cbegin() const
{
    return _head-&gt;next;
}

//测试代码修改为
void test_const_iterator()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt;::const_iterator cit = ls.cbegin();// 显式指定const版本迭代器

    while (cit != ls.cend())
    {
        //*cit = 2;
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<ol>
<li>在<code>const</code>版本的迭代器结构中添加非<code>const</code>对象向<code>const</code>对象转换的构造函数</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<p>缺点：没有调用<code>const</code>版本的迭代器</p>
</blockquote>
<pre><code class="language-C++">// 非const对象向const对象转换的构造函数
//传入非const对象，为了确保安全，使用const修饰形参
_list_iterator_const(const _list_iterator&lt;T&gt; nonConst)
    :_node(nonConst._node)//使用非const对象中的_node值构造const版本的对象中的_node
{}
</code></pre>
<h2 id="constconst"><code>const</code>版本迭代器和非<code>const</code>版本迭代器合并优化<a class="headerlink" href="#constconst" title="Permanent link">&para;</a></h2>
<p>在实现非<code>const</code>版本的迭代器时，可以很明显感觉到除了<code>operator*()</code>函数和<code>operator-&gt;()</code>函数两个有不同以外，其余均没有不同，而这两个版本中的这两个函数只是返回值类型不同，那么可以考虑通过模板单独控制这两个返回值类型，现在将类型引用<code>T&amp;</code>用模板参数<code>Ref</code>指代，将类型指针<code>T*</code>用模板参数<code>Ptr</code>指代，则<code>const</code>版本迭代器和非<code>const</code>版本迭代器可以合并为下面的代码：</p>
<pre><code class="language-C++">//迭代器结构——复合版本
template&lt;class T, class Ref, class Ptr&gt;
struct _list_iterator
{
    typedef _list_node&lt;T&gt; Node;
    typedef _list_iterator&lt;T, Ref, Ptr&gt; self;

    Node* _node;//迭代器节点

    //迭代器构造函数
    _list_iterator(Node* node)
        :_node(node)
    {}

    //迭代器前置++运算符重载
    self&amp; operator++()
    {
        _node = _node-&gt;next;
        return *this;
    }

    //迭代器前置--运算符重载
    self&amp; operator--()
    {
        _node = _node-&gt;prev;
        return *this;
    }

    //迭代器后置++运算符重载
    self operator++(int)
    {
        Node* cur = _node;
        _node = _node-&gt;next;
        return cur;
    }

    //迭代器后置--运算符重载
    self operator--(int)
    {
        Node* cur = _node;
        _node = _node-&gt;prev;
        return cur;
    }

    //迭代器*运算符重载
    Ref operator*()
    {
        return _node-&gt;data;
    }

    //迭代器-&gt;运算符重载
    Ptr operator-&gt;()
    {
        return &amp;(_node-&gt;data);
    }

    //迭代器!=运算符重载
    bool operator!=(const self&amp; cur)
    {
        return _node != cur._node;
    }

    //迭代器==运算符重载
    bool operator==(const self&amp; cur)
    {
        return _node == cur._node;
    }
};
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>注意，此处也需要考虑到非<code>const</code>对象向<code>const</code>对象的转换问题，为了更方便解决，采取上面的第一种解决方案，如果直接是<code>const</code>对象调用则不需要考虑这个问题</p>
</blockquote>
<h2 id="list_2">list类无参构造函数<a class="headerlink" href="#list_2" title="Permanent link">&para;</a></h2>
<p>对于list类来说，因为只有一个头指针作为成员变量，所以无参构造时只需要考虑创建头结点即可</p>
<pre><code class="language-C++">//头节点处理
void empty_init()
{
    _head = new Node;
    _head-&gt;prev = _head;
    _head-&gt;next = _head;

    _size = 0;
}

//构造函数
list()
{
    empty_init();
}
</code></pre>
<h2 id="list_3">list类析构函数<a class="headerlink" href="#list_3" title="Permanent link">&para;</a></h2>
<p>调用<code>clear()</code>函数后将头节点资源清理并置为空即可</p>
<pre><code class="language-C++">//析构函数
~list()
{
    clear();

    delete _head;
    _head = nullptr;
}
</code></pre>
<h2 id="list_4">list类拷贝构造函数<a class="headerlink" href="#list_4" title="Permanent link">&para;</a></h2>
<pre><code class="language-C++">//拷贝构造函数
list(list&lt;T&gt;&amp; ls)
{
    empty_init();

    for (auto num : ls)
    {
        push_back(num);
    }
}
</code></pre>
<h2 id="list_5">list类赋值运算符重载函数<a class="headerlink" href="#list_5" title="Permanent link">&para;</a></h2>
<pre><code class="language-C++">//赋值运算符重载函数
list&lt;T&gt;&amp; operator=(list&lt;T&gt;&amp; ls)
{
    if (this != &amp;ls)
    {
        for (auto num : ls)
        {
            push_back(num);
        }
    }

    return *this;
}
</code></pre>
<h2 id="begin"><code>begin()</code>函数<a class="headerlink" href="#begin" title="Permanent link">&para;</a></h2>
<p>返回第一个有效数据节点的位置即可</p>
<pre><code class="language-C++">//begin()函数——非const版本
iterator begin()
{
    return _head-&gt;next;//隐式类型转换
}

//begin()函数——const版本
const_iterator begin() const
{
    return _head-&gt;next;
}
</code></pre>
<h2 id="end"><code>end()</code>函数<a class="headerlink" href="#end" title="Permanent link">&para;</a></h2>
<p>返回最后一个头节点的位置即可</p>
<pre><code class="language-C++">//end()函数——非const版本
iterator end()
{
    return _head;
}

//end()函数——const版本
const_iterator end() const
{
    return _head;
}
</code></pre>
<h2 id="insert"><code>insert()</code>函数<a class="headerlink" href="#insert" title="Permanent link">&para;</a></h2>
<p>插入节点思路参考带头双向循环链表</p>
<blockquote>
<p>[!NOTE]</p>
<p>可以考虑返回当前节点位置防止迭代器失效问题</p>
</blockquote>
<pre><code class="language-C++">//insert()函数
iterator insert(iterator position, const T&amp; val)
{
    //创建新的节点
    Node* node = new Node(val);
    //改变节点指针指向
    //记录当前position位置的节点
    Node* cur = position._node;
    //改变新节点的指向
    node-&gt;next = cur;
    node-&gt;prev = cur-&gt;prev;
    //改变当前位置节点的前一个节点的后继指针指向
    cur-&gt;prev-&gt;next = node;
    //改变当前位置节点的前驱指针指向
    cur-&gt;prev = node;

    ++_size;

    return position;
}
</code></pre>
<h2 id="push_back"><code>push_back()</code>函数<a class="headerlink" href="#push_back" title="Permanent link">&para;</a></h2>
<p>设计思路参考带头双向循环链表的思路</p>
<pre><code class="language-C++">//push_back()函数
void push_back(const T&amp; val)
{
    //创建新的节点
    Node* node = new Node(val);//调用节点结构构造函数
    //改变节点指针
    //先记录当前最后一个节点
    Node* tail = _head-&gt;prev;
    //改变头节点前驱指针为新节点
    _head-&gt;prev = node;
    //改变最后一个节点的后继指针指向新节点
    tail-&gt;next = node;
    //改变新节点的指针
    node-&gt;prev = tail;
    node-&gt;next = _head;

    ++_size;
}
</code></pre>
<h2 id="push_front"><code>push_front()</code>函数<a class="headerlink" href="#push_front" title="Permanent link">&para;</a></h2>
<p>设计思路参考带头双向循环链表的思路</p>
<pre><code class="language-C++">//push_front()函数
void push_front(const T&amp; val)
{
    //创建新节点
    Node* node = new Node(val);
    //改变指针指向
    //先记录当前第一个节点
    Node* first = _head-&gt;next;
    //改变新节点的指针指向
    node-&gt;next = first;
    node-&gt;prev = _head;
    //改变头指针后继指针指向
    _head-&gt;next = node;
    //改变原始第一个节点的前驱指针指向
    first-&gt;prev = node;

    ++_size;
}
</code></pre>
<h2 id="erase"><code>erase()</code>函数<a class="headerlink" href="#erase" title="Permanent link">&para;</a></h2>
<p>删除节点的思路类似于带头双向链表的删除思路</p>
<blockquote>
<p>[!NOTE]</p>
<p>注意返回删除节点位置的下一个节点的位置防止出现迭代器失效问题</p>
</blockquote>
<pre><code class="language-C++">//erase()函数
iterator erase(iterator position)
{
    //不可以删除头结点
    assert(position != iterator(_head));

    //记录要删除的节点的后一个节点
    Node* cur = position._node-&gt;next;
    //改变要删除的节点的前一个节点的后继指针
    position._node-&gt;prev-&gt;next = cur;
    //改变要删除的节点的后一个节点的前驱指针
    cur-&gt;prev = position._node-&gt;prev;

    //删除当前位置的指针
    delete position._node;

    --_size;

    return cur;
}
</code></pre>
<h2 id="pop_back"><code>pop_back()</code>函数<a class="headerlink" href="#pop_back" title="Permanent link">&para;</a></h2>
<p>直接复用<code>erase()</code>函数即可，但是需要注意删除的位置不是<code>end</code>的位置，而是<code>end</code>前一个位置</p>
<pre><code class="language-C++">//pop_back()函数
void pop_back()
{
    erase(--end());
}
</code></pre>
<h2 id="pop_front"><code>pop_front()</code>函数<a class="headerlink" href="#pop_front" title="Permanent link">&para;</a></h2>
<p>直接复用<code>erase()</code>函数即可</p>
<pre><code class="language-C++">//pop_front()函数
void pop_front()
{
    //复用erase()函数
    erase(begin());
}
</code></pre>
<h2 id="clear"><code>clear()</code>函数<a class="headerlink" href="#clear" title="Permanent link">&para;</a></h2>
<p>调用<code>erase()</code>函数循环从头删除即可，但是不可以删除头结点</p>
<pre><code class="language-C++">//clear()函数
void clear()
{
    iterator it = begin();
    while (it != end())
    {
        it = erase(it);
    }
}
</code></pre>
<h1 id="_5">额外补充<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h1>
<p>打印函数</p>
<p>当链表中的类型为<code>int</code>时，打印函数中的list模板参数直接设置为<code>int</code>即可，例如下面的代码：</p>
<pre><code class="language-C++">//额外补充的函数——标准库中没有
//打印函数
void print_list(const list&lt;int&gt;&amp; ls)
{
    sim_list::list&lt;int&gt;::const_iterator cit = ls.begin();
    while (cit != ls.end())
    {
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
}
</code></pre>
<p>但是，上面的代码在模板参数处写定为<code>int</code>，如果更换类型，此时就需要在打印函数处同时更改类型。</p>
<p>假设现在的链表为如下：</p>
<pre><code class="language-C++">sim_list::list&lt;string&gt; ls;
ls.push_back(&quot;111111&quot;);
ls.push_back(&quot;111111&quot;);
ls.push_back(&quot;111111&quot;);
ls.push_back(&quot;111111&quot;);
</code></pre>
<p>此时必需更改打印函数中的类型为<code>string</code>类型，但是每一次更换类型就要改变函数步骤相对繁琐，如果一个函数中涉及到多个类型的list，此时就无法实现调用打印函数打印链表内容，此时可以考虑使用模板，将list的模板参数设置为模板参数，如下面的代码：</p>
<pre><code class="language-C++">//额外补充的函数——标准库中没有
//打印函数
template&lt;class T&gt;
void print_list(const list&lt;T&gt;&amp; ls)
{
    sim_list::list&lt;T&gt;::const_iterator cit = ls.begin();
    while (cit != ls.end())
    {
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
}
</code></pre>
<p>但是上面的代码没有通过编译，原因在于模板参数，当模板参数在函数模板或者类模板中，编译器开始编译时，可以实现替换，从而生成对应的函数或者类。但是在上面的代码中，<code>const_iterator</code>是一个被<code>typedef</code>的变量，但是编译器并不知道是重命名的变量，反之编译器可能会认为是静态变量，所以此时到底是<code>const_iterator</code>是静态变量还是重命名的变量编译器并不知道，编译器需要在类<code>sim_list</code>中确定<code>const_iterator</code>的类型，从而实现链接，最后再替换模板参数，因为在模板参数还未被替换时，编译器不能进类<code>sim_list</code>中寻找，因为此时类中可能存在未知的内容没有被处理，所以为了确保正常编译通过，此时不可以使用<code>class T</code>作为模板参数，而应该使用<code>typename T</code>，所以上面的代码修改为：</p>
<pre><code class="language-C++">//额外补充的函数——标准库中没有
//打印函数
template&lt;typename T&gt;
void print_list(const list&lt;T&gt;&amp; ls)
{
    //此处的typename不可以省略，此处的typename是为了告诉编译器这个需要等到模板参数被替换之后再去类中找的变量
    typename sim_list::list&lt;T&gt;::const_iterator cit = ls.begin();
    while (cit != ls.end())
    {
        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
        cit++;
    }
}
</code></pre>
<p>另外还有一个问题，上面的打印代码仅仅实现的是list类的内容打印，但是如果此时需要为其他类打印，则需要另外再写一个打印，方式过于繁琐，所以可以考虑为各种类的内容打印写一个通用的函数，此时设计该函数时需要改变函数参数为各种容器，可以考虑使用函数模板，模板参数即为作为函数参数的容器，如下面的代码：</p>
<pre><code class="language-C++">//各种容器内容打印
template&lt;typename container&gt;
void print_container(const container&amp; con)
{
    typename container::const_iterator it = con.begin();
    while (it != con.end())
    {
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
        it++;
    }
    cout &lt;&lt; endl;
}
</code></pre>
<h1 id="_6">项目代码<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<h2 id="list_6">list类实现文件<a class="headerlink" href="#list_6" title="Permanent link">&para;</a></h2>
<pre><code class="language-C++">#pragma once

#include &lt;iostream&gt;
#include &lt;cassert&gt;
using namespace std;

namespace sim_list
{
    //节点结构
    template&lt;class T&gt;
    struct _list_node
    {
        T data;// 数据类型
        _list_node* prev;// 前驱指针
        _list_node* next;// 后继指针

        //节点构造函数
        _list_node(const T&amp; x = T())
            :data(x)
            ,prev(nullptr)
            ,next(nullptr)
        {}
    };

    //迭代器结构——非const版本
    //迭代器结构——复合版本
    template&lt;class T, class Ref, class Ptr&gt;
    struct _list_iterator
    {
        typedef _list_node&lt;T&gt; Node;
        typedef _list_iterator&lt;T, Ref, Ptr&gt; self;

        Node* _node;//迭代器节点

        //迭代器构造函数
        _list_iterator(Node* node)
            :_node(node)
        {}

        //迭代器前置++运算符重载
        self&amp; operator++()
        {
            _node = _node-&gt;next;
            return *this;
        }

        //迭代器前置--运算符重载
        self&amp; operator--()
        {
            _node = _node-&gt;prev;
            return *this;
        }

        //迭代器后置++运算符重载
        self operator++(int)
        {
            Node* cur = _node;
            _node = _node-&gt;next;
            return cur;
        }

        //迭代器后置--运算符重载
        self operator--(int)
        {
            Node* cur = _node;
            _node = _node-&gt;prev;
            return cur;
        }

        //迭代器*运算符重载
        Ref operator*()
        {
            return _node-&gt;data;
        }

        //迭代器-&gt;运算符重载
        Ptr operator-&gt;()
        {
            return &amp;(_node-&gt;data);
        }

        //迭代器!=运算符重载
        bool operator!=(const self&amp; cur)
        {
            return _node != cur._node;
        }

        //迭代器==运算符重载
        bool operator==(const self&amp; cur)
        {
            return _node == cur._node;
        }
    };

#if 0
    // 迭代器——const版本
    template&lt;class T&gt;
    struct _list_iterator_const 
    {
        typedef _list_node&lt;T&gt; Node;
        typedef _list_iterator_const&lt;T&gt; self;

        Node* _node;

        //构造函数
        //使用指针构造迭代器
        _list_iterator_const(Node* node)
            :_node(node)
        {}

        //非const对象向const对象转换的构造函数
        //传入非const对象，为了确保安全，使用const修饰形参
        _list_iterator_const(const _list_iterator&lt;T&gt; nonConst)
            :_node(nonConst._node)//使用非const对象中的_node值构造const版本的对象中的_node
        {}

        //operator++()函数
        self&amp; operator++()
        {
            _node = _node-&gt;next;
            return *this;
        }

        //operator*()函数
        const T&amp; operator*() const
        {
            return _node-&gt;data;
        }

        //operator!=()函数
        bool operator!=(const self&amp; cur)
        {
            return _node != cur._node;
        }

        //operator--()函数
        self&amp; operator--()
        {
            _node = _node-&gt;prev;
            return *this;
        }

        //operator--(int)函数
        self operator--(int)
        {
            Node* cur = _node;
            _node = _node-&gt;prev;
            return cur;
        }

        //operator++(int)函数
        self operator++(int)
        {
            Node* cur = _node;
            _node = _node-&gt;next;
            return cur;
        }

        //operator==()函数
        bool operator==(const self&amp; cur)
        {
            return _node == cur._node;
        }

        //operator-&gt;()函数
        const T* operator-&gt;()
        {
            return &amp;_node-&gt;data;
        }
    };
#endif
    template&lt;class T&gt; 
    class list
    {
        typedef _list_node&lt;T&gt; Node;
    public:
        typedef _list_iterator&lt;T, T&amp;, T*&gt; iterator; // 迭代器——非const版本
        typedef _list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; // 迭代器——const版本
        //头节点处理
        void empty_init()
        {
            _head = new Node;
            _head-&gt;prev = _head;
            _head-&gt;next = _head;

            _size = 0;
        }

        //构造函数
        list()
        {
            empty_init();
        }

        //析构函数
        ~list()
        {
            clear();

            delete _head;
            _head = nullptr;
        }

        //拷贝构造函数
        list(const list&lt;T&gt;&amp; ls)
        {
            empty_init();

            for (auto num : ls)
            {
                push_back(num);
            }
        }

        //赋值运算符重载函数
        list&lt;T&gt;&amp; operator=(list&lt;T&gt;&amp; ls)
        {
            if (this != &amp;ls)
            {
                for (auto num : ls)
                {
                    push_back(num);
                }
            }

            return *this;
        }

        //begin()函数——非const版本
        iterator begin()
        {
            return _head-&gt;next;//通过构造函数进行隐式类型转换
        }

        //begin()函数——const版本
        const_iterator begin() const
        {
            return _head-&gt;next;
        }

        //end()函数——非const版本
        iterator end()
        {
            return _head;
        }

        //end()函数——const版本
        const_iterator end() const
        {
            return _head;
        }

        //push_back()函数
        void push_back(const T&amp; val)
        {
            //创建新的节点
            Node* node = new Node(val);
            //改变节点指针
            //先记录当前最后一个节点
            Node* tail = _head-&gt;prev;
            //改变头节点前驱指针为新节点
            _head-&gt;prev = node;
            //改变最后一个节点的后继指针指向新节点
            tail-&gt;next = node;
            //改变新节点的指针
            node-&gt;prev = tail;
            node-&gt;next = _head;
            ++_size;
        }

        //push_front()函数
        void push_front(const T&amp; val)
        {
            //创建新节点
            Node* node = new Node(val);
            //改变指针指向
            //先记录当前第一个节点
            Node* first = _head-&gt;next;
            //改变新节点的指针指向
            node-&gt;next = first;
            node-&gt;prev = _head;
            //改变头指针后继指针指向
            _head-&gt;next = node;
            //改变原始第一个节点的前驱指针指向
            first-&gt;prev = node;

            ++_size;
        }

        //insert()函数
        iterator insert(iterator position, const T&amp; val)    
        {
            //创建新的节点
            Node* node = new Node(val);
            //改变节点指针指向
            //记录当前position位置的节点
            Node* cur = position._node;
            //改变新节点的指向
            node-&gt;next = cur;
            node-&gt;prev = cur-&gt;prev;
            //改变当前位置节点的前一个节点的后继指针指向
            cur-&gt;prev-&gt;next = node;
            //改变当前位置节点的前驱指针指向
            cur-&gt;prev = node;

            ++_size;

            return position;
        }

        //erase()函数
        iterator erase(iterator position)
        {
            //不可以删除头结点
            assert(position != iterator(_head));

            //记录要删除的节点的后一个节点
            Node* cur = position._node-&gt;next;
            //改变要删除的节点的前一个节点的后继指针
            position._node-&gt;prev-&gt;next = cur;
            //改变要删除的节点的后一个节点的前驱指针
            cur-&gt;prev = position._node-&gt;prev;

            //删除当前位置的指针
            delete position._node;

            --_size;

            return cur;
        }

        //pop_front()函数
        void pop_front()
        {
            //复用erase()函数
            erase(begin());
        }

        //pop_back()函数
        void pop_back()
        {
            erase(--end());
        }

        //clear()函数
        void clear()
        {
            iterator it = begin();
            while (it != end())
            {
                it = erase(it);
            }
        }

        //swap()函数
        void swap(list&lt;T&gt;&amp; ls)
        {
            std::swap(_head, ls._head);
            std::swap(_size, ls._size);
        }

    private:
        Node* _head;
        //有效数据节点个数
        size_t _size;
    };

    //额外补充的函数——标准库中没有
    //打印函数
    //template&lt;typename T&gt;
    //void print_list(const list&lt;T&gt;&amp; ls)
    //{
    //    //此处的typename不可以省略，此处的typename是为了告诉编译器这个需要等到模板参数被替换之后再去类中找的变量
    //    typename sim_list::list&lt;T&gt;::const_iterator cit = ls.begin();
    //    while (cit != ls.end())
    //    {
    //        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
    //        cit++;
    //    }
    //}

    //各种容器内容打印
    template&lt;typename container&gt;
    void print_container(const container&amp; con)
    {
        typename container::const_iterator it = con.begin();
        while (it != con.end())
        {
            cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
            it++;
        }
        cout &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="_7">测试文件<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<pre><code class="language-C++">#include &quot;list.h&quot;
#include &lt;vector&gt;

void test_pushback()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt;::iterator it = ls.begin();
    while (it != ls.end())
    {
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
        it++;
    }
}

void test_pushfront()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_front(1);
    ls.push_front(2);
    ls.push_front(3);
    ls.push_front(4);
    ls.push_front(5);

    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_insert()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt;::iterator it = ++ls.begin();
    //sim_list::list&lt;int&gt;::iterator it = find(ls.begin(), ls.end(), 2);
    ls.insert(it, 6);
    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_erase()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt;::iterator it = --ls.end();

    it = ls.erase(it);
    it = ls.erase(--it);
    it = ls.erase(--it);
    it = ls.erase(--it);

    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_popback()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    ls.pop_back();
    ls.pop_back();
    ls.pop_back();
    ls.pop_back();
    ls.pop_back();

    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_popfront()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    ls.pop_front();
    ls.pop_front();
    ls.pop_front();
    ls.pop_front();
    ls.pop_front();

    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_clear()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    ls.clear();
    //ls.pop_back();

    for (auto num : ls)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

void test_operatorGive()
{
    sim_list::list&lt;int&gt; ls;
    ls.push_back(1);
    ls.push_back(2);
    ls.push_back(3);
    ls.push_back(4);
    ls.push_back(5);

    sim_list::list&lt;int&gt; ls1;
    ls1 = ls;
    for (auto num : ls1)
    {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
}

struct test
{
    int num1;
    int num2;
};

void test_operatorTo()
{
    sim_list::list&lt;struct test&gt; ls;
    sim_list::list&lt;struct test&gt;::iterator it = ls.begin();
    //使用直接访问
    cout &lt;&lt; (*it).num1 &lt;&lt; &quot; &quot; &lt;&lt; (*it).num2 &lt;&lt; endl;

    //使用间接访问
    cout &lt;&lt; it-&gt;num1 &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num2 &lt;&lt; endl;
    //等价于
    cout &lt;&lt; it.operator-&gt;()-&gt;num1 &lt;&lt; &quot; &quot; &lt;&lt; it.operator-&gt;()-&gt;num2 &lt;&lt; endl;
}

//void test_const_iterator()
//{
//    sim_list::list&lt;int&gt; ls;
//    ls.push_back(1);
//    ls.push_back(2);
//    ls.push_back(3);
//    ls.push_back(4);
//    ls.push_back(5);
//    //const sim_list::list&lt;int&gt; ls1(ls);// const对象
//
//    //sim_list::list&lt;int&gt;::const_iterator cit = ls.begin();// 编译器自动识别const类型的迭代器
//    sim_list::list&lt;int&gt;::const_iterator cit = ls.cbegin();// 编译器无法自动识别const类型的迭代器
//
//    while (cit != ls.cend())
//    {
//        //*cit = 2;
//        cout &lt;&lt; *cit &lt;&lt; &quot; &quot;;
//        cit++;
//    }
//    cout &lt;&lt; endl;
//}

void test_print()
{
    sim_list::list&lt;string&gt; ls;
    ls.push_back(&quot;111111&quot;);
    ls.push_back(&quot;111111&quot;);
    ls.push_back(&quot;111111&quot;);
    ls.push_back(&quot;111111&quot;);
    sim_list::print_container(ls);

    vector&lt;string&gt; v;
    v.push_back(&quot;1111&quot;);
    v.push_back(&quot;1111&quot;);
    v.push_back(&quot;1111&quot;);
    v.push_back(&quot;1111&quot;);

    sim_list::print_container(v);
}

int main()
{
    //test_pushback();
    //test_pushfront();
    //test_insert();
    //test_erase();
    //test_popback();
    //test_popfront();
    //test_clear();
    //test_operatorGive();
    //test_operatorTo();
    //test_const_iterator();
    test_print();


    return 0;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["header.autohide"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>