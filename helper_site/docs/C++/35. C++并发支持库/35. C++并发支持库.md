# C++并发支持库

!!! note

    阅读本篇文章之前建议有一定的线程编程基础，此处可以参考[Linux线程部分](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/1.%20Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/1.%20Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C.html#linux)

## 线程库`<thread>`

在C++11中，引入了线程库`<thread>`，用于实现多线程编程。该库提供了一组类和函数，用于创建、管理和同步线程

### 构造函数

对于创建一个线程来说，可以使用`thread`类的构造函数，常见的构造如下：

以下是C++11中用于创建线程的`std::thread`类的构造函数列表，以Markdown表格形式展示，并附上说明：

| 构造函数                                                                                  | 说明                                                                                                         |
| ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `thread() noexcept;`                                                                      | 默认构造函数，创建一个空的线程对象，不关联任何实际线程                                                       |
| `template <class Function, class... Args> explicit thread(Function&& f, Args&&... args);` | 创建一个线程并执行指定的可调用对象（函数、lambda表达式、函数对象等）及其参数。参数会被完美转发到可调用对象中 |
| `thread(const thread&) = delete;`                                                         | 禁止拷贝构造函数，线程对象不可被复制                                                                         |
| `thread(thread&& x) noexcept;`                                                            | 移动构造函数，将另一个线程对象的所有权转移到当前线程对象中。原线程对象变为未关联任何线程的状态               |

**默认构造函数**  

```cpp
// 简单例子
std::thread t;
```
创建一个空的线程对象，此时`t`不关联任何实际线程并且没有任何交给新线程执行的函数。可以通过后续的移动操作（如`std::move`）将其与一个实际线程关联，例如下面的代码：

```cpp
#include <iostream>
#include <thread>

void test()
{
	std::cout << "test" << std::endl;
}

// 注释
int main()
{
	// 创建空的线程
	std::thread t;

	// 后续需要使用上面的线程需要单独再创建一个线程
	std::thread t1(test);
	t = std::move(t1);
	// 不能单独复制一个非右值对象
	// t = t1;

	t.join();

	return 0;
}
```

**带可调用对象的构造函数（最常用）**

```cpp
// 简单例子
void foo(int x) 
{ 
    std::cout << x << std::endl; 
}
std::thread t(foo, 42);
```

第一个参数是一个可调用对象（如函数、lambda表达式、函数对象等），后面的参数是传递给该可调用对象的参数

**默认情况下，创建一个线程对象后，该线程会立即执行**

但是，需要注意的是，如果函数的参数需要接收的是引用类型，那么在传递参数时一定要确保传递给线程执行函数的参数也是一个引用才能确保引用有效。存在这个问题的本质原因是创建线程时并不是直接将参数传递给线程执行函数，而是经过了一层拷贝，此时线程执行函数接收到的参数是拷贝后的副本，而不是原始参数的引用。为了解决这个问题，可以使用`std::ref`函数将参数包装成引用类型，这样在线程执行函数中就可以接收到原始参数的引用

```cpp
#include <iostream>
#include <thread>

void test1(int &x)
{
	std::cout << "修改前：x为 " << x << std::endl;
	++x;
	std::cout << "修改后：x为 " << x << std::endl;
}

// 注释
int main()
{
	int x = 1;

	std::thread t(test1, x);

	t.join();

	return 0;
}

// 输出
修改前：x为 1
修改后：x为 2
```

**禁止拷贝构造函数**  

```cpp
std::thread t1(foo, 42);
std::thread t2 = t1; // 编译错误
```
线程对象不可被复制，因为线程资源是独占的，不能同时由多个线程对象管理，但是可以将控制权转移，即使用`std::move`，具体例子在上面已经给出

**移动构造函数**  

```cpp
std::thread t1(foo, 42);
std::thread t2(t1); // t1的所有权转移给t2
```

上面的例子中，`t1`的所有权被转移给`t2`，`t1`变为未关联任何线程的状态

### 成员函数

以下是C++11中`std::thread`类的成员函数列表：

| 成员函数                        | 说明                                                                                                                                 |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `get_id() const noexcept;`      | 返回线程的ID（`std::thread::id`类型）。如果线程对象未关联任何线程，则返回默认构造的`std::thread::id`                                 |
| `joinable() const noexcept;`    | 检查线程是否可被`join`或`detach`。如果线程对象关联了一个有效的线程且尚未被`join`或`detach`，则返回`true`；否则返回`false`            |
| `join();`                       | 阻塞当前线程，直到被调用的线程完成执行。调用后，线程对象变为不可`join`状态（即不再关联任何线程）。每个线程对象只能调用一次`join`     |
| `detach();`                     | 将线程与线程对象分离，使其在后台独立运行。调用后，线程对象不再关联该线程，无法再通过该对象管理线程。每个线程对象只能调用一次`detach` |
| `swap(thread& other) noexcept;` | 交换两个线程对象的内容。                                                                                                             |

示例代码：

```cpp
#include <iostream>
#include <thread>
#include <chrono>

void worker(int n) 
{
    std::cout << "线程 " << std::this_thread::get_id() << " 开始工作，参数: " << n << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "线程 " << std::this_thread::get_id() << " 工作完成" << std::endl;
}

int main() 
{
    // 默认构造函数创建空线程
    std::thread t1;
    std::cout << "t1 ID: " << t1.get_id() << std::endl;
    std::cout << "t1 是否可join: " << std::boolalpha << t1.joinable() << std::endl;
    
    // 创建实际工作的线程
    std::thread t2(worker, 2);
    std::cout << "t2 ID: " << t2.get_id() << std::endl;
    // std::boolalpha 是一个格式化标志，用于将布尔值输出为 "true" 或 "false"
    std::cout << "t2 是否可join: " << t2.joinable() << std::endl;
    
    // 创建另一个工作线程
    std::thread t3(worker, 3);
    
    // 使用swap交换两个线程
    std::cout << "交换前 - t2 ID: " << t2.get_id() << ", t3 ID: " << t3.get_id() << std::endl;
    t2.swap(t3);
    std::cout << "交换后 - t2 ID: " << t2.get_id() << ", t3 ID: " << t3.get_id() << std::endl;
    
    // 使用join等待线程完成
    if (t2.joinable()) 
    {
        std::cout << "等待t2完成..." << std::endl;
        t2.join();
        std::cout << "t2已完成" << std::endl;
    }
    
    // 使用detach分离线程
    if (t3.joinable()) 
    {
        std::cout << "分离t3..." << std::endl;
        t3.detach();
        std::cout << "t3已分离，t3是否可join: " << t3.joinable() << std::endl;
    }
    
    return 0;
}
```

参考输出：

```
t1 ID: 0
t1 是否可join: false
t2 ID: 39880
t2 是否可join: true
交换前 - t2 ID: 39880, t3 ID: 36264
交换后 - t2 ID: 36264, t3 ID: 39880
等待t2完成...
线程 39880 开始工作，参数: 线程 36264 开始工作，参数: 23

线程 39880 工作完成
线程 36264 工作完成
t2已完成
分离t3...
t3已分离，t3是否可join: false
```

需要注意的是，每个线程对象在其生命周期结束前必须明确调用`join`或`detach`，否则程序会调用`std::terminate`终止运行，例如：

```cpp
std::thread t([] {});
if (t.joinable()) {
    t.join(); // 或者 t.detach();
}
```

### `this_thread`命名空间

在C++11中，`std::this_thread`是一个命名空间，提供了与当前线程相关的功能。它主要用于获取当前线程的信息、控制当前线程的执行（如暂停或休眠），以及设置线程的名称（在某些实现中）。以下是`std::this_thread`命名空间中的主要函数及其功能：

| 函数                                                                | 说明                                             |
| ------------------------------------------------------------------- | ------------------------------------------------ |
| `std::this_thread::get_id()`                                        | 返回当前线程的ID（`std::thread::id`类型）        |
| `std::this_thread::yield()`                                         | 提示调度器让出当前线程的时间片，允许其他线程运行 |
| `std::this_thread::sleep_for(const chrono::duration& rel_time)`     | 让当前线程暂停指定的持续时间                     |
| `std::this_thread::sleep_until(const chrono::time_point& abs_time)` | 让当前线程暂停，直到指定的时间点                 |

!!! note

    在上面的函数中，对于`yield`函数来说，在不同的操作系统上可能会有不同的表现，具体表现取决于操作系统的调度策略和实现，并不是所有的操作系统都保证`yield`函数一定会让出时间片

示例代码：

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <iomanip> // 用于格式化输出时间

void print_time(const std::string& message) 
{
    auto now = std::chrono::system_clock::now();
    auto now_c = std::chrono::system_clock::to_time_t(now);
    std::cout << message << " - 时间: " 
              << std::put_time(std::localtime(&now_c), "%H:%M:%S") << std::endl;
}

int main() 
{
    // 1. 获取当前线程ID
    std::cout << "当前线程ID: " << std::this_thread::get_id() << std::endl;
    
    // 2. 使用yield让出时间片
    std::cout << "准备让出时间片..." << std::endl;
    std::this_thread::yield();
    std::cout << "继续执行..." << std::endl;
    
    // 3. 使用sleep_for暂停指定时间
    print_time("准备休眠2秒");
    std::this_thread::sleep_for(std::chrono::seconds(2));
    print_time("休眠结束");
    
    // 4. 使用sleep_until暂停到指定时间点
    auto now = std::chrono::system_clock::now();
    auto wake_time = now + std::chrono::seconds(3);
    
    print_time("准备休眠到指定时间点(当前时间+3秒)");
    std::this_thread::sleep_until(wake_time);
    print_time("到达指定时间点，继续执行");
    
    return 0;
}
```

参考输出：

```
当前线程ID: 26096
准备让出时间片...
继续执行...
准备休眠2秒 - 时间: 19:23:48
休眠结束 - 时间: 19:23:50
准备休眠到指定时间点(当前时间+3秒) - 时间: 19:23:50
到达指定时间点，继续执行 - 时间: 19:23:53
```

## 互斥锁库`<mutex>`

在C++11中，标准库提供了多种互斥锁（mutex）类型和相关工具，用于实现线程间的同步。这些互斥锁和工具位于`<mutex>`头文件中。以下是C++11中互斥锁库的完整列表，并附上详细说明。

---

## C++11中的互斥锁类型

| 互斥锁类型                   | 说明                                                                                   |
| ---------------------------- | -------------------------------------------------------------------------------------- |
| `std::mutex`                 | 最基本的互斥锁类型，提供独占锁定功能。支持`lock()`、`unlock()`和`try_lock()`操作       |
| `std::recursive_mutex`       | 递归互斥锁，允许同一线程多次锁定同一个互斥锁，但必须解锁相同次数才能释放锁。           |
| `std::timed_mutex`           | 带超时功能的互斥锁，支持尝试锁定一段时间后放弃（使用`try_lock_for`和`try_lock_until`） |
| `std::recursive_timed_mutex` | 结合了递归互斥锁和带超时功能的互斥锁特性                                               |

对于基本的`mutex`来说，使用方式与Linux下的`pthread_mutex_t`类似，使用`lock()`加锁，使用`unlock()`解锁，使用`try_lock()`尝试加锁，加锁成功返回`true`，加锁失败返回`false`。此处不再赘述

下面介绍递归锁和带超时的锁

在一般场景下，直接使用普通的锁完全够用，但是在下面的情况下，如果使用普通的锁，可能会出现死锁的情况，例如：

```cpp
#include <mutex>

// 定义一个递归函数
void recursion(int n, std::mutex& mtx, int &x)
{
	// 加锁保护临界区资源
	mtx.lock();
	if (n == 0)
    {
        mtx.unlock();
		return;
    }
	for (int i = 0; i < n; i++)
		++x;
	recursion(n - 10, mtx, x);
	mtx.unlock();
}

int main()
{
	int n = 100;
	int x = 0;
	std::mutex mtx;
	// 注意使用引用传递
	std::thread t(recursion, n, std::ref(mtx), std::ref(x));

	t.join();
	return 0;
}
```

在上面的代码中，第一次调用`recursion`函数时，会加锁保护临界区资源，但是在第一次递归调用时，因为调用递归的位置在释放锁之前，此时当前线程再次进入`recursion`函数就会开始尝试加锁，但是因为第一次调用并没有释放锁，这就导致当前线程会一直等待锁的释放，这就导致了死锁的情况。这也侧面说明了当前`recursion`函数是[不可重入](https://www.help-doc.top/Linux/18.%20Linux%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/18.%20Linux%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html#_11)的

基于这个问题，就需要使用递归锁：

```cpp
// 定义一个递归函数
void recursion(int n, std::recursive_mutex& mtx, int &x)
{
	// 加锁保护临界区资源
	mtx.lock();
	if (n == 0)
	{
		mtx.unlock(); // 确保在返回前解锁
		return;
	}
	for (int i = 0; i < n; i++)
		++x;
	recursion(n - 10, mtx, x);
	mtx.unlock();
}

int main()
{
	int n = 100;
	int x = 0;
	// 使用递归锁
	std::recursive_mutex mtx;
	// 注意使用引用传递
	std::thread t(recursion, n, std::ref(mtx), std::ref(x));

	t.join();
	return 0;
}
```

接下来是超时锁`timed_mutex`，超时锁本质就是不让线程持续阻塞，而是在指定的时间内尝试加锁，如果加锁成功就继续执行，如果加锁失败就返回。例如下面的代码：

```cpp
void test(int n, std::timed_mutex &tmtx, int &x)
{
	// 不要直接使用lock
	// tmtx.lock();
	// 使用try_lock_for
	while (tmtx.try_lock_for(std::chrono::milliseconds(1000));)
	{
		for (int i = 0; i < n; i++)
			++x;
	}

	tmtx.unlock();
}

int main()
{
	std::timed_mutex tmtx;
	int x = 1;
	int n = 100;

	std::thread t(test, n, std::ref(tmtx), std::ref(x));

	std::thread t1(test, n, std::ref(tmtx), std::ref(x));

	t.join();
	t1.join();

	return 0;
}
```

需要注意的是，如果使用超时锁想实现防止线程阻塞在等待锁的过程，需要使用`try_lock_for`或者`try_lock_until`，如果直接使用`timed_mutex`的`lock`系列接口，那么<a href="javascript:;" class="custom-tooltip" data-title="参考文档对timed_mutex的lock函数的描述：The calling thread locks the timed_mutex, blocking if necessary (it behaves exactly as in mutex)">`timed_mutex`和普通的`mutex`没有任何区别</a>

## C++11中的互斥锁相关工具

| 工具类型                             | 说明                                                                     |
| ------------------------------------ | ------------------------------------------------------------------------ |
| `std::lock_guard<std::mutex>`        | 简单的RAII风格锁管理器，自动在构造时加锁，在析构时解锁。不可手动解锁。   |
| `std::unique_lock<std::mutex>`       | 更灵活的RAII风格锁管理器，支持延迟加锁、手动解锁以及与条件变量配合使用。 |
| `std::call_once` 和 `std::once_flag` | 用于确保某段代码在多线程环境中仅执行一次。                               |

对于`lock_guard`来说，在[Linux线程互斥与同步](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.html#craii)已经模拟实现了一份`MutexGuard`，基本原理就类似于`MutexGuard`

接下来主要看`unique_lock`。`unique_lock`可以理解为是`lock_guard`的一种升级版本，基本使用方式和`lock_guard`类似，所以这里就不再介绍基本使用方式

`unique_lock`的灵活性在于它可以由程序员控制加锁和解锁的时机，例如下面的三种构造函数：

1. `unique_lock (mutex_type& m, try_to_lock_t tag);`：尝试加锁，如果加锁失败就不会阻塞当前线程，底层调用的是`try_lock`。但是`try_lock_t`因为是非阻塞的，不论是否获取到锁，都会返回一个`unique_lock`对象，即这个`unique_lock`是否真的已经管理到指定锁对象是未知的，所以需要判断是否加锁成功。具体如何判断在下面会具体介绍
2. `unique_lock (mutex_type& m, defer_lock_t tag) noexcept;`：缓上锁，即`unique_lock`接收一个锁对象时不会对这个锁进行加锁，具体加锁时机由程序员决定，但是会自动释放锁对象
3. `unique_lock (mutex_type& m, adopt_lock_t tag);`：领养锁，即此时`unique_lock`可以接受一个（假设）已经加锁的锁对象，并且会自动释放锁对象

要使用上面的三种构造函数，需要使用三种类型：

1. `try_to_lock	`
2. `defer_lock`
3. `adopt_lock`

首先看后两个`defer_lock`和`adopt_lock`，示例代码如下：

```cpp
std::mutex mtx;
// 1. defer_lock_t 示例：延迟加锁
void defer_lock_example(int id)
{
    // 创建锁但不立即加锁
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);

    // 执行一些不需要锁的操作
    std::cout << "线程 " << id << " 正在执行不需要锁的操作..." << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(200));

    // 在需要的时候手动加锁
    std::cout << "线程 " << id << " 尝试获取锁..." << std::endl;
    lock.lock();
    std::cout << "线程 " << id << " 获取到了锁" << std::endl;

    // 执行需要锁保护的操作
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    // 可以手动解锁
    lock.unlock();
    std::cout << "线程 " << id << " 手动释放了锁" << std::endl;

    // 执行更多不需要锁的操作
    std::this_thread::sleep_for(std::chrono::milliseconds(200));

    // 可以再次加锁
    lock.lock();
    std::cout << "线程 " << id << " 再次获取到了锁" << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(300));

    // 锁会在unique_lock析构时自动释放
}

// 2. adopt_lock_t 示例：接管已加锁的互斥量
void adopt_lock_example(int id)
{
    // 先手动加锁
    mtx.lock();
    std::cout << "线程 " << id << " 手动获取了锁" << std::endl;

    // 创建unique_lock并接管已加锁的互斥量
    {
        std::unique_lock<std::mutex> lock(mtx, std::adopt_lock);
        std::cout << "线程 " << id << " 的unique_lock接管了锁的所有权" << std::endl;

        // 执行需要锁保护的操作
        std::this_thread::sleep_for(std::chrono::milliseconds(800));

        std::cout << "线程 " << id << " 即将退出作用域，锁将被自动释放" << std::endl;
        // 锁会在unique_lock析构时自动释放
    }

    // 此时锁已被释放，可以执行其他操作
    std::cout << "线程 " << id << " 的锁已被释放" << std::endl;
}

int main()
{
    std::cout << "\n=== defer_lock 示例 ===" << std::endl;
    {
        std::thread t(defer_lock_example, 1);
        t.join();
    }

    std::cout << "\n=== adopt_lock 示例 ===" << std::endl;
    {
        std::thread t(adopt_lock_example, 1);
        t.join();
    }

    return 0;
}
```

参考输出：

```
=== defer_lock 示例 ===
线程 1 正在执行不需要锁的操作...
线程 1 尝试获取锁...
线程 1 获取到了锁
线程 1 手动释放了锁
线程 1 再次获取到了锁

=== adopt_lock 示例 ===
线程 1 手动获取了锁
线程 1 的unique_lock接管了锁的所有权
线程 1 即将退出作用域，锁将被自动释放
线程 1 的锁已被释放
```

接下来看`try_to_lock`，在上面提到过，`try_to_lock`会尝试加锁，需要判断是否加锁成功，这里可以通过调用`owns_lock`来判断，当然也可以直接通过`operator bool`来判断，示例代码如下：

```cpp
std::mutex mtx;

void try_lock_example(int id)
{
    // 尝试获取锁，如果失败则不阻塞
    std::unique_lock<std::mutex> lock(mtx, std::try_to_lock);

    if (lock.owns_lock()) // 可以直接使用if(lock)，调用operator bool
    {
        // 成功获取到锁
        std::cout << "线程 " << id << " 获取到了锁" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        std::cout << "线程 " << id << " 完成工作并释放锁" << std::endl;
    }
    else 
    {
        // 未能获取到锁
        std::cout << "线程 " << id << " 未能获取锁，执行替代操作" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    // 锁会在unique_lock析构时自动释放（如果已获取）
}

int main()
{
    std::cout << "=== try_to_lock 示例 ===" << std::endl;
    {
        // 创建两个线程同时尝试获取锁
        std::thread t1(try_lock_example, 1);
        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 确保t1先运行
        std::thread t2(try_lock_example, 2);

        t1.join();
        t2.join();
    }

    return 0;
}
```

参考输出：

```
=== try_to_lock 示例 ===
线程 1 获取到了锁
线程 2 未能获取锁，执行替代操作
线程 1 完成工作并释放锁
```

除了上面的三种构造函数，`unique_lock`还提供了一些其他的成员函数：

1. `release()`：释放当前锁对象，并且返回该锁对象指针，不再管理该锁（需要程序员自己释放锁）
2. `mutex()`：获取`unique_lock`管理的锁对象的指针

这两个成员函数不具体介绍使用，了解即可

## 防止死锁的函数`lock`和`try_lock`

