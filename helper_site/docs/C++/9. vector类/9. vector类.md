# vector类

## vector介绍

1. vector是表示可变大小数组的序列容器。就像数组一样，vector也采用连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
2. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
3. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。
4. 与其他动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。

## vetor类定义

```C++
template < class T, class Alloc = allocator<T> > class vector; 
```

vector类为类模板，所以在使用时需要带上类型表示一个具体的类，例如数据类型为`int`类型的vector使用时需要写为`vector<int>`

## vector常见构造

| 构造函数                         | 函数原型                                                     |
| -------------------------------- | ------------------------------------------------------------ |
| 无参构造函数                     | `explicit vector ();`                                        |
| 使用指定个数个元素构造函数       | `explicit vector (size_type n, const value_type& val = value_type());` |
| 使用指定对象的迭代器区间进行构造 | `template <class InputIterator>``         vector (InputIterator first, InputIterator last);` |
| 拷贝构造函数                     | `vector (const vector& x);`                                  |

!!! note
    上面表格中的前三个构造函数均含有自定义空间配置器并带有缺省值，目前只使用默认即可

!!! note
    使用vector类需要包含头文件`<vector>`

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //无参构造函数
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }

    return 0;
}
输出结果：
1 2 3 4
```

上面的代码中，使用vector类的无参构造函数时创建了一个数据类型为`int`类型的vector类对象，编译器不会自动开辟空间因为没有数据，所以当前的`size`为0，可以使用`push_back()`函数进行数据插入，插入数据时会动态分配空间

<img src="image\image.png">

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //使用指定个数个数据构造
    vector<int> v(10, 1);//使用10个1进行构造
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }

    return 0;
}
输出结果：
1 1 1 1 1 1 1 1 1 1
```

如果不指定初始化内容，则默认初始化为0

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10);

    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
0 0 0 0 0 0 0 0 0 0
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //使用其他对象的迭代器区间进行构造
    vector<int> v(10, 1);
    vector<int> v1(v.begin(), v.end());

    for (size_t i = 0; i < v1.size(); i++)
    {
        cout << v1[i] << " ";
    }
    cout << endl;
    string s1 = "hello world";
    vector<char> v2(s1.begin(), s1.end());
    for (size_t i = 0; i < v2.size(); i++)
    {
        cout << v2[i] << " ";
    }

    return 0;
}
输出结果：
1 1 1 1 1 1 1 1 1 1
h e l l o   w o r l d
```

### 数组地址作为迭代器参数

因为可以理解为指向第一个元素的指针和指向最后一个元素的下一个位置的指针，所以可以将数组名作为开始迭代器，将数组最后一个元素的下一个位置为结尾迭代器对vector对象进行构造

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int arr[] = { 2,2,1,1,1,2,2 };
    vector<int> v(arr, arr + sizeof(arr) / sizeof(int));
    for(auto num : v)
    {
        cout << num << " ";
    }
    cout << endl;
    //也可以使用库中的begin()和end()接受数组起始位置和终止位置进行构造
    int arr[] = { 1,2,3,4,5 };
    vector<int> v1(begin(arr), end(arr));

    for (auto num : v1)
    {
        cout << num << " ";
    }
    return 0;
}
输出结果：
2 2 1 1 1 2 2
1 2 3 4 5
```

### vector类元素直接初始化

对于vector类来说，可以直接使用类型相同的不同个数的元素进行构造

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v{ 1,2,3,4,5 };

    for (auto num : v)
    {
        cout << num << " ";
    }

    return 0;
}
输出结果：
1 2 3 4 5
```

## vector类中的容量操作

| 函数         | 功能                                       |
| ------------ | ------------------------------------------ |
| `size()`     | 获取当前存储的有效数据个数                 |
| `resize()`   | 修改调用对象的容量并初始化为指定内容       |
| `capacity()` | 获取当前存储的空间大小                     |
| `reserve()`  | 扩容调用对象的空间大小                     |
| `max_size()` | 获取调用对象空间可以存储的有效数据最大个数 |

### `size()`函数与`capacity()`函数

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    cout << "指定大小为10时：\n";
    vector<int> v(10, 1);

    cout << v.size() << endl;
    cout << v.capacity() << endl;

    vector<int> v1;
    v1.push_back(1);
    v1.push_back(1);
    v1.push_back(1);
    v1.push_back(1);
    cout << "插入四个数据时：\n";
    cout << v1.size() << endl;
    cout << v1.capacity() << endl;
    cout << "插入五个数据时：\n";
    v1.push_back(1);
    cout << v1.size() << endl;
    cout << v1.capacity() << endl;

    return 0;
}
输出结果：
指定大小为10时：
10
10
插入四个数据时：
4
4
插入五个数据时：
5
6
```

在VS下，vetor中的`capacity`不同于string中的`capacity`，在vector类中，除指定大小以外，当只有四个数据时，`capacity`大小等于`size`的大小，当数据个数超过四个时，`capacity`大于`size`（`capacity`以1.5倍增长），而string类的`capacity`大于`size`的大小

### `resize()`函数

使用`resize()`函数可以改变调用对象的`size`和`capacity`大小，如果指定的大小小于`size`时相当于删除数据，当指定大小大于`size`时则作用为扩容＋初始化（对于`int`默认初始化为0）

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10, 1);

    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;

    v.resize(20);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;

    v.resize(5);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    //指定大小小于当前的size时，再指定初始化内容时不会修改原始内容
    v.resize(3, 3);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0
1 1 1 1 1
1 1 1
```

### `reserve()`函数

使用`reserve()`函数可以更改调用对象的`capacity`的大小

!!! note
    注意，如果指定大小小于当前的`capacity`时，则不会做任何处理

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10, 1);
    cout << "原始大小：\n";
    cout << v.capacity() << endl;
    cout << v.size() << endl;

    cout << "扩容到20：\n";
    v.reserve(20);
    cout << v.capacity() << endl;
    cout << v.size() << endl;

    cout << "扩容到5：\n";
    v.reserve(5);
    cout << v.capacity() << endl;
    cout << v.size() << endl;

    return 0;
}
输出结果：
原始大小：
10
10
扩容到20：
20
10
扩容到5：
20
10
```

在VS下，vector类同string类`reserve()`函数扩容倍数（1.5倍）基本一致

```c++
#include <iostream>
#include <vector>
using namespace std;
void TestVectorExpand()
{
    size_t sz;
    vector<int> v;
    sz = v.capacity();
    cout << sz << endl;
    cout << "making v grow:\n";
    for (int i = 0; i < 100; ++i)
    {
        v.push_back(i);
        if (sz != v.capacity())
        {
            sz = v.capacity();
            cout << "capacity changed: " << sz << '\n';
        }
    }
}

int main()
{
    TestVectorExpand();
    return 0;
}
输出结果：
0
making v grow:
capacity changed: 1
capacity changed: 2
capacity changed: 3
capacity changed: 4
capacity changed: 6
capacity changed: 9
capacity changed: 13
capacity changed: 19
capacity changed: 28
capacity changed: 42
capacity changed: 63
capacity changed: 94
capacity changed: 141
```

### `max_size()`函数

使用`max_size()`函数可以获取调用对象空间可以存储的数据类型对应可以存储的数据总个数

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    cout << v.max_size() << endl;

    vector<char> v1;
    cout << v1.max_size() << endl;

    return 0;
}
输出结果：
4611686018427387903
9223372036854775807
```

## vector类中的数据遍历操作

| 函数              | 功能                                                         |
| ----------------- | ------------------------------------------------------------ |
| `begin()`+`end()` | `begin`获取第一个数据的迭代器 + `end`获取最后一个数据下一个位置的迭代器 |
| `operator[]()`    | vector类中的`[]`运算符重载函数                               |
| 范围`for()`       | C++11支持更简洁的范围`for`的新遍历方式                       |
| `at()`            | 指定位置遍历调用对象空间内容                                 |

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v1;

    v1.push_back(1);
    v1.push_back(2);
    v1.push_back(3);
    v1.push_back(4);
    v1.push_back(5);
    v1.push_back(6);

    //迭代器遍历
    vector<int>::iterator it = v1.begin();
    while (it != v1.end())
    {
        cout << *it << " ";
        it++;
    }
    cout << endl;
    //下标遍历
    for (size_t i = 0; i < v1.size(); i++)
    {
        cout << v1[i] << " "; 
    }
    cout << endl;
    //范围for
    for (auto num : v1)
    {
        cout << num << " ";
    }
    return 0;
}
输出结果：
1 2 3 4 5 6
1 2 3 4 5 6
1 2 3 4 5 6
```

### `operator[]()`与`at()`函数

`operator[]()`函数与`at()`函数都是下标遍历，区别是`operator[]()`函数越界访问时断言报错，而`at()`函数抛出异常

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10, 1);
    cout << v[11] << endl;

    return 0;
}
```

<img src="image\image1.png">

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10, 1);
    try
    {
        cout << v.at(11) << endl;    
    }
    catch (const std::exception& e)
    {
        cout << e.what() << endl;;
    }

    return 0;
}
输出结果：
invalid vector subscript
```

### vector类中的迭代器遍历

| 函数      | 功能                                                         |
| --------- | ------------------------------------------------------------ |
| `begin()` | `iterator begin();`（非`const`对象调用）`const_iterator begin() const;`（`const`对象调用） |
| `end()`   | `iterator end();`（非`const`对象调用）`const_iterator end() const;`（`const`对象调用） |

#### 正向遍历`begin()`和`end()`迭代器——非`const`

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v(10, 1);
    //正向迭代器——非const
    vector<int>::iterator it = v.begin();
    while (it != v.end())
    {
        *it = 2;//可修改
        cout << *it << " ";
        it++;
    }

    return 0;
}
输出结果：
2 2 2 2 2 2 2 2 2 2
```

#### 逆向遍历`rbegin()`和`rend()`迭代器——非`const`

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    //逆向迭代器——非const
    vector<int>::reverse_iterator rit = v.rbegin();
    while (rit != v.rend())
    {
        (*rit)++;//可修改
        cout << *rit << " ";
        rit++;
    }

    return 0;
}
输出结果：
5 4 3 2
```

!!! note
    逆向遍历也可也使用`rbegin()`和`rend()`

#### 正向遍历`begin()`和`end()`迭代器——`const`

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    vector<int>::const_iterator cit = v.begin();
    while (cit != v.end())
    {
        //(*cit)++;不可修改
        cout << *cit << " ";
        cit++;
    }
    return 0;
}
输出结果：
1 2 3 4
```

!!! note
    `const`逆向遍历也可以使用`cbegin()`和`cend()`

#### 逆向遍历`rbegin()`和`rend()`迭代器——`const`

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    vector<int>::const_reverse_iterator crit = v.rbegin();
    while (crit != v.rend())
    {
        //(*crit)++;不可修改
        cout << *crit << " ";
        crit++;
    }

    return 0;
}
输出结果：
4 3 2 1
```

!!! note
    `const`逆向遍历也可以使用`rcbegin()`和`rcend()`

## vector类中数据修改操作

| 函数          | 功能                                   |
| ------------- | -------------------------------------- |
| `assign()`    | 为调用对象空间重新分配内容为指定内容   |
| `push_back()` | 在调用对象空间中的已有内容后方插入内容 |
| `pop_back()`  | 删除调用对象空间中的最后一个内容       |
| `insert()`    | 在调用对象空间中指定位置插入内容       |
| `erase()`     | 删除调用对象空间中指定内容             |
| `swap()`      | 交换调用对象的内容以及指定对象的内容   |
| `find()`      | 查找函数（算法库中的模板函数）         |

### `assign()`函数

使用`assign()`函数可以为调用对象分配指定内容，如果调用对象中原来有内容，将会替换为指定内容，并改变`size`为指定内容大小

|      | 函数原型                                                     |
| ---- | ------------------------------------------------------------ |
|      | `template <class InputIterator> void assign (InputIterator first, InputIterator last);`（使用一个对象的迭代器区间为调用对象分配内容） |
|      | `void assign (size_type n, const value_type& val);`（指定`n`个内容为调用对象分配） |

```C++
//使用一个对象的迭代器区间为调用对象分配内容
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //vector<int> v(5, 1);
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    for (auto num : v)
    {
        cout << num << " ";
    }
    cout << endl;

    vector<int> v1(10, 2);

    //v.assign(v1.begin(), v1.end());
    v.assign(v1.begin(), v1.end());
    for (auto num : v)
    {
        cout << num << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
2 2 2 2 2 2 2 2 2 2

//指定n个内容为调用对象分配
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    //vector<int> v(5, 1);
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    for (auto num : v)
    {
        cout << num << " ";
    }
    cout << endl;

    //vector<int> v1;
    //v1.push_back(5);
    //v1.push_back(6);
    //v1.push_back(7);
    //v1.push_back(8);

    //v.assign(v1.begin(), v1.end());
    v.assign(10, 5);
    for (auto num : v)
    {
        cout << num << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
5 5 5 5 5 5 5 5 5 5
```

### `push_back()`函数

使用`push_back()`函数可以在调用对象空间中插入一个指定内容

| 函数          | 函数原型                                  |
| ------------- | ----------------------------------------- |
| `push_back()` | `void push_back (const value_type& val);` |

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
```

### `pop_back()`函数

使用`pop_back()`函数可以删除调用对象内容中的最后一个数据

| 函数         | 函数原型           |
| ------------ | ------------------ |
| `pop_back()` | `void pop_back();` |

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    v.pop_back();
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
1 2 3
```

### `insert()`函数

使用`insert()`函数可以调用对象空间中的指定位置插入指定内容

!!! note
    插入过程中涉及数据的挪动，故不推荐频繁使用

| 函数       | 函数原型                                                     |
| ---------- | ------------------------------------------------------------ |
| `insert()` | `iterator insert (iterator position, const value_type& val);`（在指定的迭代器位置前插入内容`val`） |
|            | `void insert (iterator position, size_type n, const value_type& val);`（在指定的迭代器位置前开始插入`n`个`val`） |
|            | `template <class InputIterator>`    `void insert (iterator position, InputIterator first, InputIterator last);`（在指定的迭代器位置前开始插入一个其他对象对应的迭代器区间中的内容） |

!!! note
    使用迭代器插入数据时尽量考虑迭代器失效问题，可能指定位置是野指针

```C++
//在指定的的迭代器位置后插入内容val
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    v.insert(v.begin() + 3, 5);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
1 2 3 5 4

//在指定的迭代器位置后开始插入n个val
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    v.insert(v.begin() + 3, 5, 10);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    return 0;
}
输出结果：
1 2 3 4
1 2 3 10 10 10 10 10 4

//在指定的迭代器位置后开始插入一个其他对象对应的迭代器区间中的内容
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    vector<double> v1;
    v1.push_back(5.2);
    v1.push_back(6.3);
    v1.push_back(7.4);
    v1.push_back(8.5);

    //根据调用对象的类型决定强制转换的类型
    v.insert(v.begin() + 3, v1.begin(), v1.end());//将double强制转换成int类型存入int类型的vector对象
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    v1.insert(v1.begin() + 3, v.begin(), v.end());//将int强制转换成double类型存入double类型的vector对象
    for (size_t i = 0; i < v1.size(); i++)
    {
        cout << v1[i] << " ";
    }

    return 0;
}
输出结果：
1 2 3 4
1 2 3 5 6 7 8 4
5.2 6.3 7.4 1 2 3 5 6 7 8 4 8.5
```

### `erase()`函数

使用`erase()`函数可以删除调用对象指定位置的指定内容

| 函数原型                                                     |
| ------------------------------------------------------------ |
| `iterator erase (iterator position);`（删除指定位置的一个数据） |
| `iterator erase (iterator first, iterator last);`（删除迭代器区间中的内容） |

!!! note
    使用迭代器删除数据时注意迭代器失效问题，在VS和g++下结果不同，可能指定位置导致结果未定义

```C++
//删除指定位置的一个数据
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;

    vector<int>::iterator it = v.begin() + 1;
    v.erase(it);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    //不可以再删除迭代器一开始指向的位置，存在迭代器失效问题
    //v.erase(it);
    //如果还需要删除下标为1的位置需要再将迭代器更新
    it = v.begin() + 1;
    v.erase(it);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }

    return 0;
}
输出结果：
1 2 3 4
1 3 4
1 4

//删除迭代器区间中的内容
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;
    v.erase(v.begin() + 2, v.end());
    for (size_t i = 0; i < v.size(); i++)
    {
        cout << v[i] << " ";
    }
    cout << endl;

    return 0;
}
输出结果：
1 2 3 4
1 2
```

### `swap()`函数

使用`swap()`函数可以交换调用对象和指定对象中的数据

```C++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    vector<int>    v1(5, 1);

    cout << "交换前：\n";
    cout << "v的size：" << v.size() << endl;
    cout << "v的capacity：" << v.capacity() << endl;
    for (auto num : v)
    {
        cout << num << " ";
    }
    cout << endl;
    cout << "v1的size：" << v1.size() << endl;
    cout << "v1的capacity：" << v1.capacity() << endl;
    for (auto num : v1)
    {
        cout << num << " ";
    }

    v.swap(v1);

    cout << "\n交换后：\n";
    cout << "v的size：" << v.size() << endl;
    cout << "v的capacity：" << v.capacity() << endl;
    for (auto num : v)
    {
        cout << num << " ";
    }
    cout << endl;
    cout << "v1的size：" << v1.size() << endl;
    cout << "v1的capacity：" << v1.capacity() << endl;
    for (auto num : v1)
    {
        cout << num << " ";
    }
    return 0;
}
输出结果：
交换前：
v的size：4
v的capacity：4
1 2 3 4
v1的size：5
v1的capacity：5
1 1 1 1 1
交换后：
v的size：5
v的capacity：5
1 1 1 1 1
v1的size：4
v1的capacity：4
1 2 3 4
```

### `find()`函数

使用`find()`函数可以在指定迭代器区间查找指定内容

!!! note
    `find()`函数不是vector库中的函数，使用时可以选择包含头文件`<algorithm>`

| 函数原型                                                     |
| ------------------------------------------------------------ |
| `template <class InputIterator, class T>   InputIterator find (InputIterator first, InputIterator last, const T& val);` |

```C++
#include <iostream>
#include <vector>
//#include <algorithm>
using namespace std;

int main()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);

    vector<int>::iterator it = find(v.begin(), v.end(), 3);
    cout << *it << endl;
    return 0;
}
输出结果：
3
```