# 2. 进制转换与类型在内存中存储方式

二进制、八进制、十进制、十六进制是数值的不同表示形式

| 进制     | 底数   | 基数                                           |
| -------- | ------ | ---------------------------------------------- |
| 二进制   | 底为2  | 0，1                                           |
| 八进制   | 底为8  | 0，1，2，3，4，5，6，7                         |
| 十进制   | 底为10 | 0，1，2，3，4，5，6，7，8，9                   |
| 十六进制 | 底为16 | 0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F |

在二进制中，逢二进一；在八进制中，逢八进一；在十进制中，逢十进一；在十六进制中，逢十六进一

## 二进制、八进制与十六进制向十进制转换

转换方法：将需要转换的数值中的每一位乘以该数值当前进制的位权值求和即可转为十进制

对于整数值1101B，12O，9BH：

<img src="images\Snipaste_2024-04-27_16-24-46.png">

对于小数值，以二进制为例，其余进制同理，110.11B

<img src="images\Snipaste_2024-04-27_16-27-35.png">

## 十进制向二进制、八进制与十六进制转换

!!! note
    十进制向其余进制转换需要分两个部分：1.整数部分 2. 小数部分

### 转换整数部分，以二进制为例

对于十进制数值35转换为二进制步骤如下

<img src="images\image.png">

### 转换小数部分，以二进制为例

以十进制数值0.625转换为二进制步骤如下

<img src="images\image1.png">

### 十进制转二进制的巧妙方法

!!! note
    以整数部分为例

十进制数值289转二进制为例

前置知识：

| $2^9$ | $2^8$ | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| 512   | 256   | 128   | 64    | 32    | 16    | 8     | 4     | 2     | 1     |

因为数值289介于512和256之间，故其二进制最高位位权为8，此时已知289二进制最高位为1，即100000000，而因为289 - 256 = 33，可得33 = 32 + 1， 将二进制中32对应的位权和1对应的位权填1其余填0即可，即100100001

| $2^9$ | $2^8$ | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| 512   | 256   | 128   | 64    | 32    | 16    | 8     | 4     | 2     | 1     |
| 0     | 1     | 0     | 0     | 1     | 0     | 0     | 0     | 0     | 1     |

## 二进制向八进制与十六进制转换

### 二进制转八进制

基本思路：每三位二进制数为一组转换为一位八进制数

以二进制数值1101101为例

<img src="images\Snipaste_2024-04-27_13-28-19.png">

### 二进制转十六进制

基本思路：每四位二进制数为一组转换为一位十六进制数

以二进制数值1101101为例

<img src="images\Snipaste_2024-04-27_13-29-31.png">

## 原码、反码与补码

整数的2进制表示方法有三种，即原码、反码和补码

有符号整数的三种表示方法均有符号位和数值位两部分，2进制序列中，最高位的1位是被当做符号

位，剩余的都是数值位。

<img src="images\Snipaste_2024-04-27_13-32-29.png">

符号位都是用0表示“正”，用1表示“负”

### 正数原码、反码与补码

正整数的原、反、补码都相同

### 负数原码、反码与补码

负整数的三种表示方法各不相同。

原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码。

反码：将原码的符号位不变，其他位依次按位取反就可以得到反码。

补码：反码+1就得到补码

!!! note
    补码也可以通过取反+1得到原码

!!! note
    对于整型数值来说：数据存放内存中其实存放的是补码

## 计算机中的单位

### 位、字节和字

位：最小存储单元，单位是`bit`（比特）

字节：常用的计算机存储单位，单位：`byte`（字节），1字节= 8位（二进制数）

字（字长）：设计计算机时给定的自然存储单位（8位计算机，16位计算机，32位计算机，64位计算机）

### 基本单位及数值换算

```C
//常见单位
bit —— 比特位 —— b
byte —— 字节 —— B
KB —— 千字节
MB —— 兆字节
GB
TB
PB
```

| 大单位 | 小单位    | 字节       |
| ------ | --------- | ---------- |
| 1 KB   | 1024 byte | $2^{10}$B  |
| 1 MB   | 1024 KB   | $2^{20}$ B |
| 1 GB   | 1024 MB   | $2^{30}$ B |
| 1 TB   | 1024 TB   | $2^{40}$ B |
| 1 PB   | 1024 PB   | $2^{50}$ B |

## 大端与小端字节序

在内存中，一个内存单元为一个字节大小，超过一个字节的数据在内存中存储的时候，就有存储顺序的问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储

大端字节序：数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处

小端字节序：数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处

例如：⼀个 `16bit` 的 `short` 型 `x` ，在内存中的地址为 `0x0010` ， `x` 的值为 `0x11223344` ，那么`0x44`则为低位数值，依次往高位到`0x11`。对于大端模式，就将 `0x44` 放在低地址中，即 `0x0010` 中，`0x33` 放在高地址中，即 `0x0011` 中，直到高位数值`0x11`。小端模式，刚好相反。我们常用的 `x86` 与`x64`结构是小端模式，而KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

<img src="images\image2.png">

代码验证当前环境是大端字节序还是小端字节序

```C
//测试环境：VS2022 x64
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

union test
{
    int i;
    char c;
}un;

int main()
{
    un.i = 1;
    if (un.c == 1)
    {
        printf("小端字节序\n");
    }
    else
    {
        printf("大端字节序\n");
    }

    return 0;
}
输出结果：
小端字节序
```

## 浮点数在内存中的存储

浮点数类型包括：`float`、`double`以及`long double`类型。这三个类型的精度依次增高

浮点数的表示范围在头文件`float.h`中定义

代码实例展示整数和浮点数的存储方式不同

```C
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

int main()
{
    int n = 9;
    float* pFloat = (float*)&n;
    printf("n的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);
    *pFloat = 9.0;
    printf("num的值为：%d\n", n);
    printf("*pFloat的值为：%f\n", *pFloat);

    return 0;
}
输出结果：
n的值为：9
*pFloat的值为：0.000000
num的值为：1091567616
*pFloat的值为：9.000000
```

### 浮点数在内存中的存储方式

根据国际标准IEEE（电⽓和电⼦⼯程协会）754，任意⼀个⼆进制浮点数V可以表⽰成下⾯的形式：

!!! note

    V  =  $(-1)^S $∗ M ∗ $2^E$​

    - $(-1)^S$表示符号位，当S=0，V为正数；当S=1，V为负数
    - M表示有效数字，M大于等于1但小于2
    - 2E表示指数位

例如：

十进制的5.0，写成二进制是 101.0 ，相当于 1.01×$2^2$，则S=0，M=1.01，E=2

十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×$2^2$ ，则S=1，M=1.01，E=2

IEEE754规定：

对于32位的浮点数，最高的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M

对于64位的浮点数，最高的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M

<img src="images\image3.png">

### 浮点数的存储过程

- 对于数值位M

因为1≤M<2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。

IEEE754规定，在计算机内部保存M时，默认这个数的第⼀位总是1，因此可以被舍去，只保存后面的小数部分。例如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字

- 对于指数位E

!!! note

    E是一个无符号整数类型（`unsigned int`）

如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，因为科学计数法中的E是可以出现负数的，所以IEEE754规定，存⼊内存时E的真实值必须再加上一个中间数，对于32位浮点数的E，这个中间数是127；对于64位浮点数的E，这个中间数是1023。比如，210的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

### 浮点数的取出过程

指数E从内存中取出分成三种情况：

- E不全为0或不全为1

浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效

数字M前加上第一位的1。

例如：0.75的二进制形式为0.11，由于规定正数部分必须为1，即将小数点右移1位，则为1.1*2-1，其

阶码为-1+127(中间值)=126，表示为01111110，而尾数1.1去掉整数部分为1，补齐0到23位10000000000000000000000，则其二进制表示形式为:

```C
0        01111110     10000000000000000000000
符号位S    指数位E            数值位M
```

- E全为0

浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字

```C
例如：
0         00000000             00100000000000000000000
符号位S      指数位E（全为0）            数值位M
```

E全为1

如果有效数字M全为0，表示±无穷大（正负取决于符号位s）

```C
例如：
0         11111111         00010000000000000000000
符号位S     指数位E（全为1）            数值位M
```

代码分析

```C
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

int main()
{
    int n = 9;
    //n为int类型，在内存中以补码形式存储，即00000000000000000000000000001001
    float* pFloat = (float*)&n;//pFloat指针为float*类型的指针，虽然访问也是4个空间，但是因为整数和浮点数的存储方式不同，故pFloat指针访问n地址空间得到的结果和int*类型的指针访问的结果不一样
    printf("n的值为：%d\n", n);//正常打印9
    printf("*pFloat的值为：%f\n", *pFloat);
    //将9的补码00000000000000000000000000001001看做浮点数存储方式
    //即0 00000000 00000000000000000001001，满足指数部分E全为0，指数部分值化为-126，小数部分为0.00000000000000000001001，最后化为0.00000000000000000001001 * 2 ^ (-126)，但因为%f默认打印小数点后六位，故输出0.000000
    *pFloat = 9.0;
    //若将n地址空间的值改为9.0（二进制原码为1001.0）则代表按照浮点数存储方式进行存储S = 0，E = 3 + 127 = 130，M = 001
    //即0 10000010 00100000000000000000000
    printf("num的值为：%d\n", n);//对于%d打印，直接按照补码转原码进行打印
    //即将01000001000100000000000000000000进行转化为原码，即1091567616
    printf("*pFloat的值为：%f\n", *pFloat);//对于%f按照浮点数方式进行打印

    return 0;
}
输出结果：
n的值为：9
*pFloat的值为：0.000000
num的值为：1091567616
*pFloat的值为：9.000000
```

!!! note
    因为浮点数在内存中的存储方式，导致部分浮点数无法精确表示

代码实例

```C
#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

int main()
{
    float f = 99.7f;
    printf("%f\n", f);

    return 0;
}
输出结果：
99.699997
```