# Java的IO流

## 前置小知识

### 分隔符

分隔符一共分为两种：

1. 路径名称分隔符：在路径中用于分隔文件或者文件夹，在Windows下使用`\`表示，在Linux下使用`/`表示
2. 路径分隔符：多个路径之间的分隔，一般使用`;`表示

!!! note
    在Windows下也可以使用`/`表示路径名称分隔符，但是系统默认的路径名称分隔符为`\`

### 父路径

例如，在路径中：`E:\Test\test\test.jpg`

`test.jpg`的父路径即为`E:\Test\test`，对于`test`文件夹来说，其父路径为`E:\Test`，以此类推

## `File`类

### `File`类介绍

`File`类在官方文档中的描述是：文件和目录(文件夹)路径名的抽象表示

本意是：`File`类的对象存储着文件或者目录的路径

### `File`类中的静态成员

对于文件/文件夹的操作经常会使用到路径，其中避免不了出现分隔符，而对于「分隔符」来说，不同的系统有不同的分隔符，所以Java为了确保代码的通用性，提供了两个针对分隔符的静态变量，如下：

1. `static String pathSeparator`：与系统有关的默认路径名称分隔符，在Windows下值为`\`，在Linux下值为`/`
2. `static String separator`：与系统有关的默认路径分隔符，在Windows下值为`;`

### `File`类的构造方法

File类中常用有三种构造方法：

1. `File(String parent, String child)`：根据子路径和父路径一起确定一个完整的路径，使用此构造方法后，实例化的对象中存储的是一个结合父路径和子路径一体的完整路径
2. `File(File parent, String child)`：与第一个构造方法作用相同，不同的是，此构造方法的父路径是`File`对象引用
3. `File(String pathname)`：参数直接填入文件的完整路径

!!! note

    `File`类对象不会检查路径是否是真实存在的路径，所以理论上上面三个构造方法中的路径可以随便写，但是没有意义
    
    如果在路径中不使用Java提供的分隔符常量，注意`\`需要使用`\\`进行转义

基本实例代码如下：

```java
public class Test {
    public static void main(String[] args) {
        // 1. File(String parent, String child)
        File file1 = new File("D:\\", "a.txt");
        System.out.println(file1);
        // 2. File(File parent, String child)
        File file2 = new File("D:\\");
        File file3 = new File(file2, "a.txt");
        System.out.println(file3);
        // 3. File(String pathname)
        File file4 = new File("D:\\a.txt");
        System.out.println(file4);
    }
}

输出结果：
D:\a.txt
D:\a.txt
D:\a.txt
```

### `File`类对象相关获取方法

在`File`类创建完对象后，如果想获取到该对象中的一些内容，可以使用下面`File`类的常用方法获取指定的内容：

1. `String getAbsolutePath()`：获取`File`类对象中文件路径的绝对路径（从根目录开始的路径）
2. `String getPath()`：获取`File`类对象中的值
3. `String getName()`：获取到`File`类对象中文件路径对应的文件/文件夹
4. `long length()`：获取到`File`对象中文件路径对应的文件大小，以字节为单位

基本使用如下：

```java
public class Test01 {
    public static void main(String[] args) {
        File file = new File("D:\\", "a.txt");
        // 1. String getAbsolutePath()
        System.out.println(file.getAbsoluteFile());
        // 2. String getPath()
        File file1 = new File("D:\\a.txt");
        System.out.println(file1.getPath());
        new File("./a.txt");
        System.out.println(file1.getPath());
        // 3. String getName()
        File file2 = new File("D:\\test");
        System.out.println(file2.getName());
        File file3 = new File("D:\\test\\a.txt");
        System.out.println(file3.getName());
        // 4. long length()
        File file4 = new File(".\\a.txt");
        System.out.println(file4.length());
    }
}
```

在上面的代码中，需要注意最后一个方法，因为当前`a.txt`文件中没有任何内容，所以输出`file4`对象对应文件的大小为0，此处一般获取到的`length`与文件属性中的文件大小保持一致

!!! note
    如果指定的文件不存在，则计算文件大小的方法也会返回0
    在IDEA中，使用`./`代表的当前路径为模块所在路径，即「项目文件夹」中

### `File`类创建文件的方法

当需要使用`File`类对象在对象路径位置创建文件/文件夹时，可以使用下面的两个方法：

1. `boolean createNewFile()`：在`File`对象路径下创建一个文件，如果文件已经存在，则创建失败，否则创建成功
2. `boolean mkdirs()`：在`File`对象路径下创建一个文件夹，如果文件夹已经存在，则创建失败，否则创建成功；本方法可以一次创建多级文件夹

!!! note
    上面两个方法在使用时必须要在路径中指定创建的文件/文件夹名
    需要注意，上面两个方法都会抛出异常

基本使用如下：

```java
public class Test02 {
    public static void main(String[] args) throws IOException {
        File file = new File(".\\b.txt");
        // 1. boolean createNewFile()
        System.out.println(file.createNewFile());
        // 2. boolean mkdirs()
        File file1 = new File(".\\test\\test1");
        System.out.println(file1.mkdirs());
    }
}
```

在上面的代码中，对于`createNewFile`来说，会在项目文件夹中创建一个名为`b.txt`的文件；对于`mkdirs`方法来说，会在项目文件夹中创建一个名为`test`的文件夹，并且因为`test`后面依旧还有文件夹，所以会在`test`文件夹中继续创建新的名为`test1`的文件夹

### `File`类删除文件方法

在Java中，如果想要删除文件/文件夹时，可以使用：`boolean delete()`，如果删除成功，返回`true`，否则返回`false`

!!! note
    需要注意，删除文件夹时必须确保文件夹为空，否则删除失败
    使用该方法删除的文件/文件夹不会存在于系统回收站中

基本使用如下：

```java
public class Test03 {
    public static void main(String[] args) {
        File file = new File("./b.txt");
        System.out.println(file.delete());
        File file1 = new File("./test/test1");
        System.out.println(file1.delete());
    }
}
```

### `File`类的判断方法

在Java中，判断文件类型或者文件是否存在可以使用下面的方法：

1. `boolean isDirectory()`：判断`File`对象中的路径的文件是否是文件夹，如果不是返回`false`，否则返回`true`
2. `boolean isFile()`：判断`File`对象中的路径的文件是否是文件，如果不是返回`false`，否则返回`true`
3. `boolean exists()`：判断`File`对象中的路径的文件是否存在，如果不存在返回`false`，否则返回`true`

基本使用如下：

```java
public class Test04 {
    public static void main(String[] args) {
        File file = new File("./b.txt");
        System.out.println(file.exists());
        System.out.println(file.isDirectory());
        System.out.println(file.isFile());
    }
}
```

### `File`类的遍历方法

当需要一次拿到多个文件的名称时，可以使用下面的方法：

1. `String[] list()`：遍历指定的文件夹，将读取到的文件名称存储到`String`数组中
2. `File[] listFiles()`：遍历指定的文件夹，将读取到的文件名称存储到`File`数组中

!!! note
    `list`方法遍历结果只会显示`File`类对象路径下文件的文件名，但是`listFiles`会显示`File`类对象路径+内部文件的文件名
    
    需要注意，两个方法在遍历到`File`类对象路径下的文件夹时不会进入对应的文件夹

基本使用如下：

```java
public class Test05 {
    public static void main(String[] args) {
        File file = new File("./test/test1");
        // 1. String[] list()
        String[] list = file.list();
        for (String s : list) {
            System.out.println(s);
        }

        // 2. File[] listFiles()
        File[] files = file.listFiles();
        for (File f : files) {
            System.out.println(f);
        }
    }
}
```

一般推荐使用`listFiles`方法，因为返回的是`File`类对象，之后的操作会更加方便

### `File`类练习

遍历当前项目文件夹下的`test`文件夹中所有`txt`文件，如果存在子文件夹，遍历子文件夹中所有`txt`文件，以此类推，直到不存在`txt`文件

思路：

1. 创建`File`类对象指定路径
2. 调用`listFiles`方法获取到当前路径下的所有文件
3. 判断是否是文件，其次判断其文件名称是否以`.txt`结尾，如果是，打印出文件名，如果不是，判断是否是文件夹，时文件夹继续遍历，重复第三步

!!! note
    对于第三步来说，可以考虑使用递归的方式，因为文件目录本质还是树结构

参考代码：

```java
public class Test06 {
    public static void main(String[] args) {
        File file = new File("./test/test1");
        File[] files = file.listFiles();
        isTxt(files);
    }

    private static void isTxt(File[] file) {
        for (File file1 : file) {
            if (file1.isFile()) {
                if (file1.getName().endsWith(".txt")) {
                    System.out.println(file1);
                }
            } else {
                isTxt(file1.listFiles());
            }
        }
    }
}
```

## IO流分类

在Java中，IO流有两种分类：

1. 字节流：可以理解为「万用流」，因为一切均文件
2. 字符流：针对于文本文件

字节流有两个对应的流：

1. 字节输出流：对应`OutputStream`抽象类
2. 字节输入流：对应`InputStream`抽象类

字符流有两个对应的流：

1. 字符输出流：对应`Writer`抽象类
2. 字符输入流：对应`Reader`抽象类

## 字节流

在Java中，字节流两个抽象流：

1. 字节输出流：对应`OutputStream`抽象类
2. 字节输入流：对应`InputStream`抽象类

### 字节输出流

`OutputStream`抽象类的子类是`FileOutputStream`

构造方法如下：

1. `FileOutputStream(File file) `：通过`File`类对象创建`FileOutputStream`对象
2. `FileOutputStream(String name)`：通过文件路径字符串创建`FileOutputStream`对象

!!! note
    需要注意，上面两个构造方法都会抛出异常

基本使用如下：

```java
public class Test {
    public static void main(String[] args) throws FileNotFoundException {
        File file = new File("./a.txt");
        // 1. FileOutputStream(File file) ：通过File类对象创建FileOutputStream对象
        FileOutputStream outputStream = new FileOutputStream(file);
        // 2. FileOutputStream(String name)：通过文件路径字符串创建FileOutputStream对象
        FileOutputStream outputStream1 = new FileOutputStream("./b.txt");
    }
}
```

字节输出流的特点：

1. 如果指定的文件不存在就会创建新文件，否则就在指定的文件中写
2. 默认覆盖写，如果原来文件中有内容，再次开流写就会覆盖原始的内容

字节输出流常用方法：

1. `void write(int b)`：每一次写一个字节的数据，参数为写入内容的码值
2. `void write(byte[] b)`：每一次写一个字节数组中的数据，参数为写入内容的码值数组
3. `void write(byte[] b, int off, int len)`：每一次写一个字节数组中的部分数据，第一个参数为写入内容的码值数组，第二个参数为第一个写入的内容对应的下标，第三个参数为指定数组的元素个数
4. `void close()`：关闭输出流

基本使用如下：

```java
public class Test01 {
    public static void main(String[] args) throws IOException {
        FileOutputStream outputStream = new FileOutputStream("./a.txt");
        outputStream.write(97);
        byte[] bytes = {98, 99, 100, 101, 102};
        outputStream.write(bytes);
        outputStream.write(bytes, 1, 3);
        outputStream.close();
    }
}
```

!!! note
    需要注意，如果使用了`close`方法关闭了当前输出流，就不可以再调用当前输出流对象，否则编译报错

如果需要追加写，则可以使用：`FileOutputStream(String name, boolean append)`创建字节输出流对象，其中第二个参数此时需要为`true`

如果写的内容需要换行，则可以在写的内容中添加换行符：

```java
public class Test03 {
    public static void main(String[] args) throws IOException {
        File file = new File("./a.txt");
        FileOutputStream outputStream = new FileOutputStream(file, true);
        outputStream.write("Hello\n".getBytes());
        outputStream.write("World\n".getBytes());
        outputStream.close();
    }
}
```

### 字节输入流

`InputStream`抽象类的子类是`FileInputStream`类

构造方法如下：

1. `FileInputStream(File file) `：通过`File`类对象创建`FileInputStream`对象
2. `FileINputStream(String name)`：通过文件路径字符串创建`FileINputStream`对象

!!! note
    需要注意，上面两个构造方法都会抛出异常

使用方法同字节输出流

字节输入流的特点：如果指定的文件不存在就会打开失败抛出异常，否则就在指定的文件中读取

字节输入流的常见方法：

1. `int read()`：从指定文件中一次读取一个字节的数据，返回读取到的字节
2. `int read(byte[] b)`：从指定文件中一次读取`n`个字节的数据，`n`由参数数组大小决定，返回读取到的字节个数
3. `int read(byte[] b, int off, int len)`：从指定文件中一次读取`n`个字节中的部分数据，`n`由数组大小决定，第一个参数代表存储读取内容的数组，第二个参数为第一个读取的内容，第三个参数为字节个数。方法返回读取到的字节个数
4. `void close()`：关闭字节输入流

!!! note
    需要注意：

    如果读取文件内容的过程中，一个流在读取的过程中会按照文件内容顺序读取，每一次读取的位置为上一次读取的结束位置，已经读到文件内容的结尾，此时三个`read`方法都会返回-1。
    
    如果使用了`close`方法关闭了当前输出流，就不可以再调用当前输出流对象，否则编译报错

- 一次读取一个字节

    ```java
    public class Test04 {
        public static void main(String[] args) throws IOException {
            File file = new File("./a.txt");
            FileInputStream fileInputStream = new FileInputStream(file);
            int read = fileInputStream.read();
            System.out.println((char)read);
            int read1 = fileInputStream.read();
            System.out.println((char)read1);
            int read2 = fileInputStream.read();
            System.out.println((char)read2);
            fileInputStream.close();
        }
    }
    ```

- 一次读取`n`个字节

    ```java
    public class Test04 {
        public static void main(String[] args) throws IOException {
            File file = new File("./a.txt");
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] bytes = new byte[2];
            while (fileInputStream.read(bytes) != -1) {
                System.out.println(new String(bytes));
            }
        }
    }
    ```

    上面的代码需要注意，如果文件中的内容只有5个字节，则在最后一次读取的过程中因为只读取到一个字节的数据，所以只会覆盖字节数组中第一个元素的位置，此时会出现打印结果与文件实际内容不一致的情况，可以考虑修改方法：因为`read`方法会返回读取到的字节个数，所以可以通过该字节个数控制`bytes`数组每次转换为字符串的个数

    ```java
    public class Test04 {
        public static void main(String[] args) throws IOException {
            File file = new File("./a.txt");
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] bytes = new byte[2];
            int len = 0;
            while ((len = fileInputStream.read(bytes)) != -1) {
                System.out.println(new String(bytes,0, len));
            }
            fileInputStream.close();
        }
    }
    ```

对于「一次读取`n`个字节中的部分数据」方法来说，在实际开发中并不常用，因为读取部分数据可能导致数据读取不全造成的问题，所以不做演示

### 字节流与文件的复制

文件的复制本质是将文件输入到内存中，再从内存输出到硬盘中，并且因为文件都是字节组成的，所以可以考虑字节流，步骤如下：

1. 通过字节输入流打开指定文件
2. 依次读取文件内容写到指定位置

!!! note
    整个过程中需要注意：

    输出位置必须指明文件保存的名字，否则会导致无法找到文件
    为了确保写入的都是有效数据，可以使用写入部分数据的`write`方法
    因为创建了字节输入流和字节输出流对象，所以需要关闭两个流，但是需要满足先开流后关

示例代码：

```java
public class Test05 {
    public static void main(String[] args) throws IOException {
        File file_in = new File("./1.mp3");
        FileInputStream fileInputStream = new FileInputStream(file_in);
        File file_out = new File("./1-copy.mp3");
        FileOutputStream outputStream = new FileOutputStream(file_out);
        byte[] bytes = new byte[1024];
        int len = 0;
        while ((len = fileInputStream.read(bytes)) != -1) {
            outputStream.write(bytes, 0, len);
        }

        outputStream.close();
        fileInputStream.close();
    }
}
```

## 字符流

### 字节流读取中文问题

使用字节流读取文本内容需要确保读取的字节个数是对应编码中的一个字符占用的字节个数

在UTF-8中，中文占3个字节，在GBK中，中文占2个字节，如果数组的长度为2，一次读取两个字节的数据，在GBK编码下就不会发生问题，但是如果是UTF-8就会出现读取的字节不全导致解码出现问题，从而乱码

下面的代码不论是GBK还是UTF-8都会出现读取中文乱码问题

```java
public class Test {
    public static void main(String[] args) throws IOException {
        File file = new File("./b.txt");
        FileInputStream fileInputStream = new FileInputStream(file);
        byte[] bytes = new byte[1];
        int len = 0;
        while ((len = fileInputStream.read(bytes)) != -1) {
            System.out.println(new String(bytes, 0, len));
        }
    }
}
```

### 字符流介绍

字符流有两个对应的流：

1. 字符输出流：对应`Writer`抽象类
2. 字符输入流：对应`Reader`抽象类

### 字符输出流

`Writer`抽象类的子类是`FileWriter`

构造方法如下：

1. `FileWriter(File file)`：使用`File`对象构造`FileWriter`对象
2. `FileWriter(String fileName)`：使用文件路径构造`FileWriter`对象
3. `FileWriter(String fileName, boolean append)`：通过文件路径和是否追加构造`FileWriter`对象

基本使用：

```java
public class Test01 {
    public static void main(String[] args) throws IOException {
        File file = new File("./a.txt");
        // 1. FileWriter(File file)：使用File对象构造FileWriter对象
        FileWriter fileWriter = new FileWriter(file);
        // 2. FileWriter(String fileName)：使用文件路径构造FileWriter对象
        FileWriter fileWriter1 = new FileWriter("./a.txt");
        // 3. FileWriter(String fileName, boolean append)：通过文件路径和是否追加构造FileWriter对象
        FileWriter fileWriter2 = new FileWriter("./a.txt", true);
        
    }
}
```

字符输出流的特点（与字节输出流一样）：

1. 如果指定的文件不存在就会创建新文件，否则就在指定的文件中写
2. 默认覆盖写，如果原来文件中有内容，再次开流写就会覆盖原始的内容

常用方法如下：

1. `void write(int c)`：向文本文件中写入一个字符
2. `void write(char[] cbuf)`：向文本文件写一串字符
3. `void write(char[] cbuf, int off, int len)`：向文本文件写一串字符的一部分，第一个参数代表待写入的字符数组，第二个参数为第一个写入的字符对应的下标，第三个参数为数组的元素个数
4. `void write(String str)`：向文本文件写一个字符串
5. `void flush()`：刷新输出流缓冲区
6. `void close()`：关闭字符输出流

!!! note
    需要注意第五个方法和第六个方法：使用`flush`方法和`close`都可以将字符输出缓冲区的内容输出到文本文件中，但是`flush`刷新后，当前输出流对象依旧可以使用，但是`close`执行后，对应的输出流对象不可以再使用

基本使用如下：

```java
public class Test02 {
    public static void main(String[] args) throws IOException {
        File file = new File("./b.txt");
        FileWriter fileWriter = new FileWriter(file);
        fileWriter.write(97);
        fileWriter.write("你好".toCharArray());
        fileWriter.write("Hello World");
        // fileWriter.flush();
        fileWriter.close();
    }
}
```

### 字符输入流

`Reader`抽象类的子类是`FileReader`类

构造方法：

1. `FileReader(File file)`：使用`File`对象构造`FileReader`对象
2. `FileReader(String path)`：使用文件路径构造`FileReader`对象

使用方式与字符输出流基本一致，不做演示

常用方法如下：

1. `int read()`：每次从文本文件中读取一个字符，返回读取字符对应的`int`值
2. `int read(char[] cbuf)`：每次从文本文件中读取一串字符存储到字符数组中，返回读取字符的个数
3. `int read(char[] cbuf, int off, int len)`：每次从文本文件中读取一串字符的一部分存储到字符数组中，返回读取字符的个数，第一个参数代表存储读取字符的数组，第二个参数为第一个写入的字符，第三个参数为字符个数
4. `void close()`：关闭字符输入流

使用方式与字节输出流类似，不再演示

## IO异常处理方式

前面在遇到异常时直接使用了`throws`向上抛出异常，但是这种处理方式只是为了代码简洁

在实际开发中，需要使用`try...catch...finally`语句块处理异常，例如下面的代码：

```java
public class Test {
    public static void main(String[] args) {
        File file = new File("./a.txt");
        // 确保在finally的作用域中可以调用close方法
        FileOutputStream outputStream = null;
        try {
            outputStream = new FileOutputStream(file);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                // 文件未打开时不需要关闭
                if (outputStream != null) {
                    outputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

上面是传统的处理`IOException`的方式，需要手动关闭流

在JDK7之后，可以使用`try(IO对象1;IO对象2;...)...catch`处理`IOException`，这种处理方式的特点是会自动关闭流

!!! note
    当存在多个IO对象时，在`try()`中使用`;`隔开

```java
public class Test {
    public static void main(String[] args) {
        File file = new File("./a.txt");
        try(FileOutputStream outputStream = new FileOutputStream(file)) {

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 字节缓冲流

### 基本使用

字节缓冲输入流对应`BufferedInputStream`类，字节输出缓冲流对应`BufferedOutputStream`类，各自常用的构造方法如下：

1. `BufferedOutputStream(OutputStream out)`：使用`OutputStream`对象进行构造
2. `BufferedInputStream(InputStream in)`：使用`InputStream`对象进行构造

!!! note
    `BufferedOutputStream`和`BufferedInputStream`都是`OutPutStream`和`InputStream`的实现类
    
    因为对应的字节流中的两个类`FileOutputStream`类和`FileInputStream`类也是`OutPutStream`和`InputStream`的实现类，所以此处可以使用多态的向上转型将`FileOutputStream`对象或者`FileInputStream`对象给`OutputStream`对象引用或者`InputStream`对象引用，从而构造`BufferedOutputStream`对象和`BufferedInputStream`对象

使用如下：

```java
public class Test {
    public static void main(String[] args) throws IOException {
        // 字节输出缓冲流
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("./a.txt"));
        // 字节输入缓冲流
        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("./a.txt"));
    }
}
```

使用方法和方式与字节流一致，基本使用如下：

```java
public class Test {
    public static void main(String[] args) throws IOException {
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("./a.txt"));
        bufferedOutputStream.write(98);
        bufferedOutputStream.flush();

        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("./a.txt"));
        int word = bufferedInputStream.read();
        System.out.println((char)word);

        bufferedInputStream.close();
        bufferedOutputStream.close();
    }
}
```

!!! note
    需要注意的是，在关流时，尽管创建缓冲流相关对象时使用到了基本流对象，但是关流只需要关闭缓冲流相关对象，因为缓冲流关闭流方法底层会先关闭基本流，再关闭缓冲流

### 使用缓冲流复制文件

```java
public class Test01 {
    public static void main(String[] args) throws IOException {
        // 创建字节输入缓冲流
        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("./1.mp3"));
        // 创建字节输出缓冲流
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("./1-copy.mp3"));

        // 读取数据
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = bufferedInputStream.read(bytes)) != -1) {
            bufferedOutputStream.write(bytes, 0, len);
        }

        // 关流
        bufferedOutputStream.close();
        bufferedInputStream.close();
    }
}
```

## 字符缓冲流

字符缓冲输入流对应`BufferedReader`类，字节输出缓冲流对应`BufferedWriter`类，各自常用的构造方法如下：

1. `BufferedWriter(Writer w)`：使用`OutputStream`对象进行构造
2. `BufferedReader(Reader r)`：使用`InputStream`对象进行构造

!!! note
    `BufferedWriter`和`BufferedReader`都是`Writer`和`Reader`的实现类
    
    因为对应的字节流中的两个类`FileWriter`类和`FileReader`类也是`Writer`和`Reader`的实现类，所以此处可以使用多态的向上转型将`FileWriter`对象或者`FileReader`对象给`Writer`对象引用或者`Reader`对象引用，从而构造`BufferedWriter`对象和`BufferedReader`对象

基本使用与字节缓冲流基本一致，不再演示

常用方法与基本流一致，下面只关注`BufferedWriter`和`BufferedReader`的特有方法

1. `BufferedWriter`中的特有方法：`void newLine()`，作用：换行效果
2. `BufferedReader`中的特有方法：`String readLine()`，作用：一次读取一行数据，如果读到内容结尾则返回`null`

基本使用如下：

```java
public class Test02 {
    public static void main(String[] args) throws IOException {
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("./b.txt"));
        bufferedWriter.write(99);
        bufferedWriter.newLine();
        bufferedWriter.write(100);
        bufferedWriter.flush();

        BufferedReader bufferedReader = new BufferedReader(new FileReader("./b.txt"));
        String s = bufferedReader.readLine();
        System.out.println(s);
        String s1 = bufferedReader.readLine();
        System.out.println(s1);
    }
}
```

## 缓冲流读取数据原理

缓冲流之所以比基本流读取快，本质原因就是缓冲流在内存中开辟的缓冲区。

在从硬盘读取数据过程中，先使用基本流读取数据，再将数据交给缓冲流读入到缓冲流对应的缓冲区，因为缓冲区大小为8192字节，所以每一次缓冲流从基本流读取数据到缓冲区直到读取到8192字节才会停止。

在从内存写数据到硬盘过程中，因为输入缓冲区当前已经读取到了8192个字节的数据，就需要一个载体将输入缓冲区中的数据输送到输出缓冲区，同样输出缓冲区也是8192个字节的大小，在没有调用`flush`方法（或`close`方法）情况下，除非输出缓冲区满了，内容会由输出缓冲流传输到基本流，再由基本流输出到硬盘中，否则内容会一直留在输出缓冲区

整个过程如下图：

<img src="16. Java的IO流.assets\image.png">

## 字符编码

计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。[按照某种规则，将字符存储到计算机中，称为编码] 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本f符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。

<img src="16. Java的IO流.assets\image1.png">

字符编码`Character Encoding` : 一套自然语言的字符与二进制数之间的对应规则。

## 字符集

字符集 `Charset`：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。

计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。

<img src="16. Java的IO流.assets\image2.png">

可见，当指定了编码，它所对应的字符集然就指定了，所以编码才是我们最终要关心的。

- ASCII字符集 ：
    - ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
    - 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。
- ISO-8859-1字符集：
    - 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。
    - ISO-8859-1使用单字节编码，兼容ASCII编码。
- GBxxx字符集：
    - GB就是国标的意思，是为了显示中文而设计的一套字符集。
    - GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的"全角"字符，而原来在127号以下的那些就叫"半角"字符了。
    - GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
    - GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。
- Unicode字符集：
    - Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。
    - 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
    - UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
        1. 128个US-ASCII字符，只需一个字节编码。
        2. 拉丁文等字符，需要二个字节编码。 
        3. 大部分常用字（含中文），使用三个字节编码。
        4. 其他极少使用的Unicode辅助字符，使用四字节编码。

## 转换流

转换流主要解决的问题是：读取文本文件和写入文本文件两个过程中的字符编码不同，因为尽管是字符流读取字符，也只能保证代码文件的编码和文本文件编码一致情况下的读取正常，为了更广泛性得保证读取文本文件编码正常，就可以使用转换流

转换流有两类：

1. 输入转换流：对应`InputStreamReader`类
2. 输出转换流：对应`OutputStreamWriter`类

对应的构造方法如下：

1. `InputStreamReader(InputStream in, String charsetName)`：通过`InputStream`对象构造，第二个参数代表读取内容时解码采用的字符集
2. `OutputStreamWriter(OutputStream out, String charsetName)`：通过`OutputStream`对象构造，第二个参数代表写入内容时采用的字符集

常用方法与字符流一致

基本使用如下：

```java
public class Test {
    public static void main(String[] args) throws IOException {
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream("./a.txt"), "utf-8");
        outputStreamWriter.write("你好");
        outputStreamWriter.flush();

        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream("./a.txt"), "utf-8");
        char[] chars = new char[2];
        int len = 0;
        while ((len = inputStreamReader.read(chars)) != -1) {
            System.out.println(new String(chars, 0, len));
        }

        inputStreamReader.close();
        outputStreamWriter.close();
    }
}
```

## 序列化流与反序列化流

在Java中，如果需要将对象的属性输出到文件中并且再读取到内存中就需要用到序列化流和反序列化流

序列化流对应的类为`ObjectOutputStream`，反序列化流对应的类为`ObjectInputStream`

!!! note
    需要注意，序列化流和反序列化流写入到文件中的数据并不是让人可以看懂的，所以出现奇怪的字符都是正常的

### 基本使用

序列化流主要作用是向硬盘写对象，构造方法：`ObjectOutputStream(OutputStream out)`，常用方法：`void writeObject(Object obj)`

反序列化流主要作用是从硬盘读对象，构造方法：`ObjectInputStream(InputStream in)`，常用方法：`Object readObject()`，返回读取到的对象

需要注意，要写入类对象属性，需要确保对象对应的类实现了Serializable接口，否则会抛出`NotSerializableException`异常

```java
// 自定义类
public class Person implements Serializable {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

// 测试
public class Test {
    public static void main(String[] args) throws Exception {
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("b.txt"));
        // 写入一个ArrayList<Person>
        ArrayList<Person> people = new ArrayList<>();
        people.add(new Person("张三", 23));
        people.add(new Person("李四", 24));
        people.add(new Person("王五", 25));

        // 写入people列表
        objectOutputStream.writeObject(people);
        objectOutputStream.flush();

        // 读取people列表
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("./b.txt"));
        Object o = objectInputStream.readObject();
        for (Person person : (ArrayList<Person>) o) {
            System.out.println(person);
        }
    }
}

输出结果：
Person{name='张三', age=23}
Person{name='李四', age=24}
Person{name='王五', age=25}
```

### 禁止成员被序列化

如果不想指定的成员被序列化，可以使用`transient`关键字修饰对应成员，例如`Person`类中的`age`成员修饰为`transient`

```java
// 自定义类
public class Person implements Serializable {
    private String name;
    private transient int age;
    // ...
}

// 测试
public class Test {
    public static void main(String[] args) throws Exception {
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("b.txt"));
        // 写入一个ArrayList<Person>
        ArrayList<Person> people = new ArrayList<>();
        people.add(new Person("张三", 23));
        people.add(new Person("李四", 24));
        people.add(new Person("王五", 25));

        // 写入people列表
        objectOutputStream.writeObject(people);
        objectOutputStream.flush();

        // 读取people列表
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("./b.txt"));
        Object o = objectInputStream.readObject();
        for (Person person : (ArrayList<Person>) o) {
            System.out.println(person);
        }
    }
}

输出结果：
Person{name='张三', age=0}
Person{name='李四', age=0}
Person{name='王五', age=0}
```

### 序列号不匹配异常

序列号不匹配异常一般出现于向硬盘写入对象属性值时创建的序列号与从硬盘读取对象数值时的序列号不同，而造成这种不同的原因一般是写入对象后修改了源码

如果不想出现上面的异常，可以在对象对应的类中创建成员：

```java
public static final long serialVersionUID = 指定具体值;
```

!!! note
    需要注意，这个成员代表序列号，必须是`long`类型，且被`final`和`static`修饰

## 打印流

### 基本使用

打印流表示向某一个文件输出内容

打印流对应类为`PrintStream`类，构造方法：`PrintStream(String fileName)`

常用方法有：

1. `println(...)`：向文件中输出参数内容，并且自带换行
2. `print(...)`：向文件中输出参数内容，不换行

基本使用如下：

```java
public class Test {
    public static void main(String[] args)throws Exception{
        PrintStream ps = new PrintStream("./a.txt");
        ps.println("1");
        ps.println("2");
        ps.close();
    }
}
```

### 系统打印流与改变流向

前面经常使用`System.out.println()`输出数据，实际上就是在使用打印流，只是这个`out`成员是`System`类中的静态`PrintStream`类成员，此时调用`println`方法，默认向控制台打印数据

在实际开放中，程序在运行过程中，控制台的内容会被每一次新打印语句覆盖，导致内容不具有持久性，所以需要改变内容流向，使其不打印在控制台，而打印到文件中

当需要改变流向，可以使用`System`类中的静态方法：`static void setOut(PrintStream out)`，该方法是静态方法，所以可以被直接调用

基本使用如下：

```java
public class Test01 {
    public static void main(String[] args) throws Exception{
        System.setOut(new PrintStream("./b.txt"));
        System.out.println("这是一个日志文件");
        System.out.println("现在是"+ new Date());
    }
}

文件内容：
这是一个日志文件
现在是Sun Sep 22 21:15:47 CST 2024
```

## `Properties`集合结合IO流

前面介绍`Properties`集合时介绍到一个方法：`void load(InputStream inStream)`，该方法和结合`InputStream`对象使用

因为`Properties`集合一般存储的是配置文件信息，所以可以考虑从文件中读取配置信息，原因是：将来不能将很多的硬数据放到源码中，比如用户名和密码这些数据，因为之后有可能换用户名或者密码，如果一换，我们就需要去源码中修改，而因为类和类之间都有联系，有可能牵一发动全身，所以需要将这些数据提取出来，放到文件中，改的时候直接去文件中改，源码不需要改动

配置文件`xxx.properties`创建方式：

1. 在需要创建配置文件的父文件夹右键 -> `File` -> 取名为`xxx.properties`
2. 在`xxx.properties`文件中写配置数据
    1. `key`和`value`都是`key=value`形式
    2. `key`和`value`都是`String`的,但是不要加双引号
    3. 每个键值对写完之后,需要换行再写下一对
    4. 键值对之间最好不要有空格(空格可以有,但是不建议写)
    5. 键值对中建议不要使用中文(中文可以有,但是直接读取会乱码,需要转换流转码)  

基本使用如下：

```java
public class Test {
    public static void main(String[] args)throws Exception {
        Properties properties = new Properties();
        FileInputStream fis = new FileInputStream("jdbc.properties");
        properties.load(fis);

        Set<String> set = properties.stringPropertyNames();
        for (String key : set) {
            System.out.println(key+"..."+properties.getProperty(key));
        }
    }
}
```

## `Commons-io`工具包

### 介绍与引入工具包

`Commons-io`解决的问题：IO技术开发中，代码量很大，而且代码的重复率较高。如果我们要遍历目录，拷贝目录就需要使用方法的递归调用，也增大了程序的复杂度。

Apache软件基金会，开发了IO技术的工具类`commons-IO`，大大简化IO开发。

`Commons-io`工具包是第三方包，所以使用前需要导入包，但是这个包是`jar`包，需要先解压，下面是IDEA下的引入和解压方式：

1. 在指定位置创建文件夹,取名为`lib`或者`libs`
2. 将准备好的`jar`包,放到此文件夹下
3. 对着`jar`包,右键 -> Add as library (如果想将`lib`下所有的`jar`包一起解压,我们就直接对着`lib`文件夹右键)
4. `level`可以选择`module`，此时上面`name`位置会变成空，可以不用考虑
5. 直接点OK

!!! abstract
    上面引包的方式后面会被Maven项目管理工具替代，具体见后面Maven工具使用介绍

### 使用工具包的静态方法

#### `IOUtils`工具类

`IOUtils`工具类是`Commons-io`工具包下的关于IO的一个类，里面提供了一些文件操作的方法：

1. `IOUtils.copy(InputStream in, OutputStream out)`：拷贝文件内容到另一个文件中
2. `IOUtils.closeQuietly(任意流对象)`：作用同`close`方法，但是不需要额外处理异常

基本使用如下：

```java
public class Test {
    public static void main(String[] args) /*throws Exception*/{
        //- 静态方法：IOUtils.copy(InputStream in,OutputStream out)
        IOUtils.copy(new FileInputStream("./1.jpg"),new FileOutputStream("./1-copy.jpg"));
        //- 静态方法：IOUtils.closeQuietly(任意流对象)
        FileWriter fw = null;
        try{
            fw = new FileWriter("module22\\commons.txt");
            fw.write("你好");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            if (fw!=null){
                IOUtils.closeQuietly(fw);
            }
        }
    }
}
```

#### `FileUtils`工具类

常用方法如下：

1. `FileUtils.copyDirectoryToDirectory(File src, File dest)`：将`src`下的文件夹拷贝到`dest`下的文件夹中，整个过程中不需要对`src`内部的文件夹进行显式递归遍历
2. `writeStringToFile(File file, String str)`：向文件中写入`str`字符串内容
3. `String readFileToString(File file)`：读取文件中所有的内容

基本使用如下：

```java
public class Test01 {
    public static void main(String[] args)throws Exception {
        // FileUtils.copyDirectoryToDirectory(File src, File dest)
        FileUtils.copyDirectoryToDirectory(new File("./test"), new File("./test1"));

        //- 静态方法：writeStringToFile(File file,String str)写字符串到文本文件中。
        FileUtils.writeStringToFile(new File("./a.txt"),"haha");
        //- 静态方法：String readFileToString(File file)读取文本文件，返回字符串。
        String s = FileUtils.readFileToString(new File("./a.txt"));
        System.out.println(s);
    }
}
```

## 整章结构

<img src="16. Java的IO流.assets\image3.png">