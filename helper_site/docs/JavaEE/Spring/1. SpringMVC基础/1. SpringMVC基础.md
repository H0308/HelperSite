# SpringMVC基础

## MVC架构模式介绍

MVC（Model View Controller）是软件工程中的一种**软件架构模式**，它把软件系统分为**模型（Model）**、**视图（View）**和**控制器（Controller）**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑

- **M**：`Model`模型层：存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO（valueObject）对象或者存放一些对数据进行逻辑运算操作的的一些业务处理代码
- **V**：`View`视图层：存放一些视图文件相关的代码，例如HTML、CSS、JS
- **C**：`Controller`控制层：接收客户端请求，获得请求数据，最后将准备好的数据响应给客户端

MVC模式工作流程如下图所示：

<img src="1. SpringMVC基础.assets/download.png" style="width: 70%;">

MVC模式下项目中的常见包：

- `Model`模型层：

    1. 实体类包（`pojo`/`entity`/`bean`）专门存放和数据库对应的实体类和一些VO对象
    2. 数据库访问包（`dao`/`mapper`）专门存放对数据库不同表格CURD方法封装的一些类
    3. 服务包（`service`）专门存放对数据进行业务逻辑运算的一些类

- `Controller`控制层：控制层包（`controller`）

- `View`视图层：Web目录下的视图资源，例如HTML、CSS、JS、图片

=== "非前后端分离的MVC示意图"

    <img src="1. SpringMVC基础.assets\image-20241208214219416.png" style="width: 70%;">

=== "前后端分离的MVC示意图"

    <img src="1. SpringMVC基础.assets\1683363039636-1690349401673.png" style="width: 70%;">

## SpringMVC介绍

SpringMVC，全称为Spring Web MVC，是基于Servlet API构建的原始Web框架，从一开始就包含在Spring框架中。它的正式名称Spring Web MVC来自其源模块的名称（`Spring-webmvc`），在大部分情况下都会称为SpringMVC

!!! info "关于Servlet"

    Servlet（server applet）是运行在服务端（例如Tomcat）的Java小程序，是SUN公司提供一套定义动态资源规范。从代码层面上来讲Servlet就是一个接口，其主要用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。因此可以把Servlet称为Web应用中的**控制器**

    不是所有的Java类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet，因为其要处理客户端请求，所以Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行

在Spring实现MVC时结合了自身项目的特点对MVC模式进行了一定的改变，如下图所示：

<img src="1. SpringMVC基础.assets/download1.png" style="width: 70%;">

可以从图中看到最大的改变就是浏览器直接请求`Controller`而不是通过视图发起请求

## SpringMVC与SpringBoot

SpringMVC是Spring框架的一个Web模块，专注于MVC模式下的Web开发，而SpringBoot是Spring的扩展框架，通过自动配置和starters简化了Spring应用的搭建和部署，而SpringBoot是实现SpringMVC的其中一种方式，通过添加各种依赖和SpringMVC框架来实现Web功能

接下来的介绍会基于SpringBoot项目，在SpringBoot项目中同时介绍SpringMVC的相关知识。而本文档介绍SpringMVC基础内容时从下面三个方面进行：

1. 建立连接
2. 请求处理
3. 响应处理

## 客户端与服务端建立连接

### `@RequestMapping`介绍

在SpringMVC中，要想做到浏览器可以请求到后端的动态资源可以使用`@RequestMapping`注解实现URL路由映射。对应的，在具体的类上添加`@RestController`

例如下面的代码：

```java
@RestController
public class HelloController {

    @RequestMapping("/sayHello")
    public String hello() {
        return "Hello World!";
    }
}
```

在`@RequestMapping`注解中，第一个值为路径参数，例如上面例子中的`"/sayHello"`，这个路径可以带`/`，也可以不带`/`，但是一般情况下推荐带上`/`表示路径。接着，在浏览器通过地址`http://localhost:8080/sayHello`中发起请求即可看到返回的字符串`Hello World!`

### `@RequestMapping`修饰位置

`@RequestMapping`既可以修饰类，也可以修饰方法：

1. `@RequestMapping`修饰类时，表示请求路径的初始信息
2. `@RequestMapping`修饰方法时，表示请求路径的具体信息

当修饰类和方法时，访问的地址就是类路径+方法路径，例如下面的代码：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @RequestMapping("/sayHello")
    public String hello() {
        return "Hello World!";
    }
}
```

此时的访问路径即为`http://localhost:8080/hello/sayHello`，一般情况下建议在类上添加`@RequestMapping`，这样可以避免方法路径的重复导致的服务器错误

### `@RequestMapping`多层路径

`@RequestMapping`除了设置一层路径以外，还可以设置多层路径，例如：

```java
@RequestMapping("/user/hello")
@RestController
public class HelloController {

    @RequestMapping("/v1/sayHello")
    public String hello() {
        return "Hello World!";
    }
}
```

此时的访问路径即为`http://localhost:8080/user/hello/v1/sayHello`

### `@RequestMapping`与`GetMapping`和`PostMapping`

默认情况下，`@RequestMapping`可以处理所有类型的HTTP请求，包括但不限于`GET`和`POST`，如果想要指定只处理`GET`请求和`POST`请求，可以设置`@RequestMapping`的第二个属性值

例如，对于`GET`请求：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @RequestMapping(value = "/sayHello", method = RequestMethod.GET)
    public String hello() {
        return "Hello World!";
    }
}
```

此时只有发送了`GET`请求才可以执行`hello()`方法

为了简化上面的写法，如果只想让方法处理`GET`请求可以使用`@GetMapping`，例如上面的代码可以修改为：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @GetMapping("/sayHello")
    public String hello() {
        return "Hello World!";
    }
}
```

同样，对于`POST`请求可以通过`@RequestMapping`的第二个属性值进行指定，例如下面的代码：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @RequestMapping(value = "/sayHello", method = RequestMethod.POST)
    public String hello() {
        return "Hello World!";
    }
}
```

同样，如果只想让方法处理`POST`请求可以使用`@PostMapping`，例如上面的代码可以修改为：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @PostMapping("/sayHello")
    public String hello() {

        return "Hello World!";
    }
}
```

对于其他的请求方式也是同样的逻辑，此处不再演示

!!! note

    需要注意的是，`@GetMapping`和`@PostMapping`不支持类上添加，只支持方法上添加，对于其他针对某一种请求方式的注解也是如此

## 请求处理

### 处理一个参数

当请求中只有一个参数，例如`?name=zhangsan`时，接收方式很简单，只需要在处理方法中定义一个形参名字与请求参数`key`的名字一样即可，例如下面的代码用于接收`name`参数：

```java
@RequestMapping("/hello")
@RestController
public class HelloController {

    @GetMapping("/sayHello")
    public String hello(String name) {

        return "接收到姓名为：" + name;
    }
}
```

此时发送请求为`http://localhost:8080/hello/sayHello?name=zhangsan`即可收到下面的信息：

```
接收到姓名为：zhangsan
```

对于`POST`请求来说，参数放在请求参数或者请求体都是可以正常接收的，接收代码与`GET`请求类似：

```java
@RequestMapping(value = "/hello")
@RestController
public class HelloController {

    @PostMapping("/sayHello")
    public String hello(String name) {

        return "接收到姓名为：" + name;
    }
}
```

但是需要注意的是，如果方法参数是基本数据类型（**不包括布尔类型，如果是布尔类型不传递参数时，默认值为`false`**）时，参数不可以不传递，否则就会报错，因为当不传递参数时，如果是引用数据类型，那么值为`null`可以正常赋值给引用数据类型，但是如果参数是基本数据类型无法将`null`转换为基本数据类型从而报错。所以在处理基本数据类型的参数时建议使用对应的包装类而非基本数据类型，例如下面的代码：

=== "使用整型包装类"

    ```java
    @RequestMapping(value = "/hello")
    @RestController
    public class HelloController {

        @PostMapping("/sayHello")
        public String hello(Integer age) {

            return "接收到年龄为：" + age;
        }
    }
    ```

=== "而不是整型`int`"

    ```java
    @RequestMapping(value = "/hello")
    @RestController
    public class HelloController {

        @PostMapping("/sayHello")
        public String hello(int age) {

            return "接收到年龄为：" + age;
        }
    }
    ```
