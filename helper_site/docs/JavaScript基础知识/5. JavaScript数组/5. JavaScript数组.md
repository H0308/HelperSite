# JavaScript数组

## 介绍

数组也是一种复合数据类型，在数组可以存储多个不同类型的数据。与C++或者JavaScript一样，JavaScript数组中的每个数据都有一个唯一的索引，所以可以通过索引进行数据的访问。在数组中，数组的数据也被称为元素，对应的索引最小值为0

在JavaScript中，有两种创建数组的方式：

1. 使用`Array()`构造函数创建一个空数组，这种方式无法在创建数组时为数组添加元素
2. 使用`[]`创建一个空数组，这种方式可以在初始化时为数组添加元素

例如下面的代码：

```JavaScript
let arr1 = new Array();

let arr2 = [];

// 初始化时添加元素
let arr3 = [1, 2, 3, 4];
```

与C++和Java一样，可以直接通过下标访问和修改元素，例如下面的代码：

```javascript
let arr3 = [1, 2, 3, 4];

console.log(arr3[1]); // 2
arr3[2] = 5;
console.log(arr3[2]); // 5
```

在JavaScript中，因为数组也是对象，所以数组也有自己的属性，这里先介绍数组常用的属性：长度。在JavaScript中，如果想获取数组的长度，只需要访问数组对象的`length`属性即可，例如下面的代码：

```javascript
let arr3 = [1,2,3,4];

console.log(arr3.length); // 4
```

JavaScript数组中的`length`并不是一个常量，其长度可以指定，如果指定的数值大于原先的数值，则相当于为数组扩容，多余的部分以`undefined`填充；如果指定的数值小于原先的数值，则相当于删除数组中的元素。例如下面的代码：

```JavaScript
let arr3 = [1, 2, 3, 4];

arr3.length = 10;
console.log(arr3[6]); // undefined

arr3.length = 1;
console.log(arr3); // [1]
```

!!! note
    需要注意，尽管`length`属性可以修改，但是其值不可以是负数，否则会报错`RangeError: Invalid array length`

## 遍历数组

和C++与Java一样，使用for循环枚举下标结合数组的长度即可，这种方法不再赘述。在JavaScript中，还有一种遍历数组的方式是通过`for-of`语句

在JavaScript中，`for-of`可以相当于C++和Java中的增强`for`，其语法如下：

```JavaScript
for(let value of array)
{
    
}
// 此时value就是array中的每一个元素
```

例如下面的代码：

```javascript
let arr3 = [1, 2, 3, 4];

for (const number of arr3) {
    console.log(number);
}

输出结果：
1
2
3
4
```

## 数组常用方法

### `isArray()`方法

Array类的静态方法，参数传递一个数组对象，用于检查某一个对象是否是数组。方法返回`true`或者`false`

```javascript
let arr = [];
let obj = {};
console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false
```

### `at()`方法

Array对象方法，参数传递索引。可以根据索引获取数组中的指定元素，与使用`[]`访问的方式不同，`at()`可以接收负索引作为参数，如果是负数索引，就相当于从后向前遍历。方法返回下标对应的值

```javascript
let arr = [1, 2, 3, 4];

console.log(arr.at(1)); // 2
console.log(arr.at(-2)); // 3
```

### `concat()`方法

Array对象方法，其参数传递一个或多个数组对象，用来连接调用方法的数组对象和参数中的数组对象。方法返回一个新数组

!!! note
    需要注意的是，这个方法会将连接后的数组返回，并不会修改原先任何一个对象数组

```javascript
let arr = [1, 2, 3, 4];
let arr1 = [5, 6, 7, 8];
let arr2 = [9, 10, 11, 12];

console.log(arr.concat(arr1, arr2));
// 不会改变原数组
console.log(arr);
console.log(arr1);
console.log(arr2);

输出结果：
[
   1,  2, 3, 4,  5,
   6,  7, 8, 9, 10,
  11, 12
]
[ 1, 2, 3, 4 ]
[ 5, 6, 7, 8 ]
[ 9, 10, 11, 12 ]
```

### `indexOf()`方法

Array对象方法，用于获取参数元素在数组中第一次出现的索引，该函数接受两个参数，第一个参数代表要查找的元素，第二个参数代表查找的起始位置。方法找到对应的数值，返回其下标，否则返回-1

!!! note
    第二个参数可以不传递，默认情况下从数组第一个元素的位置开始查找

```JavaScript
let arr = [1, 2, 3, 3, 3, 5, 3, 4];

console.log(arr.indexOf(3)); // 2
console.log(arr.indexOf(3, 5)); // 6
console.log(arr.indexOf(6)); // -1
```

### `lastIndexOf()`方法

本方法与`indexOf()`方法功能类似，只是其是从后向前查找，不再演示。方法接受两个参数，第一个参数表示查找元素，第二个表示起始位置，找到对应的数值，返回其下标，否则返回-1

### `join()`方法

Array对象方法，其作用是将数组中的元素根据连接符连接成一个字符串，方法接受一个参数，参数表示连接符，默认为逗号`,`

```javascript
let arr = [1, 2, 3, 3, 3, 5, 3, 4];

console.log(arr.join()); // 1,2,3,3,3,5,3,4
console.log(arr.join("-")); // 1-2-3-3-3-5-3-4
```

### `slice()`方法

Array对象方法，其有连两个参数，第一个参数表示截取的起始位置（包括该位置），第二个参数表示截取的结束位置（不包括该位置）。方法返回一个新数组

1. 如果指定了起始位置和终止位置，那么函数就会从起始位置一直截取到终止位置，不包括终止位置
2. 如果指定了起始位置，但是没有指定终止位置，则默认情况下截取到数组的最后一个元素，包括最后一个元素
3. 如果两个参数都不指定，则默认情况下对数组进行浅拷贝

!!! note
    需要注意，不论是截取还是浅拷贝，都不会改变原来的数组

```javascript
let arr = [1, 2, 3, 3, 3, 5, 3, 4];

// 指定起始位置和种植位置
console.log(arr.slice(1,4));
console.log(arr.slice(2));
let arr1 = arr.slice();
console.log(arr1);

输出结果：
[ 2, 3, 3 ]
[ 3, 3, 3, 5, 3, 4 ]
[
  1, 2, 3, 3,
  3, 5, 3, 4
]
```

### 浅拷贝与深拷贝

在JavaScript中，浅拷贝意味着对数组或者对象进行浅层次的拷贝。在数组中，如果其元素都是原始值，则浅拷贝与深拷贝没有差异，但是如果数组中是对象，则会出现问题

数组和对象的深浅拷贝概念是一致的，下面以数组的深浅拷贝进行叙述：

- 浅拷贝：如果数组中存储了对象，则浅拷贝情况下只会拷贝对象本身，但是不会单独拷贝对象中的属性。如果使用浅拷贝将数组中的对象拷贝给另外一个对象，则当另外一个对象修改其属性时，被拷贝的对象中的属性也会同时改变
- 深拷贝：与浅拷贝相反，如果数组中存储了对象，则深拷贝情况下不仅会拷贝对象本身，也会将对象中的属性一起拷贝。如果使用深拷贝将数组中的对象拷贝给另外一个对象，则当另外一个对象修改其属性时，被拷贝的对象中的属性不会受到影响

在JavaScript中，如果想对一个对象进行深拷贝，可以调用`structuredClone()`函数，其参数传递被拷贝的对象，该函数会返回一个新对象。如果想对一个对象进行浅拷贝，可以调用Object类的静态方法`assign()`，其参数传递被拷贝的对象，该函数会返回一个新对象

例如下面的代码：

```JavaScript
// 直接浅拷贝
const obj = {
    name: "Tom",
    age: 20,
    friend: {
        name: "Jerry",
        age: 18
    }
}

const obj1 = Object.assign({}, obj);
console.log(obj1);
console.log(obj1.friend === obj.friend); // true
// 修改影响原对象
obj1.friend.name = "Alice";
console.log(obj1.friend.name); // Alice
console.log(obj.friend.name); // Alice

// slice浅拷贝
const obj2 = {
    name: "Tom",
    age: 20,
    friend: {
        name: "Jerry",
        age: 18
    }
}

let arr = [obj2];
const arr1 = arr.slice();
console.log(arr1);
console.log(arr1[0] === arr[0]); // true

// 修改影响原对象
arr1[0].friend.name = "Alice";
console.log(arr1[0].friend.name); // Alice
console.log(arr[0].friend.name); // Alice

// 深拷贝
const obj3 = {
    name: "Tom",
    age: 20,
    friend: {
        name: "Jerry",
        age: 18
    }
}

let arr2 = [obj3];

const arr3 = structuredClone(arr2);
console.log(arr3);
console.log(arr2[0] === arr3[0]); // false
// 修改不影响原对象
arr3[0].friend.name = "Alice";
console.log(arr2[0].friend.name); // Jerry
console.log(arr3[0].friend.name); // Alice
```

需要注意，在上面的代码中，`obj`对象自身中的`name`属性和`age`属性都是原始值，所以深浅拷贝效果都是一样的，但是其中的friend属性属于引用类型，此时浅拷贝就会出现修改新对象影响原对象的问题

### 对象的复制

在JavaScript中，经常会涉及到对象与对象直接的赋值，下面是常见的两种复制方式：

1. 使用展开运算符`...`
2. 调用Object类中的静态方法`assign()`

对于第二种方法，在浅拷贝和深拷贝处已经介绍，此处不再赘述。下面讨论展开运算符`...`

