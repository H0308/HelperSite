# JavaScript内建对象

## 解构赋值

### 基本使用

在前面进行赋值操作时，每一次只能对一个变量进行赋值，如果有很多变量，则需要依次赋值，这个过程就会很繁琐。在JavaScript中，为了解决这个问题，提出了一种新的赋值方式：解构赋值

解构赋值的基本语法如下：

```javascript
[变量1, 变量2, 变量3, ...] = [值1, 值2, 值3, ...]
```

例如下面的代码：

```javascript
let [a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3
```

如果右侧为数组或者是对象也可以使用解构赋值：

```JavaScript
let arr = [1, 2, 3];
let [a, b, c] = [arr[0], arr[1], arr[2]];
console.log(a, b, c); // 1 2 3
```

但是如果右侧是数组或者对象，手动取出其中的值再进行赋值不够优雅，所以也可以直接将数组引用或者对象引用给左侧的变量，例如下面的代码：

```JavaScript
let arr = [1, 2, 3];
let [a, b, c] = arr;
console.log(a, b, c); // 1 2 3
```

当数组引用给左侧的变量集时，数组中的元素会依次赋值给左侧对应的变量，所以如果数组中的元素个数少于左侧的变量数，则多余的变量值为`undefined`，例如下面的代码

```javascript
let arr = [1, 2];
let [a, b, c] = arr;
console.log(a, b, c); // 1 2 undefined
```

有了解构赋值，如果函数返回一个数组，则接收函数的返回值也可以使用解构赋值同时用多个变量接收函数的返回值，函数的返回值会依次填充变量，例如下面的代码：

```javascript
function fn() {
    return [1,2,3];
}

let [a, b, c] = fn();
console.log(a, b, c); // 1 2 3
```

### 解构赋值用于变量交换

在使用解构赋值交换变量中的值前，先想想之前交换变量的写法：

```javascript
let a = 10;
let b = 20;

let temp = a;
a = b;
b = temp;

console.log(a, b); // 20 10
```

有了解构赋值后，就可以写成下面的代码：

```javascript
let a = 10;
let b = 20;

[a, b] = [b, a];

console.log(a, b); // 20 10
```

这个代码看似会产生变量的覆盖，但是实际上在赋值符号的右侧方括号中，变量b代表的实际上是20，变量a代表的实际上是10，在整个赋值过程中，右侧的值使用都是字面量，不会改变，所以上面的解构赋值相当于`[a, b] = [20, 10];`

### 对象的解构赋值

前面提到了原始值和数组的解构赋值，下面考虑如果将对象中的值通过解构赋值给指定的变量

首先需要明白的是，前面原始值和数组的解构赋值，左侧的变量名可以随意，但是在对象中，左侧的变量名必须和对象中对应的对象名相同

其次，前面原始值和数组的解构赋值使用的都是`[]`，但是对于对象的解构赋值来说，需要使用`{}`

例如下面的代码：

```javascript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

let point = new Point(1, 2);

let {x, y} = point;
console.log(x, y); // 1 2
// 变量名与属性名不一致，解构赋值失败
let {a, b} = point;
console.log(a, b)// undefined undefined
```

假设现在不希望直接使用类内的属性作为外部的变量名，则可以使用别名的方式，在对象的解构赋值中，在左侧的与类属性同名的变量后加上`:`+别名就可以为对应的属性取别名，后面再使用对应的变量时就可以直接使用别名，例如下面的代码：

```JavaScript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

let point = new Point(1, 2);

// 使用别名
let {x:a, y:b} = point;
console.log(a, b); // 1 2
```

与数组一样，如果类对象中没有指定的属性，则对应的变量就是`undefined`，这就是为什么上面如果不给外部属性变量取别名，就必须用与类对象中的属性名相同的变量名的原因

## 对象的序列化与JSON

在JavaScript中，有的时候希望将对象中的内容可以保存在本地或者让其他语言也可以识别通过JavaScript创建的对象，就需要用到对象的序列化

在JavaScript中，对象使用时都是存在于计算机的内存中的，序列化指将对象转换为一个可以存储的格式，而在JavaScript中，对象的序列化通常是将一个对象转换为字符串（JSON字符串）

对象的序列化一般除了上面的用途外还有一种用途：编写配置文件，例如常玩vscode的玩家应该经常看到`setting.json`文件

介绍完JavaScript中的对象的序列化后，下面讲解如何进行对象序列化：在JavaScript中，有一个工具类 JSON （JavaScript Object Notation） JS对象表示法，JavaScript的对象通过序列化后会转换为一个字符串，这个字符串我们称其为JSON字符串

在JSON工具类，有两个方法：

1. `JSON.stringify()`：其作用是将JavaScript对象转换成JSON字符串，其参数传递一个对象，返回值是一个字符串，这个字符串满足JSON的规范
2. `JSON.parse()`：其作用是将符号JSON字符串规范的字符串转换成JavaScript对象，其参数传递一个JSON字符串

例如下面的代码：

```javascript
class Person {
    constructor() {
        this.name = 'mark';
        this.age = 18;
    }
    sayHello() {
        console.log('hello');
    }
}

let person = new Person();

// 调用stringify方法，将对象转换为JSON字符串
const str = JSON.stringify(person);
// 调用parse方法，将JSON字符串转换为对象
const obj = JSON.parse(str);

console.log(str); // {"name":"mark","age":18}
console.log(obj); // { name: 'mark', age: 18 }
```

JSON字符串除了可以使用特定的工具类转换以外，还可以手动编写，但是要符合JSON字符串的规范，其规范如下：

1. JSON字符串有两种类型：
    JSON对象 `{}`
    JSON数组 `[]`
2. JSON字符串的属性名必须使用双引号引起来
3. JSON字符串的类型是对象或者数组时，其中可以使用的属性值（元素）
    - 数字（Number）
    - 字符串（String） 必须使用双引号
    - 布尔值（Boolean）
    - 空值（Null）
    - 对象（Object `{}`）
    - 数组（Array `[]`）
4. JSON的格式和JavaScript对象的格式基本上一致的，
    注意：JSON字符串如果属性是最后一个，则不要再加`,`

## 使用JSON进行对象的深拷贝

因为JSON字符串转JavaScript对象的过程是深拷贝，所以可以使用JSON进行对象的深拷贝，例如下面的代码：

```javascript
let obj = {
    name: "孙悟空",
    friend: {
        name: "猪八戒",
    },
};

// 对obj进行浅复制
const obj2 = Object.assign({}, obj);

console.log(obj2); // { name: '孙悟空', friend: { name: '猪八戒' } }
// 修改obj2.friend.name的值
obj2.friend.name = "沙和尚";
// 影响到了obj.friend.name的值
console.log(obj); // { name: '孙悟空', friend: { name: '沙和尚' } }
console.log(obj2); // { name: '孙悟空', friend: { name: '沙和尚' } }

obj = {
    name: "孙悟空",
    friend: {
        name: "猪八戒",
    },
}

// 对obj进行深复制
const obj3 = structuredClone(obj);
console.log(obj3); // { name: '孙悟空', friend: { name: '猪八戒' } }
// 修改obj3.friend.name的值
obj3.friend.name = "沙和尚";
// 不会影响到obj.friend.name的值
console.log(obj); // { name: '孙悟空', friend: { name: '猪八戒' } }
console.log(obj3); // { name: '孙悟空', friend: { name: '沙和尚' } }

obj = {
    name: "孙悟空",
    friend: {
        name: "猪八戒",
    },
};
// 利用JSON来完成深复制
const str = JSON.stringify(obj);
const obj4 = JSON.parse(str);
// 修改obj4.friend.name的值
obj4.friend.name = "沙和尚";
// 不会影响到obj.friend.name的值
console.log(obj); // { name: '孙悟空', friend: { name: '猪八戒' } }
console.log(obj4); // { name: '孙悟空', friend: { name: '沙和尚' } }
```

## Map容器

### 基本介绍和使用

与其他变成语言一样，Map用来存储键值对结构的数据（key-value）， 而Object中存储的数据就可以认为是一种键值对结构，但是二者也存在一定的区别：

- Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名，JavaScript解释器会自动将其转换为字符串
- Map中任何类型的值都可以称为数据的`key`

例如下面的Object对象：

```javascript
const obj2 = {};

const obj = {
    "name":"mark",
    'age':18,
    [Symbol()]:"this is Symbol",
    [obj2]:"this is object"
}

console.log(obj[obj2]); // this is object
console.log(obj[{}]); // this is object
```

上面代码中，需要注意的是最后一个`[obj2]`，取`obj`中`obj2`的属性值时，使用`obj[obj2]`没问题，但是同样可以使用`obj[{}]`取`obj2`的属性值，因为`obj2`本质还是一个空对象，有的时候并不想出现这种情况，此时就可以考虑使用Map

Map中常用的方法如下：

1. 构造方法`Map()`，直接`new`则代表创建一个空Map
2. `size`：Map对象属性，获取Map中键值对的数量
3. `set(key, value)` ：Map对象方法，向Map中添加键值对
4. `get(key)`：Map对象方法，根据`key`获取值，返回`key`对应的`value`
5. `delete(key)`：Map对象方法，删除`key`对应的数据，返回`true`或者`false`
6. `has(key)`：Map对象方法，检查Map中是否包含指定键，返回`true`或者`false`
7. `clear()`：Map对象方法，删除全部的键值对

例如下面的代码：

```javascript
let map = new Map();

map.set("name", "mark");
map.set("age", 18);

console.log(map.size); // 2
console.log(map.get("name")); // mark
console.log(map.has("age")); // true
console.log(map.delete("age")); // true
```

现在使用Map解决前面的问题：

```javascript
const obj2 = {}

let map = new Map();
map.set(obj2, "this is object");

console.log(map.get(obj2)); // this is object
console.log(map.get({})); // undefined
```

### Map对象的遍历

前面提到`for-of`可以遍历数组，同样，可以使用`for-of`遍历Map对象，因为本质`for-of`中的`of`后面跟的就是可迭代对象

需要注意，不同于数组，数组使用`for-of`时，`for`后面的变量代表是数组中的元素，而Map使用`for-of`时，`for`后面的变量代表的是Map中的键值对

例如下面的代码：

```javascript
let map = new Map();

map.set("mark", 18);
map.set("tom", 20);
map.set("jerry", 22);

// 遍历map
for(let keyValue of map) {
    console.log(keyValue);
}
// 相当于遍历map.entries()
// for(let ketValue of map.entries()) {
//     console.log(ketValue);
// }

输出结果：
[ 'mark', 18 ]
[ 'tom', 20 ]
[ 'jerry', 22 ]
```

如果想获取到Map对象中的`key`或者`value`时，则可以使用for-of遍历`keys()`方法的结果或者`values()`方法的结果，例如下面的结果：

```javascript
let map = new Map();

map.set("mark", 18);
map.set("tom", 20);
map.set("jerry", 22);

// 遍历key
for(let key of map.keys()) {
    console.log(key);
}
// 遍历value
for(let value of map.values()) {
    console.log(value);
}

输出结果：
mark
tom
jerry
18
20
22
```

## Set容器

