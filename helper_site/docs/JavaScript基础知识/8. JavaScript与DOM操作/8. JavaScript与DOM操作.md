# JavaScript与DOM操作

## `document`对象

在介绍部分提到过：BOM最强大的功能是它提供了一个访问HTML页面的一入口——`document`对象，下面就来讨论关于`document`对象的内容

`document`对象表示的是整个网页，在JavaScript中，`document`对象的原型链如下：

`HTMLDocument` -> `Document` -> `Node` -> `EventTarget` -> `Object.prototype` -> `null`

前面在继承部分提到，JavaScript实现继承的方式就是通过原型链，所以现在根据这个原型链就可以知道：凡是在原型链上存在的对象的属性和方法都可以通过`document`去调用

下面是`document`对象的常见属性：

1. `documentElement`：表示`html`根元素
2. `head`：表示`head`元素
3. `title`：表示`title`元素
4. `body`：表示`body`元素
5. `links`：获取页面中所有的超链接，即所有的`a`元素

## 元素节点

元素节点对象：在网页中，每一个HTML标签都是一个元素节点，而为了通过JavaScript操作这些元素节点，在DOM操作中，有下面的两个方式操作元素节点

1. 通过`document`对象来获取元素节点
2. 通过`document`对象来创建元素节点

对于获取元素节点来说，有下面的几种`document`对象方法：

1. `getElementById()`：通过HTML元素中的`id`属性获取到指定元素节点，参数传递一个字符串，字符串中的内容即为元素的`id`名称，该方法返回一个获取到的节点对象。注意：传递`id`时不要携带`#`
2. `getElementsByClassName()`：通过HTML元素中的`class`属性获取到指定的元素节点，参数传递一个字符串，字符串中的内容即为元素的`class`名称，该方法返回一个实时更新的类数组对象，所谓的实时更新表示当网页中新添加元素时，集合也会实时的刷新。注意：传递`class`时不要携带`.`
3. `getElementsByTagName()`：通过HTML元素的名称获取到指定的元素节点，该方法返回一个实时更新的类数组对象，如果想获取到页面中所有的元素节点，可以在参数中传递`*`。
4. `getElementsByName()`：通过HTML元素的`name`属性的键值对获取到指定的元素节点，该方法返回一个实时更新的类数组对象，因为`name`属性并不是所有的HTML元素都有，所以一般本方法用于表单
5. `querySelectorAll()`：根据指定的选择器去页面中查询所有符合选择器的元素，参数传递一个选择器字符串，因为代表选择器，所以该有的符号修饰不可以省略，例如`id`选择器对应的字符串为`#id`，该方法返回一个数组，但是这个数组并不会实时更新
6. `querySelector()`：根据指定的选择器去页面中查询第一个符合选择器的元素，该方法返回一个元素节点对象，同样不可以省略选择器修饰符

因为DOM操作涉及到页面，所以给出HTML和JavaScript的代码例如下面的代码：

=== "HTML"

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <div id="box"></div>
        <div class="box1"></div>
        <div class="box2"></div>
    
        <form>
            <input type="text" name="username" id="username">
            <input type="password" name="password" id="password">
            <input type="submit" value="提交">
        </form>
    </body>
    <script src="test.js"></script>
    </html>
    ```

=== "JavaScript"

    ```javascript
    // getElementById()方法
    let elementById = document.getElementById("box");
    console.log(elementById); // <div id="box"></div>
    
    // getElementsByClassName()方法
    let elementsByClassName = document.getElementsByClassName("box1");
    console.log(elementsByClassName); // HTMLCollection [div.box1]
    
    // getElementsByTagName()方法
    let elementsByTagName = document.getElementsByTagName("div");
    console.log(elementsByTagName);
    
    // getElementsByName()方法
    let elementsByName = document.getElementsByName("username");
    console.log(elementsByName); // NodeList [input#username]
    
    // querySelectorAll()方法
    let nodeListOf = document.querySelectorAll("div");
    for (const nodeListOfElement of nodeListOf) {
        console.log(nodeListOfElement);
        /*
        * <div id="box"></div>
        * <div class="box1"></div>
        * <div class="box2"></div>
        * */
    }
    
    // querySelector()方法
    let querySelector = document.querySelector("div");
    console.log(querySelector); // <div id="box"></div>
    ```

对于创建元素节点来说，可以使用`document`对象方法：`createElement()`，但是这个方法只会创建一个元素节点，并不会将节点添加到页面中，后面会具体介绍[在页面中添加元素节点]()

前面通过`document`对象中的方法可以获得一个元素节点对象，有时需要根据这一个元素节点对象访问到其他元素节点对象，根据DOM中的关系可以使用下面的属性获取其他元素节点：

1. `childNodes`：元素节点对象方法，返回指定节点的孩子节点（会包含空白的子节点）
2. `children`：元素节点对象方法，返回指定节点的孩子节点（只会包含HTML元素节点）
3. `firstElementChild`：元素节点对象方法，获取当前元素的第一个子元素
4. `lastElementChild`：元素节点对象方法，获取当前元素的最后一个子元素
5. `nextElementSibling`：元素节点对象方法，获取当前元素的下一个兄弟元素
6. `previousElementSibling`：元素节点对象方法，获取当前元素的前一个兄弟元素
7. `parentNode`：元素节点对象方法，获取当前元素的父亲节点
8. `tagName`：元素节点对象方法，获取当前元素的标签名

例如下面的代码：

=== "HTML"

    ```HTML
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <div class="box1">
            <p></p>
            <div class="box2">
                <ul>
                    <li>1</li>
                    <li>2</li>
                    <li>3</li>
                    <li>4</li>
                </ul>
                <span></span>
            </div>
        </div>
    </body>
    <script src="test.js"></script>
    </html>
    ```

=== "JavaScript"

    ```javascript
    let elementsByClassName = document.getElementsByClassName("box1");
    // 获取到第一个元素
    let current = elementsByClassName[0];

    // 获取元素的父节点
    let parentNode = current.parentNode;
    console.log(parentNode);

    // 获取元素的子节点
    let childNodes = current.childNodes;
    console.log(childNodes);
    let children = current.children;
    console.log(children);

    // 获取第二个孩子
    current = document.getElementsByClassName("box2")[0].children[0];
    // 获取当前元素的标签名
    console.log(current.tagName);

    // 获取元素的第一个子元素
    let firstElementChild = current.firstElementChild;
    console.log(firstElementChild);
    // 获取元素的最后一个子元素
    let lastElementChild = current.lastElementChild;
    console.log(lastElementChild);

    // 获取元素的下一个兄弟元素
    let nextElementSibling = current.nextElementSibling;
    console.log(nextElementSibling);
    // 获取元素的前一个兄弟元素
    let previousSibling = current.previousSibling;
    console.log(previousSibling);
    ```

输出结果如下：

<img src="8. JavaScript与DOM操作.assets/image-20241113164334356.png"/>

## 文本节点

在DOM中，网页中所有的文本内容都是文本节点对象，可以通过元素来获取其中的文本节点对象，但是通常不会这么做。在JavaScript中，可以直接通过元素去修改其中的文本，一般有三个属性用于修改文本：

1. `textContent`：获取或修改元素中的文本内容，但是这个属性获取的是标签中的文本内容，不会考虑CSS样式
2. `innerText`：获取或修改元素中的文本内容，不同于上一个属性，该属性会获取到CSS样式，另外，当使用本属性读取文本内容时，如果内容中有标签，会自动对标签通过实体进行转义。在修改文本内容方面，本属性和上一个属性没有区别
3. `innerHTML`：获取或修改元素中的HTML代码，可以直接向元素中添加HTML代码。但是，使用本属性插入内容时，有被xss注入的风险

!!! note
    因为`innerText`属性会读取到CSS样式，所以每一次通过`innerText`属性获取内容时都会触发网页的重排，即重新计算CSS样式

!!! info "xss注入简介"

    当通过`innerHTML`获取用户的输入时，如果用户输入的内容时JavaScript代码，则此时可能会对网页产生影响，这个过程就被称为xss注入

例如下面的代码：

=== "HTML"

    ```HTML
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <div id="box" style="color: red"><span></span>
            这是一个盒子
        </div>
    </body>
    <script src="test.js"></script>
    </html>
    ```

=== "JavaScript"

    ```javascript
    let elementById = document.getElementById("box");
    // 读取
    console.log(elementById.innerText);
    console.log(elementById.textContent);
    console.log(elementById.innerHTML);
    // 修改
    elementById.innerText="Hello";
    elementById.innerHTML="<h1>Hello World</h1>"
    ```

## 属性节点

属性节点在DOM也是一个对象，通常不需要获取对象而是直接通过元素即可完成对其的各种操作，在JavaScript中有两种方式获取和修改属性节点：

1. `元素.属性名`（需要注意`class`属性需要使用`className`来读取和修改）：需要注意，如果读取到的属性是一个类似于`disabled`属性值为布尔值时，该属性会返回`true`或者`false`，修改时，只需要传递`true`（或者强制转换后的结果为`true`）或者`false`（或者强制转换的结果为`false`）即可
2. 元素方法（参数传递的都是字符串）：
   1. 读取：`getAttribute(属性名)`
   2. 修改：`setAttribute(属性名, 属性值)`
   3. 删除：`removeAttribute(属性名)`

!!! note
    使用`setAttribute(属性名, 属性值)`设置属性值是布尔值的属性时，第二个参数一般传递的是与属性名相同的字符串，因为这个方法不论是传递`true`还是`false`，最后都会使该属性值为`true`，如果想通过方法的方式取消属性值是布尔值的属性，则需要使用删除方法

例如下面的代码：

=== "HTML"

    ```HTML
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <form>
            输入文字：<input class="input1" type="radio">
            <input type="checkbox" value="sing" name="sng">唱歌
            <input class="input3" type="checkbox" value="dance" name="dnc">跳舞
        </form>

    </body>
    <script src="test.js"></script>
    </html>
    ```

=== "JavaScript"

    ```JavaScript
    // 修改radio属性为text
    let input1 = document.getElementsByClassName("input1")[0];
    input1.type="text";
    input1.placeholder="please input";

    // 修改第一个多选框为禁用
    // 获取属性name为sng的元素节点
    let input2 = document.querySelector("[name='sng']");
    console.log(input2.disabled);
    input2.disabled = 1;
    // 修改第二个多选框为禁用
    let input3 = document.getElementsByClassName("input3")[0];
    console.log(input3.getAttribute("disabled"));
    input3.setAttribute("disabled", "disabled");
    console.log(input3.getAttribute("disabled"));
    // 删除第二个多选框的禁用属性
    input3.removeAttribute("disabled");
    console.log(input3.getAttribute("disabled"));
    ```

## 事件基础

事件就是用户和页面之间发生的交互行为，例如：点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键……

在JavaScript中，可以通过为事件绑定响应函数（回调函数），来完成和用户之间的交互，有常见的三种绑定响应函数的方式：

1. 可以直接在元素的属性中设置，例如设置元素的`onclick`属性，表示鼠标点击事件

   ```HTML
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <button onclick="console.log('hello');">按钮</button>
    </body>
    <script src="test.js"></script>
    </html>
    ```

2. 可以通过为元素的指定属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数），例如`onclick`属性表示鼠标单击事件

    === "HTML"

        ```HTML
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
            <button id="btn">按钮</button>
        </body>
        <script src="test.js"></script>
        </html>
        ```

    === "JavaScript"

        ```JavaScript
        let element = document.querySelector("#btn");
        element.onclick = function () {
            console.log("Hello World");
        };
        ```

3. 可以通过元素`addEventListener()`方法来绑定事件，该方法第一个参数传递一个字符串，表示事件名称，一般是元素的事件属性去掉`on`后的事件，例如`onclick`变为`click`，第二个参数传递一个回调函数，回调函数中的代码即为事件触发时执行的内容

    === "HTML"

        ```HTML
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
            <button id="btn">按钮</button>
        </body>
        <script src="test.js"></script>
        </html>
        ```

    === "JavaScript"

        ```JavaScript
        let element = document.querySelector("#btn");
        element.addEventListener("click", () => {
            console.log("Hello World");
        });
        ```

## 文档的加载过程

在上面的HTML代码中，为了保证JavaScript代码可以正常获取到HTML中的元素节点，需要将JavaScript标签放置到`body`标签的下方，`html`标签的上方

之所以需要这样做是因为网页在加载时是自上而下加载的，如果将JavaScript代码写在`head`标签内，则加载`body`中的元素之前就会执行JavaScript代码，但是因为此时`body`中的元素还没创建，所以此时JavaScript的代码可能会出现问题，而如果将JavaScript代码放在后面就可以防止这个问题的出现

理论上只要将JavaScript代码放到`body`标签内的最后位置就可以，没有必要放置到与`body`标签下方作为`body`的兄弟标签。但是根据网页标准，应该将JavaScript的代码标签放置到`body`标签下方作为`body`的兄弟标签

如果还是想将JavaScript代码放置到head标签内部，则需要保证JavaScript代码在网页元素全部加载完毕后再加载，而控制这一行为的方式有下面几种：

1. 将代码编写到`window.onload`的回调函数中
2. 将代码编写到`document`对象的`DOMContentLoaded`的回调函数中（执行时机早于`window.onload`的回调函数）
3. 将代码编写到外部的`.js`文件中，然后以`defer`的形式进行引入（执行时机更早，早于`DOMContentLoaded`）（最常用）

例如下面的代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        // 第一种方式
        window.onload = function () {
            const btn = document.getElementById("btn")
            console.log(btn)
        }

        // 等价于第一种方式
        window.addEventListener("load", function () {
            const btn = document.getElementById("btn")
            alert(btn)
        })

        // 第二种方式
        document.addEventListener("DOMContentLoaded", function () {
            const btn = document.getElementById("btn")
            alert(btn)
        })
    </script>

    <!-- 第三种方式 -->
    <!-- <script defer src="test.js"></script> -->
    
</head>
<body>
    <button id="btn">按钮</button>
</body>
</html>
```

综上所述，在实际开发中，更推荐将使用外部引入的方式，而在外部引入时，可以考虑两种方式：

1. 使用外部引入的标签`script.src`，并将标签放置到`body`标签的下方
2. 使用外部引入的标签`script.src`并加上`defer`属性，将标签放置到`head`标签内部

