# Servlet开发

## 动态资源和静态资源介绍

静态资源：无需在程序运行时通过代码运行生成的资源，在程序运行之前就写好的资源。例如：HTML、CSS、JS、图片、音频文件和视频文件

动态资源：需要在程序运行时通过代码运行生成的资源，在程序运行之前无法确定的数据，运行时动态生成。例如Servlet、Thymeleaf……

!!! note

    动态资源指的不是视图上的动画效果或者是简单的人机交互效果

## Servlet简介和工作流程介绍

Servlet（server applet）是运行在服务端（例如Tomcat）的Java小程序，是SUN公司提供一套定义动态资源规范。从代码层面上来讲Servlet就是一个接口，其主要用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。因此可以把Servlet称为Web应用中的**控制器**

不是所有的Java类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet，因为其要处理客户端请求，所以Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行

Servlet工作流程可以大致如下图所示：

<img src="2. Servlet开发.assets/image-20241204145352774.png" alt="image-20241204145352774" />

基本过程如下：

1. 客户端向服务器端发出请求，服务器端的软件Tomcat接收到用户请求后会将请求报文的信息转换为`HttpServletRequest`对象，该对象中包含着请求中的所有信息，例如请求头、请求行。需要注意，这一过程中的`HttpServletRequest`对象并不是由程序员手动创建的，而是由Tomcat自动创建，并且此时除了存在`HttpServletRequest`对象以外，还有一个`HttpServletResponse`对象，该对象用于存储响应报文信息
2. 在整个过程中，Tomcat根据请求中的URL路径找到指定的Servlet类，此时将类`UserServlet`实例化，调用其`service`方法，同时传递实参给`HttpServletRequest req`和`HttpServletResponse resp`，此时在`service`方法中需要处理请求的信息，再将处理结果存储到响应对象`resp`中返回给客户端即可

## Servlet初使用

有了前面对Servlet工作流程的简单了解，接下来就可以根据上面的流程分析出以下的步骤：

1. 创建一个类并且实现`Servlet`接口
2. 重写其中的`service`方法
3. 获取客户端的请求信息
4. 处理客户端的请求信息（处理业务）
5. 将处理结果放入响应对象中

!!! note

    需要注意，整个过程中的两个对象`HttpServletRequest`和`HttpServletResponse`都是引入传递，所以`service`方法不需要返回值

根据上面的代码就可以写出下面的`UserServlet`类：

```java
public class UserServlet implements Servlet {
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {}

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {}

    @Override
    public String getServletInfo() {
        return "";
    }

    @Override
    public void destroy() {}
}
```

但是实际上只需要使用到`service`方法，而不需要重写其他方法，但是因为`Servlet`本身是一个接口，其中的所有方法都是抽象方法，所以直接实现该接口的子类`UserServlet`就必须重写所有方法：

```java
public interface Servlet {
    void init(ServletConfig var1) throws ServletException;

    ServletConfig getServletConfig();

    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    String getServletInfo();

    void destroy();
}
```

为了避免这种问题，可以考虑使用继承，但并不是继承`Servlet`接口，而是继承其子类`HttpServlet`，其子类`HttpServlet`继承自`GenericServlet`，`GenericServlet`继承自`Servlet`，而因为`HttpServlet`实现了`Servlet`中的所有接口，所以此时`UserServlet`继承该子类就可以按需重写对应的方法，此时上面的`UserServlet`就可以修改为如下代码：

```java
public class UserServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
    }
}
```

现在有一个需求：判断用户输入的用户名是否是`admin`，如果是`admin`，就提示`Wrong Username`，否则提示`Correct Username`

根据需求，首先需要一个页面获取用户的输入信息：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>校验</title>
</head>
<body>
<!--  action填写映射地址  -->
<!-- get请求时，键值对放置在url后面，即url?username=值 -->
<!-- post请求时，键值对放置在请求体中 -->
<form action="" method="get">
    用户：<input type="text" name="username" placeholder="请输入用户名"><br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```

在上面的页面中，创建了一个`form`表单，但是其`action`属性暂时留空，因为需要先处理好请求映射路径，再将该路径作为`action`的值，`method`可以为`get`也可以为`post`

接着编写Java代码，实现一个`UserServlet`类，该类继承自`HttpServlet`并重写`service`方法，根据前面的分析，在这个方法中需要进行三步：

1. 根据`name`的值`username`获取到用户输入框中的内容
2. 判断输入框内容是否是`admin`，如果是，则向客户端响应`Wrong Username`，否则响应`Correct Usernamme`
3. 将结果写入响应对象中

根据上面的三步，细化到代码中的步骤如下：

1. 调用请求对象`req`的方法`getParameter("username")`获取到输入框中的值。之所以可以这样获取，本质是因为不论是`get`请求还是`post`请求，输入框传递的参数都是键值对的形式，获取时只要有了键，就可以根据这个键获取其对应的值
2. 判断`getParameter`方法的返回值是否与`admin`相等，如果相等，说明用户输入的内容是`admin`，此时结果为`Wrong Username`，否则结果为`Correct Username`，因为需要将结果存储到响应对象，所以此处还需要一个变量存储最终结果
3. 调用响应对象的`getWriter()`方法创建一个向响应体中打印字符的响应流，将结果变量的值写入到响应流中

示例代码如下：

```java
public class UserServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取req中的内容
        String username = req.getParameter("username");
        String ret = "<h1>Correct Username</h1>";
        // 业务处理
        if(username.equals("admin")){
            ret = "<h1>Wrong Username</h1>";
        }

        // 将内容转换为写入响应报文中
        PrintWriter writer = resp.getWriter();
        writer.write(ret);
    }
}
```

有了页面和处理请求的`UserServlet`，接下来就是让页面向该`UserServlet`发送请求，此时就需要编写`Servlet`请求映射路径，这个请求路径在`WEB-INF`文件夹中的`web.xml`文件中编写，编写步骤如下：

1. 创建`<servlet></servlet>`标签，其中有两个子标签：
      1. `<servlet-name></servlet-name>`：表示目标Servlet类的别名
      2. `<servlet-class></servlet-class>`：表示目标Servlet类的全路径名
2. 在`<servlet></servlet>`标签下创建一个兄弟标签`<servlet-mapping></servlet-mapping>`，其中有两个子标签：
      1. `<servlet-name></servlet-name>`：表示需要指向的目标Servlet类的别名，与`<servlet></servlet>`中的`<servlet-name></servlet-name>`内容相同
      2. `<url-pattern></url-pattern>`：表示目标Servlet类的映射路径

例如下面的代码：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
         version="6.0">
    <!--  配置UserServlet映射  -->
    <servlet>
        <!--    UserServlet别名    -->
        <servlet-name>userServlet</servlet-name>
        <!--   UserServlet类全路径名     -->
        <servlet-class>UserServlet</servlet-class>
    </servlet>

    <!-- userServlet映射   -->
    <servlet-mapping>
        <!--   指定是哪一个userServlet需要映射地址     -->
        <servlet-name>userServlet</servlet-name>
        <!--   配置访问地址     -->
        <url-pattern>/userServlet</url-pattern>
    </servlet-mapping>
</web-app>
```

有了请求映射地址，现在就可以完善HTML中的`form`标签中的`action`属性值，注意`action`属性值不要带请求映射地址的`/`：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>校验</title>
</head>
<body>
<!--  action填写映射地址  -->
<!-- get请求时，键值对放置在url后面，即url?username=值 -->
<!-- post请求时，键值对放置在请求体中 -->
<form action="userServlet" method="get">
    用户：<input type="text" name="username" placeholder="请输入用户名"><br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```

编写完上面的内容后，配置好Tomcat运行环境就可以启动Tomcat服务器测试效果。需要注意，因为当前并没有提及Ajax，所以此时服务器端响应的结果会在一个新页面展示