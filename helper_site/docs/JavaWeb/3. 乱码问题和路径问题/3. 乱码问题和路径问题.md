# 乱码问题和路径问题

## 乱码问题

在Java基础部分已经提到过[字符编码](https://www.help-doc.top/Java/javaio/javaio.html#_18)，而所谓的乱码就是编码时使用的[字符集](https://www.help-doc.top/Java/javaio/javaio.html#_19)和解码时使用的字符集不同，所以解决乱码的唯一方式就是确保编码和解码使用的是同一个编码

在Web开发阶段，有下面几种乱码的情况：

1. HTML乱码
2. Tomcat控制台乱码
3. 请求乱码问题

      1. GET请求乱码
      2. POST方式请求乱码

4. 响应乱码问题

### HTML乱码问题

设置项目文件的字符集要使用一个支持中文的字符集

1. 查看当前文件的字符集

    <img src="3. 乱码问题和路径问题.assets/1682325817829.png"/>

2. 查看项目字符集配置，将`Global Encoding`全局字符集，`Project Encoding`项目字符集，`Properties Files`属性配置文件字符集设置为UTF-8

    <img src="3. 乱码问题和路径问题.assets\1682326229063.png">

HTML文件的字符集通过`<meta charset="UTF-8">`来告知浏览器通过什么字符集来解析当前文件，例如下面的文件：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    中文
</body>
</html>
```

在IDEA中，如果更改了`<meta charset="UTF-8">`中的UTF-8，那么IDEA会自动更改当前文件的编码

### Tomcat控制台乱码问题

在Tomcat10这个版本中，修改`tomcat->conf->logging.properties`中，所有的UTF-8为GBK即可

修改前：

<img src="3. 乱码问题和路径问题.assets\1681443202115.png">

修改后：

<img src="3. 乱码问题和路径问题.assets\1681443273573.png">

如果遇到使用`System.out.prinln()`输出乱码，则需要告诉JVM虚拟机以什么字符集进行解码。在编写文件时，IDEA会根据文件的字符集将当前的`.java`文件编译成对应字符集的`.class`文件，但是解码时，IDEA并没有告知JVM使用何种字符集进行解码，所以此时需要进行下面的设置：

<img src="3. 乱码问题和路径问题.assets\1695189588009.png">

### GET请求乱码问题

GET请求方式乱码原因分析：

GET方式提交参数的方式是将参数放到URL后面，如果使用的不是UTF-8，那么会对参数进行URL编码处理，而HTML中的`<meta charset='字符集'/>`影响了GET方式提交参数的URL编码，在Tomcat10中，URI编码默认为UTF-8，当GET方式提交的参数URL编码和Tomcat10默认的URI编码不一致时就会出现乱码

GET请求乱码问题解决方式如下：

方式1：设置GET方式提交的编码和Tomcat的URI默认解析编码一致即可 (推荐)

<img src="3. 乱码问题和路径问题.assets\1682386298048.png">

方式2：设置Tomcat10的URI解析字符集和GET请求发送时所使用URL转码时的字符集一致即可，修改`conf/server.xml`中`Connecter`添加`URIEncoding="GBK"`（不推荐）

!!! note

    之所以不推荐这种方式，是因为这种方式取决于Tomcat所运行的系统环境，如果另一台服务器的编码不是GBK，则此时的Tomcat在放到该服务器时就会出现乱码

<img src="3. 乱码问题和路径问题.assets\1682386551684.png">

<img src="3. 乱码问题和路径问题.assets\1682386611945.png">

### POST方式请求乱码问题

POST请求方式乱码原因分析：

POST请求将参数放在请求体中进行发送，请求体使用的字符集受到了`<meta charset="字符集"/>`的影响，而Tomcat10默认使用UTF-8字符集对请求体进行解析，如果请求体的URL转码和Tomcat的请求体解析编码不一致就容易出现乱码

POST请求方式乱码解决方式如下：

方式1：请求时，使用UTF-8字符集提交请求体（推荐）

<img src="3. 乱码问题和路径问题.assets\1682387836615.png">

<img src="3. 乱码问题和路径问题.assets\1682387857587.png">

方式2：后端在获取参数前，设置解析请求体使用的字符集和请求发送时使用的字符集一致（不推荐）

<img src="3. 乱码问题和路径问题.assets\1682388026978.png">

### 响应乱码问题

响应乱码原因分析：

在Tomcat10中，向响应体中放入的数据默认使用了工程编码为UTF-8，浏览器在接收响应信息时，使用了不同的字符集或者是不支持中文的字符集就会出现乱码

响应乱码解决方式：

方式1：手动设定浏览器对本次响应体解析时使用的字符集（不推荐），因为Edge和Chrome浏览器都没有提供直接的比较方便的入口，不方便

方式2：后端通过设置响应体的字符集和浏览器解析响应体的默认字符集一致（不推荐）

<img src="3. 乱码问题和路径问题.assets\1682388026978.png">

方式3：通过设置`Content-Type`响应头告诉浏览器以指定的字符集解析响应体（推荐）

<img src="3. 乱码问题和路径问题.assets\1682389263627.png">

<img src="3. 乱码问题和路径问题.assets\1682389317234.png">

## 路径问题

定位一个资源时，有两种路径可以选择：

1. 绝对路径
2. 相对路径

相对路径的特点：

- 相对路径的规则是: 以当前资源所在的路径为出发点去寻找目标资源
- 相对路径不以`/`开头
- 在file协议下，使用的是磁盘路径
- 在http协议下，使用的是`url`路径
- 相对路径中可以使用`./`表示当前资源所在路径，可以省略不写
- 相对路径中可以使用`../`表示当前资源所在路径的上一层路径，需要时要手动添加

绝对路径的特点：

- 绝对路径的规则是：使用以一个固定的路径做出出发点去寻找目标资源，和当前资源所在的路径没有关系
- 绝对路径要以`/`开头
- 绝对路径的写法中，不以当前资源的所在路径为出发点，所以不会出现`./`和`../`
- 不同的项目和不同的协议下，绝对路径的基础位置可能不同，要通过测试确定
- 绝对路径的好处就是：无论当前资源位置在哪，寻找目标资源路径的写法都一致

本次要讨论的路径问题就是基于上面两种的路径，常见的路径问题有下面几种：

1. 前端路径问题
2. 重定向中的路径问题
3. 请求转发中的路径问题

### 前端路径问题

前端路径问题一般出现在HTML文件中访问其他资源时，例如要获取到其他位置的图片、访问其他网页等，下面以访问图片为例

下面是当前目录结构：

<img src="3. 乱码问题和路径问题.assets\Snipaste_2024-12-09_19-53-37.png">

#### 相对路径

在`index.html`中引入`static/img/image.png`文件，代码如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>index</title>
</head>
<body>
<h1>这是index</h1>
<img src="static/img/image.png" />
</body>
</html>
```

启动Tomcat可以看到网页中正常显示了图片内容，下面分析为什么`index.html`中的图片会被正常访问到：

访问`index.html`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/index.html`，当前资源为`index.html`，当前资源（`index.html`）的所在路径为：`http://localhost:8080/FrontEnd_war_exploded/`。要获取的目标资源`url`为 :  `http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`

因为`index.html`中定义的了：`<img src="static/img/logo.png"/>`，因为是相对路径，所以寻找方式就是在当前资源所在路径（`http://localhost:8080/FrontEnd_war_exploded/`）后拼接`src`属性值：`static/img/logo.png`，正好是目标资源正常获取的url，即`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`

而根据前面磁盘的路径图构建后的`artifacts`结构正好可以找到`static/img/logo.png`文件，所以正常加载图片：

<img src="3. 乱码问题和路径问题.assets\Snipaste_2024-12-09_20-07-26.png">

!!! note

    此处展示构建后的`artifacts`只是为了演示为什么可以正常读取，在实际开发中不可能先构建再写路径，所以需要记住`web`目录下的内容除了`WEB_INF`、`lib`以外，其他目录都会处于项目的根路径下，特别注意`src`目录会被转换为`classes`中的文件存放到`WEB_INF`下

接下来，在`test.html`文件中使用同样的`static/img/image.png`引入图片：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
<h1>这是test</h1>
<img src="static/img/image.png"/>
</body>
</html>
```

启动Tomcat访问`test.html`可以看到无法正常加载图片，原因如下：

访问`test.html`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`，当前资源为：`test.html`，当前资源的所在路径为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/`，所以寻找方式就是在当前资源所在路径`http://localhost:8080/FrontEnd_war_exploded/a/b/c/`后拼接`src`属性值(`static/img/logo.png`)，此时因为`a/b/c`下不存在`static/img/logo.png`，所以找不到对应的资源

因为要获取的目标资源`url`为：`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`，可以考虑使用`../`抵消掉`a/b/c`，此时`test.html`中的`img`的`src`就是：`<img src="../../../static/img/logo.png"/>`。
其中`../`可以抵消一层路径，正好是目标资源正常获取的`url`：`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`

接着在`view1.html`中引入static/img/logo.png，但是因为WEB-INF中的内容无法直接访问，此时需要用到请求转发，在`view1Servlet`中编写请求转发代码：

```java
@WebServlet("/view1Servlet")
public class View1Servlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("这是view1Servlet");

        RequestDispatcher requestDispatcher = req.getRequestDispatcher("WEB-INF/views/view1.html");
        requestDispatcher.forward(req, resp);
    }
}
```

再向`view1.html`写入下面的代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>view1</title>
</head>
<body>
<h1>这是view1</h1>
<img src="static/img/image.png" />
</body>
</html>
```

启动Tomcat可以看到正常显示图片，此时就不是直观的看磁盘目录结构了，因为直接看磁盘目录结构可以发现`view1.html`不可能按照`static/img/image.png`可以找到图片，实际上是因为请求转发不会替换地址栏的内容，本质上就是通过替换view1Servlet来拼接`static/img/image.png`，所以就可以正常找到图片

#### 绝对路径

接下来看绝对路径的情况：

绝对路径情况1：`web/index.html`中引入`static/img/logo.png`

- 访问`index.html`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/index.html`
- 绝对路径的基准路径为：`http://localhost:8080`
- 要获取的目标资源`url`为：`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`
- `index.html`中定义的了：`<img src="/FrontEnd_war_exploded/static/img/logo.png"/>`
- 寻找方式就是在基准路径（`http://localhost:8080`)后面拼接`src`属性值（`/FrontEnd_war_exploded/static/img/logo.png`），得到的正是目标资源访问的正确路径

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!-- 绝对路径写法 -->
    <img src="/FrontEnd_war_exploded/static/img/logo.png">
</body>
</html>
```

绝对路径情况2：`a/b/c/test.html`中引入`static/img/logo.png`

- 访问`test.html`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`
- 绝对路径的基准路径为：`http://localhost:8080`
- 要获取的目标资源url为：`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`
- `test.html`中定义的了：`<img src="/FrontEnd_war_exploded/static/img/logo.png"/>`
- 寻找方式就是在基准路径（`http://localhost:8080`）后面拼接`src`属性值（`/FrontEnd_war_exploded/static/img/logo.png`），得到的正是目标资源访问的正确路径

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!-- 绝对路径写法 -->
    <img src="/FrontEnd_war_exploded/static/img/logo.png">
</body>
</html>
```

绝对路径情况3：`/WEB-INF/views/view1.html`中引入`static/img/logo.png`

`view1.html`在`WEB-INF`下，需要通过`Servlet`请求转发获得

``` java
@WebServlet("/view1Servlet")
public class View1Servlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("WEB-INF/views/view1.html");
        requestDispatcher.forward(req,resp);
    }
}
```

- 访问`view1.html`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/view1Servlet`
- 绝对路径的基准路径为：`http://localhost:8080`
- 要获取的目标资源`url`为：`http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png`
- `view1.html`中定义的了：`<img src="/FrontEnd_war_exploded/static/img/logo.png"/>`
- 寻找方式就是在基准路径（`http://localhost:8080`）后面拼接`src`属性值（`/static/img/logo.png`），得到的正是目标资源访问的正确路径

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<img src="/FrontEnd_war_exploded/static/img/logo.png">
</body>
</html>
```

使用`base`标签定义页面相对路径公共前缀

- `base`标签定义在`head`标签中，用于定义相对路径的公共前缀
- `base`标签定义的公共前缀只在相对路径上有效，绝对路径中无效
- 如果相对路径开头有`./`或者`../`修饰，则`base`标签对该路径同样无效

`index.html`和`a/b/c/test.html`以及`view1Servlet`中的路径处理

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!--定义相对路径的公共前缀，将相对路径转化成了绝对路径-->
    <base href="/FrontEnd_war_exploded/">
</head>
<body>
    <img src="static/img/logo.png">
</body>
</html>
```

项目上下文路径变化问题：通过`base`标签虽然解决了相对路径转绝对路径问题，但是`base`中定义的是项目的上下文路径，但是项目的上下文路径是可以随意变化的，一旦项目的上下文路径发生变化，所有`base`标签中的路径都需要改

解决方案如下：将项目的上下文路径进行缺省设置，设置为`/`，所有的绝对路径中就不必填写项目的上下文了，直接就是`/`开头即可

### 重定向中的路径问题

目标：由`/x/y/z/servletA`重定向到`a/b/c/test.html`

``` java
@WebServlet("/x/y/z/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        
    }
}

```

#### 相对路径

- 访问`ServletA`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/x/y/z/servletA`
- 当前资源为：`servletA`
- 当前资源的所在路径为：`http://localhost:8080/FrontEnd_war_exploded/x/x/z/`
- 要获取的目标资源url为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`
- ServletA重定向的路径：`../../../a/b/c/test.html`
- 寻找方式就是在当前资源所在路径（`http://localhost:8080/FrontEnd_war_exploded/x/y/z/`）后拼接（`../../../a/b/c/test/html`），形成（`http://localhost:8080/FrontEnd_war_exploded/x/y/z/../../../a/b/c/test/html`）每个`../`抵消一层目录，正好是目标资源正常获取的`url`（`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test/html`）

``` java
@WebServlet("/x/y/z/servletA")
public class ServletA extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 相对路径重定向到test.html
        resp.sendRedirect("../../../a/b/c/test.html");
    }
}
```

#### 绝对路径

- 访问`ServletA`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/x/y/z/servletA`

- 绝对路径的基准路径为：`http://localhost:8080`

- 要获取的目标资源`url`为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`

- `ServletA`重定向的路径：`/FrontEnd_war_exploded/a/b/c/test.html`

- 寻找方式就是在基准路径（`http://localhost:8080`）后面拼接（`/FrontEnd_war_exploded/a/b/c/test.html`），得到（`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`）正是目标资源访问的正确路径

绝对路径中需要填写项目上下文路径，但是上下文路径是变换的，可以通过`ServletContext`的`getContextPath()`获取上下文路径，也可以将项目上下文路径定义为`/`缺省路径，那么路径中直接以`/`开头即可

``` java
//绝对路径中，要写项目上下文路径
//resp.sendRedirect("/FrontEnd_war_exploded/a/b/c/test.html");
// 通过ServletContext对象动态获取项目上下文路径
//resp.sendRedirect(getServletContext().getContextPath()-"/a/b/c/test.html");
// 缺省项目上下文路径时，直接以/开头即可
resp.sendRedirect("/a/b/c/test.html");
```

### 请求转发中的路径问题

目标：由`x/y/servletB`请求转发到`a/b/c/test.html`

``` java
@WebServlet("/x/y/servletB")
public class ServletB extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    }
}
```

#### 相对路径

- 访问`ServletB`的`url`为：`http://localhost:8080/FrontEnd_war_exploded/x/y/servletB`

- 当前资源为：`servletB`

- 当前资源的所在路径为：`http://localhost:8080/FrontEnd_war_exploded/x/y/`

- 要获取的目标资源url为：`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test.html`

- `ServletA`请求转发路径：`../../a/b/c/test/html`

- 寻找方式就是在当前资源所在路径（`http://localhost:8080/FrontEnd_war_exploded/x/y/`）后拼接（`../../a/b/c/test/html`），形成（`http://localhost:8080/FrontEnd_war_exploded/x/y/../../a/b/c/test/html`）每个`../`抵消一层目录，正好是目标资源正常获取的`url`（`http://localhost:8080/FrontEnd_war_exploded/a/b/c/test/html`）

``` java
@WebServlet("/x/y/servletB")
public class ServletB extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("../../a/b/c/test.html");
        requestDispatcher.forward(req,resp);
    }
}
```

#### 绝对路径

- 请求转发只能转发到项目内部的资源，其绝对路径无需添加项目上下文路径

- 请求转发绝对路径的基准路径相当于`http://localhost:8080/FrontEnd_war_exploded`

- 在项目上下文路径为缺省值时，也无需改变，直接以/开头即可

```java
@WebServlet("/x/y/servletB")
public class ServletB extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("/a/b/c/test.html");
        requestDispatcher.forward(req,resp);
    }
}
```

#### 目标资源内相对路径处理

- 此时需要注意，请求转发是服务器行为，浏览器不知道，地址栏不变化，相当于访问`test.html`的路径为`http://localhost:8080/FrontEnd_war_exploded/x/y/servletB`

- 那么此时`test.html`资源的所在路径就是`http://localhost:8080/FrontEnd_war_exploded/x/y/所以test.html`中相对路径要基于该路径编写，如果使用绝对路径则不用考虑

``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <!--
        当前资源路径是     http://localhost:8080/FrontEnd_war_exploded/x/y/servletB
        当前资源所在路径是  http://localhost:8080/FrontEnd_war_exploded/x/y/
        目标资源路径=所在资源路径+src属性值 
        http://localhost:8080/FrontEnd_war_exploded/x/y/../../static/img/logo.png
        http://localhost:8080/FrontEnd_war_exploded/static/img/logo.png
        得到目标路径正是目标资源的访问路径	
    -->
<img src="../../static/img/logo.png">
</body>
</html>
```