# Linux文件操作基础

## 引入

在Linux第一章提到过，[在Linux中，一切皆文件](https://www.helper-wiki.top/Linux/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4.html?h=%E7%9A%86#_8)，而文件由文件内容和文件属性组成，在C语言中可以使用相应的接口打开文件，例如`fopen`函数

文件最开始在磁盘中，但是因为磁盘的速度远低于CPU的执行速度，根据冯诺依曼体系结构，CPU与内存进行交互，所以可以推出文件要被程序读取，就需要与程序加载到内存变成进程一样，文件也需要加载到内存，而加载到内存中的文件包括其内容和属性，内容可以类比为进程的代码和数据，而因为操作系统也需要管理加载到内存的文件，所以文件属性也被存储到一个结构中，可以类比为进程的PCB

所以，在研究Linux文件系统部分主要研究两种文件：

1. 加载到内存的文件
2. 存储在磁盘中的文件

## 回顾C语言文件操作

在C语言中，常见的处理文件的步骤如下：

1. 打开文件：`fopen`函数
2. 读取/写入内容：`fwrite`函数或者`fread`函数
3. 关闭文件：`fclose`函数

示例代码如下：

```c
#include <stdio.h>
#include <string.h>

int main()
{
    // 以写的方式打开
    FILE* fp = fopen("test.txt", "w");
    // 向文件中写数据
    const char* content = "hello linux\n";
    fwrite(content, 1, strlen(content), fp);
    // 关闭文件
    fclose(fp);

    return 0;
}
```

在上面的代码中，使用`fopen`函数以`w`的方式打开当前目录下名为`test.txt`的文件，通过`fwrite`函数向文件中写入一个字符串，最后调用`fclose`函数关闭文件

在C语言部分学到过，一切以`w`方式打开的文件，不论是否向该文件写入数据，都会优先清空文件中的数据，而如果指定的文件不存在，不论之后是否会写入都会先创建文件，下面是文档对`w`方式的介绍：

!!! quote
    **w**    Truncate file to zero length or create text file for writing. The stream is positioned at the beginning of the file.

这一段描述中第一个需要关注的就是「truncate」，该单词的含义为「截断」，此段描述中的「truncate file to zero length」表现的效果就是清空文件内容

第二个需要关注的是「create」，该单词的含义为「创建」，此段描述中的「create text file for writing」表现的效果就是如果指定文件不存在就创建文件

除了`w`方式以外，还有一个`a`方式，以`a`方式打开的文件，不论是否向该文件写入数据，都不会清空数据，如果需要写入，则是在文件已有的内容之后进行追加，同样如果指定的文件不存在，不论之后是否会写入都会先创建文件，下面是文档对`a`方式的介绍：

!!! quote
    **a**    Open for appending (writing at end of file). The file is created if it does not exist.  The stream is positioned at the end of the file.

这一段描述中第一个需要关注的就是「append」，该单词的含义为「追加」，此段描述中的「opening for appending」表现的效果就是在文件已有内容之后追加写新的内容

第二个需要关注的是「create」，该单词的含义为「创建」，此段描述中的「The file is created if it does not exist」表现的效果就是如果指定文件不存在就创建文件

除了上面的操作性知识回顾以外，在C语言中也学到，默认情况下，程序在启动时默认会开启三个流：

1. `stdin`：标准输入流，一般认为是从键盘文件读取
2. `stdout`：标准输出流，一般认为是写入显示器
3. `stderr`：标准输出流，一般认为是写入日志文件或者写入显示器

## 系统调用接口

在[操作系统基础](https://www.helper-wiki.top/Linux/6.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html#_3)部分提到过，操作系统上层存在一个系统调用接口部分，实际上C语言提供的文件操作函数都是语言级的函数，对于不同的操作系统，系统调用接口部分也会提供不同的函数供上层调用，为了更加便捷，C语言针对操作系统封装了对应的系统接口形成对应的函数，例如在Linux中，C语言的`fopen`实际上封装的就是Linux系统接口`open`函数

### `open`函数

根据Linux的操作手册，下面是`open`函数的两种函数原型：

```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

参数解释：

1. `pathname`：文件路径名
2. `flags`：打开文件的方式
3. `mode`：创建文件是，文件所拥有的权限

!!! note
    需要注意的是，对于第一种方式，因为没有参数可以传递文件创建时的权限，所以一般不会用第一种方式创建文件，更多得可能还是使用第二种方式

返回值解释：

两个函数都返回文件描述符，该值唯一代表一个加载到内存的文件

在Linux中，`flags`有下面几种常用的值，这些值都是被定义的宏：

1. `O_RDONLY`：只读模式
2. `O_WRONLY`：只写模式
3. `O_RDWR`：读写模式
4. `O_TRUNC`：覆写模式
5. `O_CREAT`：文件不存在时创建文件
6. `O_APPEND`：追加模式

!!! note
    注意，上面的所有模式只有给出的文字描述中的一种效果，没有其他效果

在给`open`函数的`flags`参数传递实参时，如果只传递五种模式的其中一种，一个参数完全可以胜任，但是如果想一次传递多个模式，比如以只写并且文件不存在时创建文件模式打开，此时就涉及到两个模式，一个形参如果通过直接赋值的形式，则无法同时识别两个模式。为了解决这个问题，实际上在Linux中，这个`flags`是个32个比特位的[位图](https://www.helper-wiki.top/数据结构/14. 位图/14. 位图.html#_1)结构，此时传递参数就可以按照位运算的方式传递，在`open`函数中，只需要判断位图中为1的部分就可以知道指定了哪些模式，下面以一个例子帮助理解这一个思路：

1. 定义一些宏模拟上面的模式

    ```c
    // 1左移0位，结果还是1（二进制位01）
    #define AONE (1 << 0) 
    // 1左移1位，结果是2（二进制位10）
    #define ATWO (1 << 1)
    // 1左移2位，结果是4（二进制100）
    #define ATHREE (1 << 2)
    ```

2. 创建函数，参数设置为一个整数，内容为打印指定模式

    ```c
    void print(int flag)
    {
        // 与运算取出二进制中的1判断指定模式是否选择
        if (flag & AONE)
        {
            printf("AONE模式\n");
        }
        if (flag & ATWO)
        {
            printf("ATWO模式\n");
        }
        if (flag & ATHREE)
        {
            printf("ATHREE模式\n");
        }
    }
    ```

3. 测试

    ```c
    #include <stdio.h>

    int main()
    {
        // 1种模式
        print(AONE);
        printf("************\n");
        // 2种模式，将为0的比特位置为1
        print(AONE | ATWO);
        printf("************\n");
        // 3种模式
        print(AONE | ATWO | ATHREE);
    }

    输出结果：
    AONE模式
    ************
    AONE模式
    ATWO模式
    ************
    AONE模式
    ATWO模式
    ATHREE模式
    ```

### `read`函数和`write`函数

在Linux中，`read`函数和`write`函数读和写的系统调用接口，其原型如下：

```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

参数解释：

1. `fd`：文件描述符，对应`open`函数返回值
2. `buf`：指向指定数组，对于`read`函数来说，代表存入读取到的内容的起始地址；对于`write`函数来说，代表待输出的内容的起始地址
3. `count`：代表期望内容个数，对于`read`函数来说，代表最大读取内容的个数；对于`write`函数来说，表示最大输出内容的个数

返回值解释：

两个函数均返回实际的内容个数，对于`read`函数来说，代表实际读取内容的个数；对于`write`函数来说，表示实际输出内容个数

### `close`函数

在Linux中，`close`函数是关闭文件的系统调用接口，其原型如下：

```c
int close(int fd);
```

参数解释：`fd`代表文件描述符，与`open`函数的返回值对应

返回值解释：0代表关闭成功，小于0代表失败

### 模拟C语言接口

有了上面的铺垫，现在考虑`open`函数的使用模拟`w`的方式，根据前面C语言中w方式的描述：以写模式打开并且不存在指定文件时创建该文件，若指定文件中有内容就清除文件内容，需要使用到只写模式、文件不存在时创建模式和覆写模式

先观察三个模式依次搭配的特点：

- `O_WRONLY`

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <unistd.h>

    int main()
    {
        // 以只写模式打开文件
        int fd = open("test.txt", O_WRONLY);
        // 向文件中写入
        const char* content = "hello linux\n";
        int num = write(fd, content, strlen(content));
        printf("%d\n", num);
        // 关闭文件
        close(fd);

        return 0;
    }
    ```

    向当前目录中的`test.txt`文件输出内容：

    <img src="13. Linux文件操作基础.assets\image.png">

    如果此时将写入的内容变短为3个字符，观察下面代码的运行结果：

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <unistd.h>

    int main()
    {
        // 以只写模式打开文件
        int fd = open("test.txt", O_WRONLY);
        // 向文件中写入
        const char* content = "bye";
        write(fd, content, strlen(content));
        // 关闭文件
        close(fd);

        return 0;
    }
    ```

    向当前目录中的`test.txt`文件输出内容：

    <img src="13. Linux文件操作基础.assets\image1.png">

    可以看到，只写模式打开一个有内容的文件默认不会清除原始内容，而是覆盖写

- `O_TRUNC`和`O_WRONLY`

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <unistd.h>

    int main()
    {
        // 以只写模式打开文件
        int fd = open("test.txt", O_WRONLY | O_TRUNC);
        // 向文件中写入
        const char* content = "hello\n";
        write(fd, content, strlen(content));
        // 关闭文件
        close(fd);

        return 0;
    }
    ```

    向当前目录中的`test.txt`文件输出内容：

    <img src="13. Linux文件操作基础.assets\image2.png">

    可以看到加了`O_TRUNC`宏后，就可以达到打开文件后不论文件是否有内容都会先清空再写入内容

- `O_TRUNC`、`O_WRONLY`和`O_CREAT`

    前面两个选项都只展示了在有指定文件的情况下正常运行，但是C语言的`fopen`函数以`w`方式打开指定文件，当该文件不存在会自动创建，所以此时就需要在系统调用接口加上`O_CREAT`，例如下面的代码：

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <fcntl.h>
    #include <unistd.h>

    int main()
    {
        // 以只写模式打开文件
        int fd = open("test.txt", O_WRONLY | O_TRUNC | O_CREAT);
        // 向文件中写入
        const char* content = "hello, this is linux\n";
        write(fd, content, strlen(content));
        // 关闭文件
        close(fd);

        return 0;
    }
    ```

    删除当前目录的`test.txt`文件后执行上面的代码：

    <img src="13. Linux文件操作基础.assets\image3.png">

    可以看到会自动创建`test.txt`文件再写入指定的内容

    此时就简单实现了C语言中的`w`方式打开的效果，但是此时创建的`test.txt`文件与直接使用`touch`创建的文件有点出入

### `open`函数与文件权限

前面使用到了`open`函数的第一个版本，现在考虑`open`函数第二个版本，这个函数可以传递第三个参数，该参数表示文件创建时拥有的权限，传递[权限八进制值](https://www.helper-wiki.top/Linux/2.%20Linux%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/2.%20Linux%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3.html#_3)

先观察使用第一个版本创建出的文件拥有的权限：
```c++
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    int id = open("test.txt", O_CREAT);

    close(id);

    return 0;
}
```
运行程序结果如下：
<img src="13. Linux文件操作基础.assets\image5.png">

可以看到创建出来的文件所拥有的权限是错乱的，尤其是除了所有者以外的权限，为了避免出现这个情况，就需要使用第二个版本的`open`函数
```c++
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    int id = open("test.txt", O_CREAT, 0666);

    close(id);

    return 0;
}
```
运行程序结果如下：
<img src="13. Linux文件操作基础.assets\image6.png">

可以看到此时文件权限就是正常的，但是因为存在[文件权限掩码`umask`](https://www.helper-wiki.top/Linux/2.%20Linux%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/2.%20Linux%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3.html#_8)，所以其值并不是代码中设置的0666（对应为-rw-rw-rw-），当前系统的文件权限掩码可以通过`umask`指令查看，默认为0002

如果不希望在程序中创建的文件所拥有的权限受到系统umask影响，可以在创建文件之前使用`umask`函数设置初始的文件权限掩码为0：
```c++
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    umask(0);
    int id = open("test.txt", O_CREAT, 0666);

    close(id);

    return 0;
}
```
运行后观察到当前就是程序中指定的0666权限：
<img src="13. Linux文件操作基础.assets\image7.png">

## 文件描述符

前面的系统调用接口函数中，四个函数均涉及到了文件描述符，该描述符在Linux中是对每一个加载到内存的唯一标识，打印指定的文件观察`open`函数返回值：

```c
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    // 以只写模式打开文件
    int fd = open("test.txt", O_WRONLY | O_TRUNC | O_CREAT);
    printf("%d\n", fd);
    // 关闭文件
    close(fd);

    return 0;
}

输出结果：
3
```

根据Linux操作手册，对于`open`函数的返回值具体描述如下：

!!! quote
    open() returns the new file descriptor, or -1 if an error occurred (in which case, errno is set appropriately).

可以看到，当`open`函数打开文件成功时返回-1，否则返回打开的文件对应的文件描述符，为了知道何为文件描述符，这里就需要深入了解在Linux具体是如何描述和管理文件的

首先，有了前面学习进程的基础可以知道每一个进程需要被管理就需要先描述再组织，而描述对应的就是进程PCB（`task_struct`），组织就是双向链表，对于文件也是如此，描述对应的就是`struct file`，组织也是双向链表

但是，如果直接让进程访问文件结构`file`就会增加耦合度，导致操作系统的管理工作会变得繁重，所以在内存中，进程结构在单独的一个区域，文件结构也在单独的一个区域，而为了进程可以访问到文件，进程结构中就存在一个结构体指针`struct files_struct *files`，该结构体指针类型是`struct files_struct *`，所谓的`files_struct`就是将文件和进程建立连接的结构，该结构中存在一个属性：`struct file * fd_array[NR_OPEN_DEFAULT]`，该数组的每一个成员就是指向每一个文件`file`结构的指针，因为是数组，所以可以通过下标访问指定的元素，在当前这个条件下，访问到的就是指向每一个文件`file`结构的指针

所以所谓的文件描述符，就是`fd_array`数组的下标，示意图如下：

<img src="13. Linux文件操作基础.assets\image4.png">

此时就会有第二个问题：为什么在程序中打开的文件默认下标是3，错误是-1，中间的0、1和2表示什么？

前面提到，在C语言程序启动时，会自动加载3种文件流：

1. `stdin`：标准输入流，一般认为是从键盘文件读取
2. `stdout`：标准输出流，一般认为是写入显示器
3. `stderr`：标准输出流，一般认为是写入日志文件或者写入显示器

在Linux手册中，这三个流的原型如下：

```c
#include <stdio.h>

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;
```

可以看到三者均是`FILE`类型，这个类型实际上是语言级上的封装，因为在Linux中文件描述符是访问文件的唯一方式，所以C语言的接口想访问文件就必须要访问到指定文件的文件描述符，所以`FILE`结构中一定可以有文件描述符属性，根据下面代码可以验证（下面的代码中`_fileno`对应的就是文件描述符）：

```c
#include <stdio.h>

int main()
{
    printf("%d\n", stdin->_fileno);
    printf("%d\n", stdout->_fileno);
    printf("%d\n", stderr->_fileno);

    return 0;
}

输出结果：
0
1
2
```

所以，之所以显式打开的文件对应的文件描述符为3是因为默认打开的三个文件占用了`fd_array`数组前面三个空间