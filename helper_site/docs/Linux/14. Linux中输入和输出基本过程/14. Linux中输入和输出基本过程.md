# Linux中输入和输出基本过程

## 文件内核级缓冲区

前面在如何理解Linux一切皆文件的特点中提到为了保证在Linux中所有进程访问文件时的方式趋近相同，在`file`结构体中存在一个`files_operations`结构体指针，对应的结构体保存所有文件操作的函数指针（这个结构体也被称为操作表）

每一个`file`结构体中除了有自己的操作表以外还有一个文件的内核级缓冲区，这个缓冲区不同于语言层面的缓冲区，在调用底层系统接口的读或者写时，会有一方先将内容保存到该缓冲区，再将内容移动到指定设备

例如，对于读函数`read`来说，以从磁盘文件读取文件内容为例，首先操作系统会从磁盘中读取文件内容到缓冲区，再由`read`函数从缓冲区将内容读取到指定的设备；对于`write`函数来说，首先操作系统会将内存中需要写入的内容先写入缓冲区，再由`write`函数从缓冲区写入到磁盘中。除了前面提到的两个单一过程外，还要一种复合过程：对文件的内容进行修改。这一种过程既涉及到读取，也涉及到写入，所以首先需要通过操作系统读入需要修改的内容到内核级缓冲区，由`read`函数将缓冲区中的数据读到内存，在程序运行中对读取到的内容进行修改，再通过`write`函数将修改后的内容写入到缓冲区，最后由操作系统从缓冲区写入到磁盘

如果抽象化一下`read`函数和`write`函数的过程可以发现这两个函数的基本行为就是读写缓冲区，所以这两个函数也可以理解为拷贝函数，`read`函数即为将缓冲区中的数据拷贝到内存中的指定位置，`write`函数即为将内存中的数据拷贝到缓冲区

上面整个过程中，`read`函数和`write`函数只完成对缓冲区中的数据进行处理，但是缓冲区中的数据何时移动到指定的设备由操作系统自主决定

读或者写过程示意图如下：

<img src="14. Linux中输入和输出基本过程.assets\image.png">

## 何为重定向

前面提到，文件描述符是Linux中每一个文件的唯一标识符，也就是说，通过文件描述符可以唯一确定一个文件，而`stdin`、`stdout`和`stderr`是每一个C语言程序默认打开的三个文件，对应的文件描述符为0、1和2，而之所以文件描述符是从0开始，本质是因为文件描述符是`fd_array`数组的下标，当用户再打开一个文件时，对应的文件结构指针就会存储到`fd_array`的指定位置，而因为下标0、1和2已经被占用，所以新开的文件对应的下标只能从3开始

现在关闭0号位置的文件，观察效果，例如下面的代码：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main()
{
    close(0);
    int fd1 = open("test1.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd2 = open("test2.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd3 = open("test3.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd4 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT);

    printf("%d\n", fd1);
    printf("%d\n", fd2);
    printf("%d\n", fd3);
    printf("%d\n", fd4);

    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);

    return 0;
}
```

编译运行上面的代码后可以看到结果如下：

<img src="14. Linux中输入和输出基本过程.assets\image1.png">

如果关闭的是2号文件，观察效果，例如下面的代码：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main()
{
    close(2);
    int fd1 = open("test1.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd2 = open("test2.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd3 = open("test3.txt", O_WRONLY | O_TRUNC | O_CREAT);
    int fd4 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT);

    printf("%d\n", fd1);
    printf("%d\n", fd2);
    printf("%d\n", fd3);
    printf("%d\n", fd4);

    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);

    return 0;
}
```

编译运行上面的代码后可以看到结果如下：

<img src="14. Linux中输入和输出基本过程.assets\image2.png">

从上面的代码中可以看出，在Linux中，一个文件被打开时，文件描述符的分配原则是在`fd_array`中找到最小的且没有被其他`file`结构指针占用的位置

以关闭0号位置为例，示意图如下：

<img src="14. Linux中输入和输出基本过程.assets\image3.png">

但是，前面的代码中，只演示了关闭0号位置和2号位置的文件，如果此时关闭1号位置的文件，再打开同样的四个文件，输出每一个文件的文件描述符，从前面的规律可以推出，输出语句会因为1号位置的文件是`test1.txt`而将内容输出到`test1.txt`中，例如下面的代码：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main()
{
    close(1);
    int fd1 = open("test1.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd2 = open("test2.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd3 = open("test3.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd4 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);

    printf("%d\n", fd1);
    printf("%d\n", fd2);
    printf("%d\n", fd3);
    printf("%d\n", fd4);

    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);

    return 0;
}
```

编译运行上面的代码后可以看到不论是`test1.txt`还是其他文件都没有显示需要的内容，控制台也没有正常打印需要的内容

但是如果将代码修改为如下：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main()
{
    // ...
    fflush(stdout);

    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);

    return 0;
}
```

编译运行上面的代码后可以看到结果如下：

<img src="14. Linux中输入和输出基本过程.assets\image4.png">

现在就引入了一个问题，为什么加了`fflush(stdout)`就可以看到需要的效果

在解决上面的问题之前，先介绍一下何为重定向，在上面的演示中，先关闭了某一个文件描述符较前的文件，再打开另一个文件，打开的这个文件所处的位置是就是被关闭的那个文件的位置，此时再使用输出语句输出内容，原本应该输出到文件描述符较前的原始文件中，比如前面的`stdout`，后面却输出到了文件中`test1.txt`，这个过程就称为文件重定向，主要原理就是文件描述符是固定不变的，而输出和输入只认文件描述符，不会在意这个文件描述符对应的位置指向的是哪一个文件

在Linux中，存在一个系统调用接口使得可以在程序中实现重定向，这个函数为`dup2`，其原型如下：

```c
int dup2(int oldfd, int newfd);
```

在Linux操作手册中，dup2函数的描述如下：

!!! quote
    dup2() makes newfd be the copy of oldfd, closing newfd first if necessary

参数解释：

1. `oldfd`：该参数表示待拷贝的文件的文件指针对应的文件描述符
2. `newfd`：该参数表示被覆盖的文件的文件指针对应的文件描述符

示意图如下：

<img src="14. Linux中输入和输出基本过程.assets\image5.png">

所以，使用`dup2`就可以实现使用`printf`函数本应该输出到`stdout`中，而输出到`test1.txt`的效果，代码如下：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

int main()
{
    int fd1 = open("test1.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd2 = open("test2.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd3 = open("test3.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd4 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);

    dup2(fd1, 1);

    printf("%d\n", fd1);
    printf("%d\n", fd2);
    printf("%d\n", fd3);
    printf("%d\n", fd4);

    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);

    return 0;
}
```

需要注意，因为在使用`dup2`函数之前，`stdout`已经被打开了，此时`open`函数打开`test1.txt`文件时就只能使用3号下标的位置，所以可以看到`dup2`函数的确实现了将内容输出到`test1.txt`文件而不是`stdout`中，此时示意图如下：

<img src="14. Linux中输入和输出基本过程.assets\image6.png">

这里需要注意一个细节：尽管`dup2`函数会关闭被覆盖的文件`stdout`，但是关闭后被拷贝的文件`test1.txt`占用了被覆盖的文件`stdout`的位置，所以再打开其他文件依旧会从7号位置开始，例如下面的代码演示：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

int main()
{
    int fd1 = open("test1.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd2 = open("test2.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd3 = open("test3.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);
    int fd4 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666);

    dup2(fd1, 1);
    int fd5 = open("test4.txt", O_WRONLY | O_TRUNC | O_CREAT, 0666); // 重定向后打开一个新文件
    
    printf("%d\n", fd1);
    printf("%d\n", fd2);
    printf("%d\n", fd3);
    printf("%d\n", fd4);
    printf("%d\n", fd5);


    close(fd1);
    close(fd2);
    close(fd3);
    close(fd4);
    close(fd5);

    return 0;
}
```

编译运行上面的代码后可以看到结果如下：

<img src="14. Linux中输入和输出基本过程.assets\image7.png">

## 手撕一个简单的shell（版本2）

### 判断重定向命令与截取

在第一个版本中已经实现了shell基本的功能，但是前面并没有解决重定向问题，本次版本中主要实现重定向的效果

首先观察一条命令目的是将指定内容重定向到指定文件时的基本结构，以`ls`+重定向为例：

```bash
// 输出重定向
ls -l > test.txt
// 追加重定向
ls -l >> test.txt
// 输入重定向
ls -l < test.txt
```

可以看到，重定向时需要使用到三个字符：`>`、`>>`和`<`，所以可以通过判断这三个字符判断是否是重定向，接下来的问题就转化为如何判断

在前面获取用户输入的命令时，将用户的输入当成一串字符串看待，接下来在另一个函数中处理该字符串（对字符串进行切割），所以判断其中的字符就需要在切割字符串时处理，并且需要在调用`strtok`函数切割前处理

可以考虑从尾部向前遍历字符串，如果遇到了三个字符中的其中一个就停止，在这个过程中，需要注意两个字符`>`和`>>`，在Linux中，对于追加重定向的符号`>>`来说，不允许两个`>`中含有空格，所以判断是`>`后还需要判断前一个字符是不是`>`，所以判断逻辑主要分成两种：

1. 是否是`>`
    1. 再判断前一个字符是否是`>`
2. 是否是`<`

!!! note
    这里需要注意出现的先后，不要单独将`>>`拿出来判断，此时如果先写判断是否是`>`的逻辑且判断`>>`是`else if`的分支时，就会出现判断`>>`始终无法进入

反向遍历到三个符号中的一个之后进入对应分支中就可以开始处理分割问题，在C语言中，一个字符串的结尾即为`\0`，所以可以将指定位置置为`\0`达到分割的效果，分割分为三种情况：

1. `>`：将`>`位置置为0，此时前面的内容即为普通命令，后面的内容即为文件名
2. `>>`：将两个`>`位置置为0，此时前面的内容即为普通命令，后面的内容即为文件名
3. `<`：将`<`位置置为0，此时前面的内容即为普通命令，后面的内容即为文件名

需要注意，获取到的文件名不一定一开始就是有效字符，还需要处理第一个有效字符前的空格问题，所以这里可以考虑使用一个宏函数或者内联函数解决，基本思路就是一直遍历到第一个有效字符为止：

=== "宏函数"

    ```c++
    // 跳过空白字符
    #define Trim(pos) do {\
        while(isspace(*pos))\
        {\
            pos++;\
        }\
    }while(0)
    ```

=== "内联函数"

    ```c++
    inline void trim(char* pos) 
    {
        while(isspace(*pos))
        {
            pos++;
        }
    }
    ```

!!! note
    上面的宏函数中使用`do...while(0)`结构只是确保主体逻辑代码被代码块包裹，使结构更加清晰

示例代码如下：

```c++
// 重定向状态
enum redirStatus
{
    NONE,
    APPEND,
    TRUNCATE,
    INPUT 
};
// 重定向状态码
int redirCode;
// 文件名
char* filename;

void parseInput()
{
    // ...

    // 重定向
    redirCode = NONE;
    filename = nullptr;

    printf("command start: %s\n", input_arr);
    // 判断是否存在重定向符号
    size_t end = strlen(input_arr) - 1;
    while(end)
    {
        if(input_arr[end] == '>')
        {
            // 判断前面一个字符是否是>
            if(input_arr[end - 1] == '>')
            {
                redirCode = APPEND;
                // 切割字符串
                input_arr[end - 1] = 0;
                input_arr[end] = 0;
                // 获取文件名，重定向符的下一个位置
                filename = &input_arr[end+1];
                // 去除空格
                trim(filename);
                // 查找到重定向符号后就可以停止遍历
                break;
            }
            else 
            {
                // 输出重定向
                redirCode = TRUNCATE;
                // 切割字符串
                input_arr[end] = 0;
                // 获取文件名
                filename = &input_arr[end+1];
                // 去除空格
                trim(filename);
                // 查找到重定向符号后就可以停止遍历
                break;
            }
        }
        else if(input_arr[end] == '<')
        {
            // 输入重定向
            redirCode = INPUT;
            // 切割字符串
            input_arr[end] = 0;
            // 获取文件名
            filename = &input_arr[end+1];
            // 去除空格
            trim(filename);
            // 查找到重定向符号后就可以停止遍历
            break;
        }
        else 
        {
            // 一直向前查找
            --end;
        }
    }

    printf("redir: %d\n", redirCode);
    printf("filename: %s\n", filename);
    printf("command end: %s\n", input_arr);

    // 拆分读取的字符串
    for(char* ch = strtok(input_arr, " "); (bool)ch; ch = strtok(nullptr, " "))
    {
       global_argv[global_argc++] = ch; 
    }
}
```