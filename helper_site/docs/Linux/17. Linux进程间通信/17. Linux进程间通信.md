# Linux进程间通信

## 进程间通信介绍

进程间通信，就是让进程之间可以访问同一个资源，但是进程本身是具有独立性的，所以直接让两个进程访问同一个资源是做不到的

!!! note

    需要注意，尽管父子进程可以访问到全局变量，但是这个变量如果子进程要修改就会发生写时拷贝，最后导致两个进程看到的实际上并不是同一个全局变量

既然从进程角度出发无法直接做到，就需要考虑通过「第三方」进行，此处的「第三方」就是操作系统。从某一个角度来看，操作系统是所有进程所共享的资源

进程间通信在Linux中有下面的作用：

1. 数据传输：一个进程需要将它的数据发送给另一个进程
2. 资源共享：多个进程之间共享同样的资源
3. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
4. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

进程间通信本质上属于本地通信，即在同一台主机、同一个操作系统下进行的通信，对应着就有三种标准，根据进程间通信的发展，最先出现的就是管道方式通信，其次就是System V进程间通信一直到现在的POSIX进程间通信

其中，管道方式通信有下面两种：

1. 匿名管道
2. 命名管道

System V进程间通信有下面三种：

1. System V消息队列
2. System V共享内存
3. System V信号量

POSIX进程间通信有下面6种：

1. 消息队列
2. 共享内存
3. 信号量
4. 互斥量
5. 条件变量
6. 读写锁

## 管道介绍

在介绍匿名管道前，先了解何为管道：

管道是Unix/Linux中最古老的进程间通信的形式，把从一个进程连接到另一个进程的一个数据流称为一个「管道」。在前面[Linux常用选项和指令](https://www.help-doc.top/Linux/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4.html#_11)已经介绍过管道的基础使用，此处进一步探讨管道到底是如何执行的

以下面的命令为例：

```shell
who | wc -l
```

这个指令的作用是：统计当前使用Linux系统有多少个用户登录。其中，`who`显示当前登录的用户和其他信息，`wc`用于代表word count，可以用来统计给定文件中的字节数、字数、行数等，其中的`-l`表示只输出行数

上面的命令执行过程如下：

<img src="17. Linux进程间通信.assets/image-20241222213037593.png"/>

为了揭示管道左右两侧的命令的本质，可以执行下面的命令：

```shell
sleep 10 | sleep 20 &
```

!!! info "后台执行符号`&`"

    当在命令末尾加上`&`符号时，它会让该命令在后台运行，这样就可以立即得到命令行提示符，并可以继续输入其他命令而不必等待前面的命令完成

上面命令的作用是：同时启动睡眠计时器，并让二者在后台运行

执行上面的指令后使用下面的指令查看`sleep`进程：

```shell
ps ajx | head -1 && ps ajx | grep sleep
```

可以看到下面的结果：

<img src="17. Linux进程间通信.assets\Snipaste_2024-12-22_21-37-39.png">

观察到二者的均为进程，并且二者的父进程相同，说明管道左侧和右侧的指令都变为了进程，并且具有兄弟关系。根据这个现象，可以得出**管道实际上就是为两个进程提供通信的方式**

## 匿名管道

### 匿名管道介绍

对管道有了了解后，接下来就可以了解何为匿名管道

在前面学习文件时，当文件需要被一个进程打开时，操作系统会根据进程的CWD找到文件所在目录，再根据文件名和`inode`编号映射找到对应的文件将其加载到内存，此时在文件视角会创建对应的`struct file`，在进程视角会存在进程PCB和`files_struct`，其中存在`fd_array`，并在`fd_array`的空位置存储文件指针，为了可以进行文件内容写入和读取，打开文件后也会创建对应的文件内核级缓冲区，如下图所示：

<img src="17. Linux进程间通信.assets\Snipaste_2024-12-22_21-52-11.png">

如果此时的进程创建了一个子进程，那么在子进程不修改数据的前提下，子进程会拷贝父进程的`task_struct`、`files_struct`（包括`fd_array`）以及`struct file`，但是子进程不会再次打开父进程已经打开的文件，也就是说，对于文件内核级缓冲区和已经从磁盘加载到内存的文件来说，子进程和父进程是共享的

!!! note

    子进程之所以要拷贝`struct file`是为了保证子进程也可以向文件中写入数据，在`struct file`中存在文件偏移量，当子进程修改这个文件偏移量时只有在不与父进程共享的前提下才可以做到父进程和子进程在文件的不同位置写入数据

!!! info "何时关闭文件"

    当一个进程打开了一个文件，那么正常情况下，在该进程结束后，这个文件会自动被操作系统释放，那么操作系统是如何知道这个文件已经没有进程在访问的，其实是通过`struct file`中的一个称为「引用计数」的属性，这个属性子进程并不会修改，只有这个引用计数为0时，操作系统才会自动释放文件。进程也可以调用关闭文件的接口关闭文件，例如`close()`

既然子进程和父进程共享一个文件内核级缓冲区，那么此时这个文件内核级缓冲区就是子进程和父进程两个进程所共享的资源，也就满足了进程间通信的前提条件：「进程间共享同一个资源」，并且这个资源并不是由子进程或者父进程提供，而是由操作系统提供的，所以也就不会因为进程独立性导致一个进程修改另外一个进程看不到的情况

但是现在的问题就是每一次父子进程需要通信就必须先打开一个磁盘中存在的文件，这个过程就会有点繁琐并且如果频繁做IO也会影响到系统整体的效率。为了解决这个问题就需要考虑一种存在于内存中的结构，这个结构不需要实际存在于硬盘中，也就想到了直接使用一个匿名的文件内核级缓冲区。这便是匿名管道「匿名」的由来

既然是文件内核级缓冲区，就说明可以直接调用文件相关的接口直接操作，但需要保证这个文件内核级缓冲区不自动刷新，否则可能读端还没读取到内容数据就已经丢失了。其中「直接调用文件相关的接口」也是最开始想到使用文件内核级缓冲区作为通信介质的原因

!!! info "「管道」的由来"

    之所以叫这个作为进程通信介质的文件内核级缓冲区为「管道」是因为最开始只想到一端向另一端发送数据，也就是一方写入一方读取，即所谓的单向通信，在现实生活中，管道大部分便是一端进一端出，所以将其命名为「管道」

### 创建匿名管道

在Linux中创建匿名管道按照下面的步骤：

1. 父进程调用系统调用接口`pipe()`打开匿名的文件内核级缓冲区，其中`pipe()`接口中传递一个两个元素的数组，数组的第一个元素表示读端，第二个元素表示写端，返回值为一个整数，返回0表示打开成功，-1表示打开失败
2. 父进程创建子进程
3. 因为管道只能单向通信，所以只能读写或者写读，如果是读写，那么父进程就需要关闭写，子进程就需要关闭读，这一步并不是必须的，但是如果不关闭可能会出现误操作导致数据错误