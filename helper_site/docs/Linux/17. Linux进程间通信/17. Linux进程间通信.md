# Linux进程间通信

## 进程间通信介绍

进程间通信，就是让进程之间可以访问同一个资源，但是进程本身是具有独立性的，所以直接让两个进程访问同一个资源是做不到的

!!! note

    需要注意，尽管父子进程可以访问到全局变量，但是这个变量如果子进程要修改就会发生写时拷贝，最后导致两个进程看到的实际上并不是同一个全局变量

既然从进程角度出发无法直接做到，就需要考虑通过「第三方」进行，此处的「第三方」就是操作系统。从某一个角度来看，操作系统是所有进程所共享的资源

进程间通信在Linux中有下面的作用：

1. 数据传输：一个进程需要将它的数据发送给另一个进程
2. 资源共享：多个进程之间共享同样的资源
3. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）
4. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变

进程间通信本质上属于本地通信，即在同一台主机、同一个操作系统下进行的通信，对应着就有三种标准，根据进程间通信的发展，最先出现的就是管道方式通信，其次就是System V进程间通信一直到现在的POSIX进程间通信

其中，管道方式通信有下面两种：

1. 匿名管道
2. 命名管道

System V进程间通信有下面三种：

1. System V消息队列
2. System V共享内存
3. System V信号量

POSIX进程间通信有下面6种：

1. 消息队列
2. 共享内存
3. 信号量
4. 互斥量
5. 条件变量
6. 读写锁

## 管道介绍

在介绍匿名管道前，先了解何为管道：

管道是Unix/Linux中最古老的进程间通信的形式，把从一个进程连接到另一个进程的一个数据流称为一个「管道」。在前面[Linux常用选项和指令](https://www.help-doc.top/Linux/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4/1.%20Linux%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E5%92%8C%E6%8C%87%E4%BB%A4.html#_11)已经介绍过管道的基础使用，此处进一步探讨管道到底是如何执行的

以下面的命令为例：

```shell
who | wc -l
```

这个指令的作用是：统计当前使用Linux系统有多少个用户登录。其中，`who`显示当前登录的用户和其他信息，`wc`用于代表word count，可以用来统计给定文件中的字节数、字数、行数等，其中的`-l`表示只输出行数

上面的命令执行过程如下：

<img src="17. Linux进程间通信.assets/image-20241222213037593.png"/>

为了揭示管道左右两侧的命令的本质，可以执行下面的命令：

```shell
sleep 10 | sleep 20 &
```

!!! info "后台执行符号`&`"

    当在命令末尾加上`&`符号时，它会让该命令在后台运行，这样就可以立即得到命令行提示符，并可以继续输入其他命令而不必等待前面的命令完成

上面命令的作用是：同时启动睡眠计时器，并让二者在后台运行

执行上面的指令后使用下面的指令查看`sleep`进程：

```shell
ps ajx | head -1 && ps ajx | grep sleep
```

可以看到下面的结果：

<img src="17. Linux进程间通信.assets\Snipaste_2024-12-22_21-37-39.png">

观察到二者的均为进程，并且二者的父进程相同，说明管道左侧和右侧的指令都变为了进程，并且具有兄弟关系。根据这个现象，可以得出**管道实际上就是为两个进程提供通信的方式**

## 匿名管道

### 匿名管道介绍

对管道有了了解后，接下来就可以了解何为匿名管道

在前面学习文件时，当文件需要被一个进程打开时，操作系统会根据进程的`CWD`找到文件所在目录，再根据文件名和`inode`编号映射找到对应的文件将其加载到内存，此时在文件视角会创建对应的`struct file`，在进程视角会存在进程PCB和`files_struct`，其中存在`fd_array`，并在`fd_array`的空位置存储文件指针，为了可以进行文件内容写入和读取，打开文件后也会创建对应的文件内核级缓冲区，如下图所示：

<img src="17. Linux进程间通信.assets\Snipaste_2024-12-22_21-52-11.png">

如果此时的进程创建了一个子进程，那么在子进程不修改数据的前提下，子进程会拷贝父进程的`task_struct`、`files_struct`（包括`fd_array`）以及`struct file`，但是子进程不会再次打开父进程已经打开的文件，也就是说，对于文件内核级缓冲区和已经从磁盘加载到内存的文件来说，子进程和父进程是共享的

!!! note

    子进程之所以要拷贝`struct file`是为了保证子进程也可以向文件中写入数据，在`struct file`中存在文件偏移量，当子进程修改这个文件偏移量时只有在不与父进程共享的前提下才可以做到父进程和子进程在文件的不同位置写入数据

!!! info "何时关闭文件"

    当一个进程打开了一个文件，那么正常情况下，在该进程结束后，这个文件会自动被操作系统释放，那么操作系统是如何知道这个文件已经没有进程在访问的，其实是通过`struct file`中的一个称为「引用计数」的属性，这个属性子进程并不会修改，只有这个引用计数为0时，操作系统才会自动释放文件。进程也可以调用关闭文件的接口关闭文件，例如`close()`

既然子进程和父进程共享一个文件内核级缓冲区，那么此时这个文件内核级缓冲区就是子进程和父进程两个进程所共享的资源，也就满足了进程间通信的前提条件：「进程间共享同一个资源」，并且这个资源并不是由子进程或者父进程提供，而是由操作系统提供的，所以也就不会因为进程独立性导致一个进程修改另外一个进程看不到的情况

但是现在的问题就是每一次父子进程需要通信就必须先打开一个磁盘中存在的文件，这个过程就会有点繁琐并且如果频繁做IO也会影响到系统整体的效率。为了解决这个问题就需要考虑一种存在于内存中的结构，这个结构不需要实际存在于硬盘中，也就想到了直接使用一个匿名的文件内核级缓冲区。这便是匿名管道「匿名」的由来

既然是文件内核级缓冲区，就说明可以直接调用文件相关的接口直接操作，但需要保证这个文件内核级缓冲区不自动刷新，否则可能读端还没读取到内容数据就已经丢失了。其中「直接调用文件相关的接口」也是最开始想到使用文件内核级缓冲区作为通信介质的原因

!!! info "「管道」的由来"

    之所以叫这个作为进程通信介质的文件内核级缓冲区为「管道」是因为最开始只想到一端向另一端发送数据，也就是一方写入一方读取，即所谓的单向通信，在现实生活中，管道大部分便是一端进一端出，所以将其命名为「管道」

### 创建匿名管道

在Linux中创建匿名管道按照下面的步骤：

1. 父进程调用系统调用接口`pipe()`打开匿名的文件内核级缓冲区，其中`pipe()`接口中传递一个两个元素的数组，数组的第一个元素表示读端，第二个元素表示写端，返回值为一个整数，返回0表示打开成功，-1表示打开失败
2. 父进程创建子进程
3. 因为管道只能单向通信，所以只能读写或者写读，如果是读写，那么父进程就需要关闭写，子进程就需要关闭读，这一步并不是必须的，但是如果不关闭可能会出现误操作导致数据错误

!!! note

    注意，不可以颠倒步骤1和步骤2，因为只有父进程创建了文件内核级缓冲区，子进程才能拷贝其文件描述符表和文件结构

根据上面的步骤可以写出下面的代码（以父进程读，子进程写为例）：

1. 父进程调用`pipe()`接口

    ```c++
    int fd_pipe[2] = {0};

    // 1. 父进程调用pipe
    int ret = pipe(fd_pipe);
    ```

2. 父进程创建子进程

    ```c++
    // 2. 父进程创建子进程
    int pid = fork();
    ```

3. 父进程关闭写端，子进程关闭读端

    ```c++
    // 3. 父进程关闭写端，子进程关闭读端
    if (pid == 0)
    {
        // 子进程
        // 子进程关闭读端
        close(fd_pipe[0]);
    }
    else
    {
        // 父进程
        // 父进程关闭写端
        close(fd_pipe[1]);
    }
    ```

现在，子进程向匿名管道中写入数据，为了保证父进程看到的数据是动态变化的，可以使用一个计数器`count`，子进程向父进程写入一串字符串，父进程读取该字符串，完整示例代码如下：

```c++
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>

int main()
{
    int fd_pipe[2] = {0};

    // 1. 父进程调用pipe
    int ret = pipe(fd_pipe);

    // 如果ret为0，证明打开成功，否则打开失败
    if (ret)
        return -1;

    pid_t pid = fork();

    if (pid == 0)
    {
        int count = 0;
        // 子进程
        // 子进程关闭读端
        close(fd_pipe[0]);
        // 子进程持续写
        while (true)
        {
            count++;
            std::string msg = "hello linux ";
            msg += std::to_string(count);

            // 写入——C++字符串不包含\0
            write(fd_pipe[1], msg.c_str(), msg.size());
            sleep(1);
        }
    }
    else
    {
        // 父进程
        // 父进程关闭写端
        close(fd_pipe[1]);

        char buffer[1024] = {0};
        // 父进程持续读取
        while (true)
        {
            ssize_t n = read(fd_pipe[0], buffer, 1024);
            // 在字符串末尾添加\0
            buffer[n] = '\0';
            printf("父进程读取到：%s\n", buffer);
        }

        // 回收子进程
        pid_t rid = waitpid(pid, nullptr, 0);
    }
    return 0;
}
```

部分输出结果如下：

<img src="17. Linux进程间通信.assets\Snipaste_2024-12-23_16-03-45.png">

从上面的运行结果可以看到，尽管子进程在一直修改`count`变量，父进程依旧可以正常读取到修改后的`count`，现在基本上就实现了父子进程通信

### 匿名管道的特点

在Linux中，匿名管道有如下四个现象：

1. 如果当前匿名管道为空且正常，那么此时读端就会等待，直到匿名管道中存在数据
2. 如果当前匿名管道为满（在Ubuntu下是64KB）且正常，那么此时写端就会等待，直到匿名管道重新有空间
3. 如果匿名管道的写端关闭，但是读端还在读取，那么此时读端相当于读取到文件结尾结束读取
4. 如果匿名管道写端正常写入，但是读端关闭，那么操作系统会直接关闭写端进程，关闭的方式就是通过发送`SIGPIPE`（编号为13）信号

匿名管道的特点：

1. 面向字节流
2. 用来进行父子等具有“血缘”关系的进程进行进程间通信
3. 匿名管道的生命周期同文件的生命周期
4. 单向数据通信
5. 管道带有同步互斥等保护机制（从上面的现象1和2可以看出）。因为匿名管道属于共享资源，只要是共享资源就会有「数据不一致」问题，此时就必须要有对应的策略对这个资源进行保护，通常这个被保护的资源也被称为临界资源（即在一个时间段内只能有一个进程访问的资源）

!!! info "何为面向字节流"

    当提到匿名管道具有「面向字节流」的特点时，这意味着：

    1. 无消息边界：匿名管道处理的数据被视为连续的字节流，而不是离散的消息。发送方可以写入任意数量的字节到管道中，而接收方则从管道中读取这些字节。但是，读取操作并不保证会一次性读取所有写入的数据；每次读取可能返回任意数量的字节，直到所有数据都被读取完毕。因此，应用程序需要自行管理如何将字节流重新组合成有意义的消息
    2. 顺序性：字节流中的字节保持它们被写入时的顺序。也就是说，第一个写入管道的字节将是第一个被读出的字节（FIFO, First In First Out），这确保了数据传输的顺序不会被打乱
    3. 不可寻址性：由于是面向字节流的，所以不能像文件那样随机访问或定位到特定位置读写数据。你只能从当前的位置开始读或写，且一旦读取后，这些数据就被消费掉了，不能再次读取
    4. 半双工通信：传统上的匿名管道是单向的，即数据只能在一个方向上流动。如果需要双向通信，则必须创建两个管道，每个管道负责一个方向的数据传输。然而，某些现代操作系统提供了全双工的匿名管道
    5. 阻塞性质：当一个进程尝试从管道中读取数据但管道为空时，该读取操作会被阻塞，直到有数据可读为止。同样地，如果管道已满（尽管大多数现代系统对管道容量很大，几乎不会出现这种情况），写入操作也会被阻塞，直到有足够的空间来容纳新数据。
    6. 有限缓冲区：虽然理论上可以认为管道能处理无限量的数据流，但实际上每个匿名管道都有一定的缓冲区大小。当缓冲区满时，写入操作会被阻塞直到有足够空间可用
