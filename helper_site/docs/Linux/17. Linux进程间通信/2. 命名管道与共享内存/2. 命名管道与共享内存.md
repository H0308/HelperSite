# 命名管道与共享内存

## 命名管道介绍和基本使用

理解了匿名管道后，命名管道的理解就会变得容易。在前面使用匿名管道时可以发现，之所以可以匿名是因为由父进程创建，子进程拷贝所以子进程和父进程都可以看到这个管道。但是如果对于任意两个进程，因为进程之间是独立的，需要任意两个进程看到这个管道就需要借助进程通信，但是匿名管道本身就是用于进程通信，所以匿名管道无法用于任意的两个进程。对此，根据一个文件可以被任意一个进程打开并由任意多个进程共享，如果设计一个文件作为两个进程通信方式就可以解决这个问题，此时这个文件也被称为命名管道

在Linux中，创建命名管道的方式有两种：

1. 终端命令`mkfifo 文件名`
2. 函数调用：`int mkfifo(const char *pathname, mode_t mode)`

首先介绍终端命令，使用`mkfifo`命令创建一个管道文件，这个文件的类型是`p`，表示管道（pipe）类型的文件，在当前路径下创建一个命名管道如下图所示：

<img src="2. 命名管道与共享内存.assets/image-20250104173302865.png">

当使用一个指令向管道内写入数据，再使用另外一个指令从管道中读取数据，就可以看到下面的效果：

<img src="2. 命名管道与共享内存.assets\Snipaste_2025-01-04_17-35-49.png">

在匿名管道部分提到过，在终端中指向的指令实际上是一个进程，所以此时使用`echo`的进程向命名管道中写入数据，使用`cat`的进程从命名管道中读取数据，此时就是进程间通信

可以看到，如果两个进程要使用命名管道进行通信，就必须有一个进程先创建命名管道，另外一个进程获取命名管道，所以两个进程使用命名管道的方式为：

1. 创建+使用
2. 获取+使用

如果想要删除一个文件，就可以使用前面提到的`unlink`命令删除管道文件，也可以使用`rm`删除

## 命名管道的原理

之所以叫命名管道，本质就是因为命名管道就是一个文件，一个文件就存在自己的路径，在Linux中，要查找一个文件就会根据这个文件的路径进行查找，此时查出的结果一定是唯一的，所以任意两个进程要通过命名管道进行通信就必须通过路径打开命名管道，也就是打开文件，此时二者就构成了访问同一份资源的通信条件

既然命名管道是一个文件，那么在磁盘上一定有其对应的`inode`编号与文件名映射，那么是否可以直接使用一个普通文件完成进程通信？实际上也是可以的，但是对于普通文件来说，其存在最大的问题就是会将文件中的内容刷新到磁盘上，而对于命名管道来说，之所以单独为他创建一个文件类型，就是因为他不进行内容刷新，完全是内存级别的文件，所以其在磁盘上的`inode`编号和文件名映射也只是占个位置

## 使用函数调用完成两个进程通信

创建命名管道的函数调用为`int mkfifo(const char *pathname, mode_t mode)`，其第一个参数传递路径名称，表示在哪个目录下创建命名管道（可以传递命名管道的名称），第二个参数传递命名管道的权限，其与文件权限一样。如果命名管道创建成功函数返回0，否则返回-1

前面已经介绍过使用命令如何创建命名管道，接下来主要介绍如何使用函数调用创建命名管道，基本上分为下面的步骤：

1. 第一个进程创建命名管道并打开管道进行使用
2. 第二个进程获取（打开）对应的命名管道并进行使用

所以此处需要用到两个可执行程序，首先创建对应的`Makefile`：

```makefile
SERVER=Server
CLINET=Client
SERVER_CC=Server.cc
CLINET_CC=Client.cc
CC=g++

.PHONY: all
all: $(SERVER) $(CLINET)

$(SERVER): $(SERVER_CC)
	$(CC) -o $(SERVER) $(SERVER).cc -std=c++11

$(CLINET): $(CLINET_CC)
	$(CC) -o $(CLINET) $(CLINET).cc -std=c++11

.PHONY: clean
clean:
	rm -f $(SERVER) $(CLINET)
```

在上面的`Makefile`中，为了同时生成出两个可执行程序，需要用到`all`，其依赖关系为两个可执行程序，但是因为这两个可执行程序还不存在，`Makefile`会向下执行直到`all`的依赖全部存在为止。另外，`Server`表示创建命名管道的一方，`Client`表示使用获取命名管道的一方，本次演示`Client`向命名管道中写入，`Server`从命名管道中读取

在匿名管道部分实现了简单的进程池，当时也处理了从面向过程转向面向对象，所以本次直接使用面向对象的思路进行设计

在下面的两个类的设计中，有些内容是共用的，所以放在单独的一个头文件中：

```c++
#ifndef __SHARED_HPP__
#define __SHARED_HPP__

#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

// 定义路径
// 在当前进程的CWD下创建命名管道fifo
const std::string pipe_path = "./fifo";
// 指定命名管道的权限
const mode_t pipe_mode = 0600;
// 缓冲区大小
const int buffer_size = 1024;

#endif
```

**设计`Server`类**

因为要创建命名管道，所以考虑在`Server`类对象创建时就创建命名管道：

```c++
class Server
{
public:
    Server()
    {
        // 创建命名管道
        int ret = mkfifo(pipe_path.c_str(), pipe_mode);
        if (ret < 0)
        {
            std::cout << "管道创建失败" << std::endl;
            return;
        }
    }

private:
};
```

接着，因为`Server`需要从命名管道中读取，所以可以考虑实现一个函数用于打开对应的命名管道文件，因为打开文件会返回对应的文件描述符，所以可以考虑添加一个成员`_fd`存储命名管道的文件描述符

```c++
// 打开管道文件
void openFifo()
{
    _fd = open(pipe_path.c_str(), pipe_mode);

    // 错误处理
    if (_fd < 0)
    {
        std::cout << "打开管道失败" << std::endl;
        return;
    }
}
```

在上面的代码中，`_fd`就是成员变量，用于存储管道的文件描述符

因为`Server`是读取数据，所以考虑在`Server`类中提供读取方法，该方法返回读取到的字节数，如果为0，说明读取到文件结尾，可能是写端关闭，否则就是正常读取到的数据，本次以读取字符串为例，为了保证外部可以直到读取到的字符串，需要调用方传递一个实参，此时函数的形参应该应该作为输出型参数，下面有常见的三种写法分别代表不同类型的参数：

1. `*`表示输出型参数
2. `const &`表示输入型参数
3. `&`表示输入输出型参数

```c++
// 从管道中读取数据
int readFromPipe(std::string *out)
{
    char buffer[buffer_size] = {0};
    int ret = read(_fd, buffer, buffer_size);
    if (ret > 0)
        *out = buffer; // 通过输出型参数带离函数

    return ret;
}
```

最后就是关闭管道，关闭管道只需要关闭对应的文件并删除命名管道文件即可，在代码中删除命名管道文件可以使用`unlink`系统调用：

```c++
int unlink(const char *pathname);
```

提供对应的函数如下：

```c++
// 关闭管道
void closePipe()
{
    if (_fd > 0)
        close(_fd);

    // 删除命名管道
    int ret = unlink(pipe_path.c_str());
    if (ret < 0)
    {
        std::cout << "删除命名管道失败" << std::endl;
        return;
    }
}
```

**设计`Client`类**

设计`Client`类的思路和`Server`类的思路非常类似，只需要将`Server`类中的「创建管道」改为「获取（打开）管道」，将「管道读取」改为「管道写入」，代码整体如下：

```c++
class Client
{
public:
    Client()
    {
        // 打开管道
        _fd = open(pipe_path.c_str(), O_WRONLY);
        if (_fd < 0)
        {
            std::cout << "管道打开失败" << std::endl;
            return;
        }
    }

    // 写入
    void writeToPipe()
    {
        const std::string str = "Hello Pipe";
        write(_fd, str.c_str(), str.size());
    }

    // 关闭管道
    void closePipe()
    {
        if (_fd > 0)
            close(_fd);
    }

private:
    int _fd;
};
```

至此，命名管道的用法就是上面的过程，上面两个类还可以对相同的代码进行简化，此处就不再赘述，下面是对应的主函数：

=== "`Server.cc`"

    ```c++
    #include <iostream>
    #include "Server.hpp"
    using namespace std;

    int main()
    {
        // 创建Server类对象
        Server sv;
        sv.openFifo();
        while (true)
        {
            string out;
            int ret = sv.readFromPipe(&out);
            if (ret > 0)
                std::cout << out << std::endl;
            else if (ret == 0) // 读到文件结尾，可能是写端关闭，结束读取
                break;
        }

        // 关闭管道
        sv.closePipe();

        return 0;
    }
    ```

=== "`Client.cc`"

    ```c++
    #include <iostream>
    #include "Client.hpp"
    using namespace std;

    int main()
    {
        // 创建Client类对象
        Client cl;
        while (true)
        {
            cl.writeToPipe();
            sleep(1);
        }

        return 0;
    }
    ```

运行结果如下：

<img src="2. 命名管道与共享内存.assets\Snipaste_2025-01-04_22-17-11.png">