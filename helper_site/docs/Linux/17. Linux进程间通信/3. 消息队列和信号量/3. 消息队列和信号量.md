# 消息队列与信号量

## 消息队列

遵循System V标准的进程通信除了共享内存外还有消息队列，消息队列从其字面意思就是传递消息的一个队列。实际上，其作用与队列也是非常像的，但是它并不是语言的中间件

消息队列与共享内存不同的是，消息队列可以同时让两个进程既可以从消息队列中读取数据，也可以向消息队列中写入数据，只不过进程读取数据时读取到的是另外一个进程写入的数据，而不是自己本身的数据，所以为了对消息队列中的数据作区分，除了数据本身外，还需要一个数据标识区分是哪一个进程写入的对应数据，示意图如下：

<img src="3. 消息队列和信号量.assets/image-20250112213333879.png" alt="image-20250112213333879" />

与共享内存类型，如果需要查看用户创建的消息队列，可以使用下面的指令：

```shell
ipcs -q
```

如果需要释放用户创建的消息队列，可以使用下面的指令：

```shell
ipcrm -m 消息队列唯一标识符
```

## 消息队列相关接口

与共享内存一样，消息队列也有自己的接口，但是其接口与共享内存非常相似，使用方式也非常类似，所以下面仅仅是对接口进行描述，具体使用方式参考[共享内存](https://www.help-doc.top/Linux/17.%20Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/2.%20%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/2.%20%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.html#_6)

**申请消息队列**

共享内存使用`shmget`，消息队列对应着就是`msgget`：

```c
int msgget(key_t key, int msgflg);
```

该接口第一个参数传递一个key，表示消息队列的编号，获取方式与共享内存一致，使用`ftok`根据项目路径和项目ID创建，第二个参数表示标记，同样有两种情况：

1. `IPC_CREAT`：如果单独使用`IPC_CREAT`，那么就代表如果指定的消息队列不存在就创建，否则就使用已有的消息队列
2. `IPC_EXCL`：单独使用无意义，但是一般配合`IPC_CREAT`可以实现当之地的消息队列不存在时就创建，否则就报错

同样，除了使用上面两个宏外，还需要使用文件权限，确保申请的消息队列可以使用

**使用消息队列**

进程想使用一个消息队列无非就是对消息队列进行读写操作，所以对应的接口如下：

使用`msgsnd`表示向一个消息队列中发送一个数据包：

```c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

该接口的第一个参数传递消息队列唯一标识符（同共享内存唯一标识符），第二个参数传入数据包，数据包的结构定义如下：

```c
struct msgbuf {
    long mtype;       /* message type, must be > 0 */
    char mtext[1];    /* message data */
};
```

在该结构中，第一个参数表示消息类型，第二个参数是一个[柔性数组](https://www.help-doc.top/C%E8%AF%AD%E8%A8%80/11.%20C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/11.%20C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html?h=%E6%9F%94%E6%80%A7#_7)，用于存储具体的数据

接口的第三个参数表示数据包的大小，第四个参数表示传递的标记，一般情况下不会使用到，所以传递0即可

在消息队列中，有写入就有读取，读取的接口为`msgrcv`：

```c
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

第一个参数表示消息队列唯一标识符，第二个为输出型参数，用于存储读取到的数据，第三个参数表示一次读取的数据大小，第四个参数表示读取哪一种数据（即哪一个进程写的数据），第五个参数依旧传递0

**释放消息队列**

在共享内存中使用`shmctl`，对应得在消息队列中使用`msgctl`：

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

接口的第一个参数传递消息队列唯一标识符，第二个参数表示操作标记，与共享内存一样，如果需要销毁消息队列，使用的标记为`IPC_RMID`，第三个参数表示用于存储消息队列相关信息的结构，不使用时传递`NULL`即可

## 信号量

在前面提到，当一个进程需要访问一个资源，并且这个资源在同一时刻只能被一个进程访问，那么就称这个资源为临界资源或者互斥资源，这个资源为了保证只能被一个进程访问就需要做出相应的保护操作，常见的保护操作有：互斥+同步，互斥就是「有你没我，有我没你」，同步就是保证进程访问资源具有顺序性，之所以要同步，是因为操作系统中的进程在运行时都是异步的，这也是操作系统有异步特性的原因之一

一个进程之所以会访问临界资源，是因为其代码中含有访问临界资源的代码，这段代码也被称为临界区，根据这个特点，进程代码也可以分为两部分：非临界区（没有访问临界资源的代码）+临界区（访问临界资源的代码），示意图如下：

<img src="3. 消息队列和信号量.assets\Snipaste_2025-01-12_22-21-12.png" style="zoom:50%">

前面提到的共享内存使用时是一个进程写入，一个进程读取，如果共享内存比较大，但是每次交互的数据比较小就会造成资源浪费，考虑将这个资源划分成多个小份资源，每个进程依次向指定的小块空间中写入，对应的每个进程依次从指定的小块空间中读取就可以做到更高效得利用共享内存（即不同进程在访问共享资源时可以具有一定的并发性），即下图所示：

<img src="3. 消息队列和信号量.assets\Snipaste_2025-01-12_22-26-56.png">

但是这样的操作有个问题，每一整个共享内存划分成小块空间一定会有个数限制，也就是说，共享内存中的小块空间个数是有限的，例如上图中小块共享内存的个数为24个，如果此时有25个进程访问这写小块空间，势必会出现至少两个进程资源竞争问题，所以此时就需要一个计数器来表示当前共享内存中的小块资源个数，根据这个资源个数实现有限个数个进程访问，多余进程等待的思路伪代码表示如下：

1. `if(count > 0){count--;} else {超出count的进程 wait;}`
2. `使用共享资源的一个进程 quit; count++`

