# Linux信号

## 信号介绍

在前面的[进程状态与进程优先级](https://www.help-doc.top/Linux/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.html?h=ct#runningsleeping)部分提到，如果想要终止一个进程可以使用++ctrl+c++，其本质就是进程收到一个终止的信号

所谓信号，就是一种用户、操作系统或者其他进程向目标进程发送异步事件的一种方式，而其中的异步事件表示不会立即处理的事件，因为进程收到信号之前一直在执行其代码，收到信号的那一刻之前进程并不知道自己会收到信号，当进程收到信号时，就需要做出对应的操作，此时进程可能并不是立即去完成对应的操作

知道了何为信号，接下来就需要了解产生信号的方式

## 信号产生与信号捕捉

在Linux中，产生信号的方式可以有下面五种：

1. 键盘产生，通过触发指定按键发出对应的信号
2. 系统指令，通过系统指令向进程发出信号
3. 系统调用，通过系统调用向进程发送特定的信号
4. 软件条件，当某种软件条件被触发时，进程就会收到对应的信号
5. 程序异常，当程序出现异常时，进程会收到对应的信号

为了验证上面的五种方式，需要先了解一个接口`signal`，该接口可以将信号的默认行为指定为用户自定义的行为，这个动作也被称为信号捕捉：

```c
sighandler_t signal(int signum, sighandler_t handler);
```

该接口的第一个参数表示信号编号，可以通过`kill -l`指令查看，其中前31个信号是用户可以指定的信号，如下图所示：

<img src="18. Linux信号.assets/image-20250117174042205.png" alt="image-20250117174042205" />

第二个参数表示自定义的行为，其中`sighandler_t`是一个函数指针，定义如下：

```c
// 返回值为void，参数为int
typedef void (*sighandler_t)(int);
```

该接口如果存在自定义的行为函数，就会返回该函数，否则返回`SIG_DFL`（表示信号默认行为）或者`SIG_IGN`（表示信号忽略行为）

其中，`SIG_DFL`和`SIG_IGN`为预定的宏，分别为0和1：

```c
#define	SIG_DFL	 ((__sighandler_t)  0)	/* Default action.  */
#define	SIG_IGN	 ((__sighandler_t)  1)	/* Ignore signal.  */
```

其中的`__sighandler_t`就是`sighandler_t`类型：

```c
typedef void (*__sighandler_t) (int);
```

### 键盘产生

接下来以下面的代码进行演示：

```c++
#include <iostream>
#include <unistd.h>

int main()
{
    while (true)
    {
        std::cout << "Hello, World!" << std::endl;
        sleep(1);
    }

    return 0;
}
```

如果程序正常运行时会不断打印，但是如果按下键盘的++ctrl+c++就会终止进程，实际上这个过程中是进程收到了2号信号，为了验证就可以将2号信号的默认行为改为自定义行为，自定义行为的函数如下：

```c++
void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}
```

上面的函数中，参数表示收到的信号编号

在主程序中使用`siganl`将默认行为修改为自定义行为：

```c++
// ...
#include <signal.h>

int main()
{
    // 将信号2的默认行为修改为自定义行为
    signal(2, handler);
    // ...
}
```

需要注意，`signal`接口不要放在循环里，因为这个接口只需要在一开始将2号信号的默认行为修改为自定义行为即可，只要修改过就会生效，也就是说，**一切信号的行为在信号产生前就需要准备好**

此时再运行程序并按下++ctrl+c++就会看到对应的「2号信号的默认行为被修改为自定义行为」语句被打印，如下图所示：

<img src="18. Linux信号.assets\Snipaste_2025-01-17_18-02-58.png">

由于更改了2号信号的默认行为，所以此时就无法使用++ctrl+c++终止进程，但是可以使用++ctrl+backslash++终止

上面的过程就演示了如何使用键盘向一个进程发送信号，但是实际上，并不是键盘直接向进程发送信号，而是键盘触发事件被操作系统捕捉，再有操作系统识别到对应按键对应的事件转换为信号发送给对应的进程

所以现在的问题就转化为：操作系统为什么知道键盘触发了事件，操作系统不会一直等待键盘触发事件，而是由CPU的控制器收到了键盘的数据并触发了中断，再通知操作系统需要从键盘上读取对应的数据，通过这个操作就可以做到硬件和操作系统并行执行，操作系统也不需要一直等待某一个硬件，其中此处提到的中断就是硬件中断，其是计算机体系结构中的一个重要概念，它允许外部设备或内部硬件组件在CPU执行程序的过程中插入一个信号，请求CPU暂停当前任务并转向处理特定的事件

对比硬件中断和信号可以发现，信号本质也可以算是一种中断，只不过信号是在软件层面上模拟硬件中断，二者的共同点都是通过指定的方式告诉某一方可以进行某行为

从上面的过程中，了解了进程收到信号执行对应的行为，其中的默认行为可以通过`signal`接口进行修改，但是如何知道一个信号的默认行为，对于这个问题，可以使用下面的指令查看信号的默认行为以及事件：

```shell
man 7 signal
```

在终端中输入上面的指令即可看到下面这张表：

<img src="18. Linux信号.assets\screenshot-20250117-181757.png">

其中2号信号对应的字段是`SIGINT`，对应的事件就是`Interrupt from keyboard`，表示键盘中断。同样，++ctrl+backslash++表示3号信号，对应的字段为`SIGQUIT`，事件就是`Quit from keyboard`，表示键盘退出

### 系统指令

在Linux中，如果想向一个进程发送信号，可以使用`kill`指令，实际上在前面[Linux进程基础](https://www.help-doc.top/Linux/7.%20Linux%E8%BF%9B%E7%A8%8B/7.%20Linux%E8%BF%9B%E7%A8%8B.html#_2)部分已经提到过该指令，其中`-9`就表示信号编号为9号，对应的行为查表就是`SIGKILL`，对应的事件就是`Kill signal`

需要注意的是，9号信号的默认行为是无法被自定义行为给替换的，也就是说，无法使用`signal`接口将9号信号的默认行为替换为自定义行为：

```c++
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}

int main()
{
    // 将信号9的默认行为修改为自定义行为
    signal(9, handler);

    while (true)
    {
        std::cout << "Hello, World!" << std::endl;
        sleep(1);
    }

    return 0;
}
```

运行上面的程序，并向对应的进程发送9号信号可以看到并没有打印自定义行为中的语句，并且进程被终止：

<img src="18. Linux信号.assets/image-20250117183403208.png">

### 系统调用

在Linux中，如果想通过代码的方式向进程发送信号就可以通过发送信号相关的系统调用，下面是常见的系统调用接口用于向进程发送信号：

1. `kill`：`int kill(pid_t pid, int sig);`，该接口作用是向指定的进程发送指定的信号，其中第一个参数就是进程的`pid`，通过`getpid`接口获取，第二个参数表示信号编号。如果发送成功，接口返回0，否则返回-1
2. `raise`：`int raise(int sig);`，该接口作用是向当前调用该接口的进程发送指定的信号，其中的参数表示信号编号。如果发送成功，接口返回0，否则返回非0
3. `abort`：`void abort(void);`，该接口作用是终止当前调用该接口的进程，这个接口比较固定，因为他固定了是当前进程并且固定了信号是`SIGABRT`，即6号信号
4. `alarm`：`unsigned int alarm(unsigned int seconds);`，该接口作用是创建一个定时器，当定时器设定的时间截止时，会向当前进程发送固定信号`SIGALRM`，其中的参数表示定时器的秒数。该接口的返回值表示定时器剩余秒数，如果定时器的时间自动截止时，则该接口返回0，否则返回剩余秒数
5. `pause`：`int pause(void)`，该接口作用是让进程睡眠直到被某个信号唤醒

!!! note

    关于上述接口参数列表存在`void`，见[C语言基础知识](https://www.help-doc.top/C%E8%AF%AD%E8%A8%80/1.%20C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.%20C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html#main)

下面是上面提到的接口的基本使用：

对于`kill`来说，可以设计需求：当进程中的计数器加到5时，向当前进程发送2号信号，并且2号信号的默认行为修改为自定义行为，当计数器加到10时，向当前进程发送3号信号结束进程，代码如下：

```c++
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}

int main()
{
    signal(2, handler);

    int count = 0;

    while (true)
    {
        // 当count为5时，向当前进程发送2号信号
        if (count == 5)
            kill(getpid(), 2);

        // 当count为10时，向当前进程发送3号信号
        if (count == 10)
            kill(getpid(), 3);

        std::cout << "Hello, World!" << std::endl;

        count++;
        sleep(1);
    }

    return 0;
}
```

运行结果如下：

<img src="18. Linux信号.assets\Snipaste_2025-01-18_17-34-25.png">

因为`raise`接口的作用是向当前进程发送指定的信号，所以其作用等同于`kill(getpid(), signal)`，所以上面的代码中`kill`的部分可以分别替换为：

```c++
if (count == 5)
    raise(2);

if (count == 10)
    raise(3);
```

6号信号的作用比较固定，对于`SIGABRT`信号的效果实际上类似于`exit`，但是`abort`接口更确切得说是非正常终止进程，也就是说进程退出码不为0，例如下面的的代码：

```c
#include <iostream>
#include <unistd.h>
#include <signal.h>

int main()
{
    abort();

    return 0;
}
```

运行该程序，程序结束时查看其退出码如下图：

<img src="18. Linux信号.assets\Snipaste_2025-01-18_17-42-24.png">

最后是关于`alarm`接口，因为`alarm`表示设计定时器，所以可以设计需求：设计一个5秒的定时器，当定时器时间到时触发对应的自定义行为

```c++
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}

int main()
{
    signal(SIGALRM, handler);

    alarm(5);

    int count = 0;
    while (true)
    {
        if (count == 10)
            kill(getpid(), 9);
        std::cout << "Hello, World!" << std::endl;

        count++;
        sleep(1);
    }

    return 0;
```

运行上面的程序即可看到下面的结果：

<img src="18. Linux信号.assets\Snipaste_2025-01-18_17-57-04.png">

实际上操作系统就是一个定时器，如果某一个定时器设定的时间截止时，就触发对应的任务，此处可以用`alarm`进行模拟：

设定一个1秒的定时器，执行下面的三种任务

1. 内核刷新
2. 进程根据时间片切换
3. 清理操作系统内部的内存碎片

每一种任务执行完后因为定时器会被清理，所以需要重新设置定时器，示例代码如下：

```c
#include <iostream>
#include <unistd.h>
#include <vector> // 记录任务
#include <functional>
#include <signal.h>

using task = std::function<void()>;

std::vector<task> tasks{
    []()
    { std::cout << "内核刷新任务" << std::endl; },
    []()
    { std::cout << "进程根据时间片切换" << std::endl; },
    []()
    { std::cout << "清理操作系统内部的内存碎片" << std::endl; },
};

void handler(int signal)
{
    for (auto &t : tasks)
        t();

    // 重新设置定时器
    alarm(1);
}

int main()
{
    // 1秒定时器
    alarm(1);

    signal(SIGALRM, handler);

    while (true)
    {
        // 当有信号唤醒时才执行任务
        pause();
        std::cout << "任务执行完成" << std::endl;
    }

    return 0;
}
```

运行结果如下：

<img src="18. Linux信号.assets\Snipaste_2025-01-18_18-17-17.png">

### 软件条件

所谓软件条件触发信号，就是当某个软件条件满足时，就向进程发送对应的信号，例如上面系统调用中的`alarm`接口利用的就是软件条件，当定时器设定的时间截止时满足软件条件，此时向进程发送对应的`SIGALRM`信号

因为操作系统底层不止一个定时器，所以操作系统本身也需要对创建的定时器进行管理，如果直接使用链表，那么就会出现每一次都需要遍历一遍定时器链表找出截止的定时器节点执行其中的操作，再对其进行销毁，此时的时间复杂度就会比较高，所以操作系统会考虑使用更优秀的方法来完成这个动作，例如可以考虑使用小堆结构，注意操作系统底层并不一定使用堆

因为软件条件无法一一列举，所以此处只是介绍进程收到的信号来源可能是软件条件

### 异常

异常是比较常见的进程收到信号的方式，例如除0异常、野指针异常等，在Linux中，除0时进程会收到`SIGFPE`信号从而终止进程，野指针时进程会收到`SIGSEGV`信号从而终止进程，对于这两种异常，下面主要考虑为什么进程会收到这两种异常对应的信号

前面提到，进程收到的信号都是由操作系统发送的，但是操作系统为什么知道哪一个进程出现了何种异常

首先是除0异常，对应的代码如下：

```c
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "除0异常" << std::endl;
}

int main()
{
    // 将除0异常的默认行为修改为自定义行为
    signal(SIGFPE, handler);
    // 除0异常
    int a = 1;
    a /= 0;

    return 0;
}
```

注意上面的代码没有任何退出进程的接口，例如`exit`接口，运行上面的代码就会发现：终端一直循环打印「除0异常」，根据这个现象，下面的问题就是：

1. 操作系统如何知道当前进程出现了除0异常
2. 为什么程序一直循环打印「除0异常」

对于第一个问题，直观的理解可能认为是操作系统一直在监测当前进程的运行，一旦进程出现异常就向进程发送信号，但是这个理解并不准确，因为如果操作系统管理的进程非常多时，就需要监测非常多的进程，此时操作系统的负载就非常高，另外操作系统除了要监测进程，还需要处理其他的业务逻辑，所以这个理解并不实际。实际上，操作系统并不需要监测任何一个进程，只需要执行当前进程的CPU告诉操作系统，操作系统收到CPU的反馈后就向该进程发送信号即可

对于除0异常来说，在进程的代码被CPU执行时，会有对应的状态寄存器Eflags，其中存在溢出标记位，如果进行了除0，那么此时这个标记位就会由0变为1，当前CPU监测到这一位变为1后，就会出现硬件错误从而提醒操作系统需要将这个进程从运行队列中移除，此时操作系统就会给对应的进程发送信号，这就是为什么「操作系统如何知道当前进程出现了除0异常」

对于第二个问题，因为进程离开运行队列时，只要`task_struct`结构体没有被销毁，那么其中一定就存在着上下文数据，同时也包括Eflags为1的标记，而在上面的代码中将`SIGFPE`信号的默认行为修改为自定义行为，所以上面程序对应的进程并不会被终止，而是回到了等待队列，当进程再次进入就绪队列时就会回到上一次执行的位置，但是因为上一次在计算`a/=0`时出错，所以这行代码并没有执行完毕，再次调度又会执行这一行导致再次出现除0异常，如此往复就会一直循环打印「除0异常」

接着是野指针异常，对应的代码如下：

```c
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "野指针异常" << std::endl;
}

int main()
{
    // 将野指针异常的默认行为修改为自定义行为
    signal(SIGSEGV, handler);

    int *ptr = nullptr;
    *ptr = 10;

    return 0;
}
```

注意上面的代码没有任何退出进程的接口，例如`exit`接口，运行上面的代码就会发现：终端一直循环打印「野指针异常」，根据这个现象，下面的问题就是：

1. 操作系统如何知道当前进程出现了除0异常
2. 为什么程序一直循环打印「野指针异常」

对于第一个问题，与上面除0异常非常类似，只是CPU并不是通过Eflags标记错误，而是MMU无法在对应页表中查找到有效的物理地址从而引发错误通知操作系统，后面的过程与除0异常一致。对于第二个问题和除0异常一致

## 核心转储

在使用`man 7 signal`查看信号表格时，有一列`Action`，表示信号触发时对应的行为，其中的值有：`Core`、`Term`、`Ign`、`Stop`和`Cont`。对于`Core`和`Term`来说，二者表面上都是结束当前进程，而`Ign`表示进程做出的行为是忽略

本次主要考虑`Core`和`Term`，二者更细致的区别如下：

- `Term`表示正常退出进程，并且不需要进行debug
- `Core`表示核心转储，即当进程退出时，会在进程代码所在的目录下生成一个`core.pid`或者`core`文件，当进程崩溃时，这个文件中会保存在内存中的部分信息，以便后续debug

!!! info "关于`core.pid`或者`core`文件"

    不论是`core.pid`或者`core`文件，二者作用和内容都是一样的，只是文件名不同，在较老内核的操作系统一般使用`core.pid`，较新的操作系统是直接使用`core`，二者的区别就是一个带进程`pid`，一个不带，本质原因就是因为进程`pid`每一次运行都有可能不一样，导致可能多次出错就多次创建这个文件，最后可能这个文件的占用会非常高，所以后续就使用`core`代替，这样就可以做到每次都是覆盖写。但是当代Linux操作系统为了保证系统性能和稳定，一般会关闭核心转储功能

如果想查看当前操作系统是否开启核心转储这个功能，可以使用下面的指令：

```shell
ulimit -a
```

查看`core file size`是否为0，如果为0表示当前操作系统已经关闭当前功能，否则就是表示核心转储文件的大小，如果想要打开这个功能，可以使用下面的命令：

```shell
ulimit -c 文件大小
```

一旦存在核心转储文件，在使用`GDB`调试时就可以使用`core-file 核心转储文件名`快速跳到出现错误的代码

如果子进程出现异常，为了保证可以看到异常位置，在进程的退出信息中的第8位比特位存在一个core dump标志，只要父进程查看这个标记位为1，就说明子进程出现了异常

## 信号保存

前面介绍了进程在收到一个信号时会如何进行处理，但是一个进程收到对应的信号并不会立即做出处理，而是在合适的时机才会去处理，此时就涉及到进程需要保存收到的信号。在信号部分涉及到下面的概念：

1. 信号递达：表示信号的实际处理动作被执行
2. 信号未决：表示信号从产生到信号递达之间的状态
3. 信号阻塞：一个信号处于阻塞时，该信号就会在产生时一直处于未决状态，直到进程解除对指定信号的阻塞才会进行递达动作

在Linux中，一个进程可以选择阻塞某个信号，但是阻塞并不等同于`SIG_IGN`的忽略行为，忽略本质也是信号递达的动作，而阻塞是未递达

一个进程保存自己的数据就是在其对应的`task_struct`中，所以一个进程想保存对应的信号也是在`task_struct`中保存，在其中，有下面的三种结构：

1. 信号`block`表：表示信号阻塞位图
2. 信号`pending`表：表示信号未决位图
3. 信号`handler`数组：表示信号行为数组

注意，前两个都是位图，而只有最后一个是数组，因为信号的有无可以用两种状态：有或者无，所以只需要用二进制的0和1表示即可，所以一个信号是否被阻塞与一个信号是否未决就都可以使用位图

在信号`block`表中，位图的每一位的位置就代表信号的编号，从右向左（不包含最左侧高位）的第一位即为编号为1的信号，在信号`pending`表中也是如此

在Linux内核中，这三张表对应的结构如下：

```c
struct task_struct {
    // ...
	struct sighand_struct *sighand; // handler表

	sigset_t blocked, real_blocked; // block表
	struct sigpending pending; // pending表

    // ...
};

// handler表类型
struct sighand_struct {
	atomic_t		count;
	struct k_sigaction	action[_NSIG];
	spinlock_t		siglock;
};

// pending表类型
struct sigpending {
	struct list_head list;
	sigset_t signal;
};

其中 sigset_t 类型为 unsigned long 类型
```

在内核代码中，`sigset_t`类型的变量称为信号集（注意不是信号量集），对应的阻塞信号集也称为当前进程的信号屏蔽字

根据对应的结构，操作系统也提供了相应的操作接口：

1. `sigprocmask`：用于操作`block`表
2. `sigpending`：用于检测`pending`表
3. `signal`：用于操作`handler`表

除了上面的操作三个表的方式外，还有用于读取和修改前两个位图表中内容的接口：

1. `sigemptyset`：用于将指定表全设置为0
2. `sigfillset`：用于将指定表全设置为1
3. `sigaddset`：用于将指定表的某一个信号对应的标记设为1
4. `sigdelset`：用于将指定表的某一个信号对应的标记设为0
5. `sigismember`：判断某一个信号是否在指定表中为1

下面是所有接口的详细介绍：

**`sigprocmask`**

```c
int sigprocmask(int how, const sigset_t *set, sigset_t * oldset);
```

其中的三个参数分别表示如下：

1. 第一个参数表示操作标记：有三种选择：

    1. `SIG_BLOCK`：相当于`mask = mask | set`，表示将新的`set`与原始的`mask`进行或操作，即添加阻塞标记位
    2. `SIG_UNBLOCK`：相当于`mask = mask & (~set)`，表示根据新的`set`和原始的`mask`进行取反相与，做到解除阻塞标记位
    3. `SIG_SETMASK`：相当于`mask = set`，直接赋值表示将新的`set`覆盖原始的`mask`

2. 第二个参数表示新的`set`表，其为输入型参数
3. 第三个参数表示旧的`set`表，其为输出型参数，当函数用新的`set`表替换旧的`set`表时，会将旧的`set`表存储到该变量中

**`sigpending`**

```c
int sigpending(sigset_t *set);
```

用于查看`pending`表，接口的参数为输出型参数，该接口会将指定的表存储到参数变量中

=== "`sigemptyset`"

    ```c
    int sigemptyset(sigset_t *set);
    ```

=== "`sigfillset`"

    ```c
    int sigfillset(sigset_t *set);
    ```

=== "`sigaddset`"

    ```c
    int sigaddset(sigset_t *set, int signum);
    ```

=== "`sigdelset`"

    ```c
    int sigdelset(sigset_t *set, int signum);
    ```

=== "`sigismember`"

    ```c
    int sigismember(const sigset_t *set, int signum);
    ```

上面的接口中，除了最后一个接口在指定信号存在于指定表中会返回1，不存在返回0，失败返回-1，其他均是成功返回1，失败返回-1

根据上面的接口介绍，可以设计需求：屏蔽2号信号，获取`pending`表并打印该表的内容，接着发送2号信号查看打印结果，一段时间过后取消屏蔽再查看打印结果：

```c
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int sig)
{
    std::cout << "Catch signal " << sig << std::endl;
}

int main()
{
    // 将2号信号的默认行为修改
    signal(SIGINT, handler);

    // 先屏蔽2号信号
    sigset_t set, oldSet;
    sigemptyset(&set);
    sigemptyset(&oldSet);

    sigaddset(&set, 2);

    // 为了只看到2号为1，直接覆盖
    sigprocmask(SIG_SETMASK, &set, &oldSet);

    int count = 0;

    while (true)
    {
        // 打印pending表
        sigset_t pending;

        sigpending(&pending);

        // 逆向打印31位
        for (int i = 31; i >= 1; i--)
        {
            // 判断信号是否存在于pending表中，存在打印1，否则打印0
            if (sigismember(&pending, i))
                std::cout << 1;
            else
                std::cout << 0;
        }

        std::cout << std::endl;

        sleep(1);

        count++;

        // 发送2号信号
        if (count == 5)
            raise(2);

        // 恢复2号信号
        if (count == 10)
        {
            std::cout << "恢复2号信号" << std::endl;
            // 将原来的旧表作为新表恢复
            sigprocmask(SIG_SETMASK, &oldSet, NULL);
        }

        // 发送3号信号退出进程
        if (count == 15)
            raise(3);
    }

    return 0;
}
```

对应的运行结果如下：

<img src="18. Linux信号.assets\Snipaste_2025-01-18_22-56-31.png">

因为信号本质是会被操作系统进行保存，所谓的操作系统发送信号实际上就是更改`pending`表中对应位为1，所以操作系统发送信号本质是写入信号