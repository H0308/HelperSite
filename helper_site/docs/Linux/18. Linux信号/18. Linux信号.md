# Linux信号

## 信号介绍

在前面的[进程状态与进程优先级](https://www.help-doc.top/Linux/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.html?h=ct#runningsleeping)部分提到，如果想要终止一个进程可以使用++ctrl+c++，其本质就是进程收到一个终止的信号

所谓信号，就是一种用户、操作系统或者其他进程向目标进程发送异步事件的一种方式，而其中的异步事件表示不会立即处理的事件，因为进程收到信号之前一直在执行其代码，收到信号的那一刻之前进程并不知道自己会收到信号，当进程收到信号时，就需要做出对应的操作，此时进程可能并不是立即去完成对应的操作

知道了何为信号，接下来就需要了解产生信号的方式

## 信号产生与信号捕捉

在Linux中，产生信号的方式可以有下面五种：

1. 键盘产生，通过触发指定按键发出对应的信号
2. 系统指令，通过系统指令向进程发出信号
3. 系统调用，通过系统调用向进程发送特定的信号
4. 软件条件，当某种软件条件被触发时，进程就会收到对应的信号
5. 程序异常，当程序出现异常时，进程会收到对应的信号

为了验证上面的五种方式，需要先了解一个接口`signal`，该接口可以将信号的默认行为指定为用户自定义的行为：

```c
sighandler_t signal(int signum, sighandler_t handler);
```

该接口的第一个参数表示信号编号，可以通过`kill -l`指令查看，其中前31个信号是用户可以指定的信号，如下图所示：

<img src="18. Linux信号.assets/image-20250117174042205.png" alt="image-20250117174042205" />

第二个参数表示自定义的行为，其中`sighandler_t`是一个函数指针，定义如下：

```c
// 返回值为void，参数为int
typedef void (*sighandler_t)(int);
```

### 键盘产生

接下来以下面的代码进行演示：

```c++
#include <iostream>
#include <unistd.h>

int main()
{
    while (true)
    {
        std::cout << "Hello, World!" << std::endl;
        sleep(1);
    }

    return 0;
}
```

如果程序正常运行时会不断打印，但是如果按下键盘的++ctrl+c++就会终止进程，实际上这个过程中是进程收到了2号信号，为了验证就可以将2号信号的默认行为改为自定义行为，自定义行为的函数如下：

```c++
void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}
```

上面的函数中，参数表示收到的信号编号

在主程序中使用`siganl`将默认行为修改为自定义行为：

```c++
// ...
#include <signal.h>

int main()
{
    // 将信号2的默认行为修改为自定义行为
    signal(2, handler);
    // ...
}
```

此时再运行程序并按下++ctrl+c++就会看到对应的「2号信号的默认行为被修改为自定义行为」语句被打印，如下图所示：

<img src="18. Linux信号.assets\Snipaste_2025-01-17_18-02-58.png">

由于更改了2号信号的默认行为，所以此时就无法使用++ctrl+c++终止进程，但是可以使用++ctrl+\++终止

上面的过程就演示了如何使用键盘向一个进程发送信号，但是实际上，并不是键盘直接向进程发送信号，而是键盘触发事件被操作系统捕捉，再有操作系统识别到对应按键对应的事件转换为信号发送给对应的进程

所以现在的问题就转化为：操作系统为什么知道键盘触发了事件，操作系统不会一直等待键盘触发事件，而是由CPU的控制器收到了键盘的数据并触发了中断，再通知操作系统需要从键盘上读取对应的数据，通过这个操作就可以做到硬件和操作系统并行执行，操作系统也不需要一直等待某一个硬件，其中此处提到的中断就是硬件中断，其是计算机体系结构中的一个重要概念，它允许外部设备或内部硬件组件在CPU执行程序的过程中插入一个信号，请求CPU暂停当前任务并转向处理特定的事件

对比硬件中断和信号可以发现，信号本质也可以算是一种中断，只不过信号是在软件层面上模拟硬件中断，二者的共同点都是通过指定的方式告诉某一方可以进行某行为

从上面的过程中，了解了进程收到信号执行对应的行为，其中的默认行为可以通过`signal`接口进行修改，但是如何知道一个信号的默认行为，对于这个问题，可以使用下面的指令查看信号的默认行为以及事件：

```shell
man 7 signal
```

在终端中输入上面的指令即可看到下面这张表：

<img src="18. Linux信号.assets\screenshot-20250117-181757.png">

其中2号信号对应的字段是`SIGINT`，对应的事件就是`Interrupt from keyboard`，表示键盘中断。同样，++ctrl+\++表示3号信号，对应的字段为`SIGQUIT`，事件就是`Quit from keyboard`，表示键盘退出

### 系统指令

在Linux中，如果想向一个进程发送信号，可以使用`kill`指令，实际上在前面[Linux进程基础](https://www.help-doc.top/Linux/7.%20Linux%E8%BF%9B%E7%A8%8B/7.%20Linux%E8%BF%9B%E7%A8%8B.html#_2)部分已经提到过该指令，其中`-9`就表示信号编号为9号，对应的行为查表就是`SIGKILL`，对应的事件就是`Kill signal`

需要注意的是，9号信号的默认行为是无法被自定义行为给替换的，也就是说，无法使用`signal`接口将9号信号的默认行为替换为自定义行为：

```c++
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signal)
{
    std::cout << "Signal: " << signal << "号信号的默认行为被修改为自定义行为" << std::endl;
}

int main()
{
    // 将信号9的默认行为修改为自定义行为
    signal(9, handler);

    while (true)
    {
        std::cout << "Hello, World!" << std::endl;
        sleep(1);
    }

    return 0;
}
```

运行上面的程序，并向对应的进程发送9号信号可以看到并没有打印自定义行为中的语句，并且进程被终止：

<img src="18. Linux信号.assets/image-20250117183403208.png">

### 系统调用

