# Linux线程概念与线程操作

## 线程概念

前面提到[进程=程序代码和数据+进程结构体](https://www.help-doc.top/Linux/7.%20Linux%E8%BF%9B%E7%A8%8B/7.%20Linux%E8%BF%9B%E7%A8%8B.html#_1)，在线程部分就需要进一步更新之前的认识

进程实际上承担分配系统资源的基本实体，而线程是进程中的一个执行分支，是操作系统调度的基本单位

!!! note

    此处需要注意，操作系统并不是直接调用进程，而是调用线程，所以进程并不是操作系统调度的基本单位

### Linux线程的设计

要想更清楚地理解进程就必须深入到一个操作系统中学习，在Linux中，实际上并没有所谓的线程，因为如果存在线程，那么操作系统必定要对线程进行管理，对应的线程也就需要属于自己的结构和调度方案，但是因为线程本质是进程中的一个执行分支（即执行某一段代码，并且这段代码是通过特殊的方式执行的），其中的相关内容与进程非常类似，所以可以不需要额外单独创建一个结构来表示线程，只需要复用进程的PCB结构即可，这样一来，线程所能看到的就是一个进程所有的内容，包括进程的虚拟地址空间、打开的各种文件、各种数据等

这种线程在Linux下统一称为轻量级线程（LWP），之所以轻量，就是因为线程不需要携带各种资源，只需要执行对应的代码得到对应的结构即可

进程和线程的关系如下图所示：

<img src="1. Linux线程概念与线程操作.assets/image-20250131143735073.png">

在前面的部分提及到的进程调度，实际上更准确来说是线程调度，只不过其中只有一个线程（即主线程），而从线程部分开始，一个进程内就可以有多个线程，所有线程共享一个进程的资源

对于用于CPU调度来说，其看到的只有每一个线程的`task_struct`，但是进程中可能不止有一个`task_struct`，所以CPU所能看到的`task_struct`个数一定是小于等于进程内部总共`task_struct`的个数

### 理解页表与虚拟地址到物理地址转换

前面提到线程本质是一个执行流，执行属于自己的代码，但是一个进程内部所有的线程都共用一个虚拟地址空间，此时就需要考虑如何做到不同的线程看到不同的资源

首先了解Linux中的内存管理，在Linux中，操作系统为了更好得将内存和硬盘进行交互，除了从磁盘上读取数据时按照4kb大小读取外，在内存中，写入/读取数据也是按照4kb进行的，而在内存中，这4kb也被称为页框，有了这样的管理方式，就可以尽可能减少内存的碎片，尽管已经可能存在碎片，但是这个碎片只会出现在多个页框内

同样，每一个页框也有自己的属性，操作系统也需要管理所有的页框，即需要对应的结构，对应的结构源码如下：

```c
struct page 
{
	unsigned long flags;		/* atomic flags, some possibly
					   updated asynchronously */
	atomic_t count;			/* Usage count, see below. */
	struct list_head list;		/* ->mapping has some page lists. */
	struct address_space *mapping;	/* The inode (or ...) we belong to. */
	unsigned long index;		/* Our offset within mapping. */
	struct list_head lru;		/* Pageout list, eg. active_list;
					   protected by zone->lru_lock !! */
	union {
		struct pte_chain *chain;/* Reverse pte mapping pointer.
					 * protected by PG_chainlock */
		pte_addr_t direct;
	} pte;
	unsigned long private;		/* mapping-private opaque data */

#if defined(WANT_PAGE_VIRTUAL)
	void *virtual;			/* Kernel virtual address (NULL if
					   not kmapped, ie. highmem) */
#endif /* WANT_PAGE_VIRTUAL */
};
```

接着，操作系统可以考虑使用一个数组对所有的页框进行管理，其中的元素都是`struct page*`，之所以用数组，原因之一是因为数组可以使用下标进行访问，而在C语言的世界里，下标和对应的地址（即起始地址+偏移量）可以相互转换，有了这一点，一旦在页表中通过虚拟地址找到了对应的物理地址，就可以在对应的页框数组中通过下标找到指向指定物理地址对应页框的指针从而访问到对应的属性

也就是说当获取到一个物理地址，那么通过该地址`/`4kb即可获取到改地址所在页框的起始地址值，通过该地址值根据C语言数组名即为数组的起始地址的特点就可以获取到偏移量计算出下标，进而获取到指定的元素，对应的地址`/`4kb也可以转化为地址`/`$2^{12}byte$

理解了上面的内存管理方式后，接下来就可以深入理解页表是如何进行虚拟地址到物理地址转换的。因为内存是按照4kb进行读写操作的，所以虚拟地址同样也是按照4kb进行，此时的4kb被称为页，在前面[Linux进程地址空间](https://www.help-doc.top/Linux/11.%20Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/11.%20%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.html?h=%E9%A1%B5%E8%A1%A8#_7)提到，页表中主要的字段有：虚拟地址、物理地址、读写权限和是否存在标记，但是实际上页表中可以并不需要虚拟地址字段，因为虚拟地址是从0开始计算的，一直到最大值，所以可以考虑直接将当前的虚拟地址和虚拟地址空间起始地址之间的偏移量作为索引去对应映射的物理地址即可，这样的做法可以在一定程度上减少页表在物理内存中的占用，但是尽管如此，如果页表中仅有物理地址，在32位系统下，每一个物理地址在每一个页表项中占4个字节（32位比特位），而一个虚拟地址空间就有$2^{32}$个地址，所以一共需要$2^{32}\times 4 byte = 2^{34} = 16GB$，可以看到单单一个页表就需要占用16GB，远超一个物理内存本身的大小，所以页表不可能直接是上面的形式

在Linux中，页表实际上是一个多级页表，类似于[Linux文件系统](https://www.help-doc.top/Linux/15.%20Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/15.%20Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html#inode)部分提到的数据块指针，示意图如下：

<img src="1. Linux线程概念与线程操作.assets\Snipaste_2025-01-31_17-01-59.png">

在32为系统下，其中，一级页表称为页目录，一共有1024（$2^{10}$）项，每一项称为页目录表项，二级页表（或简称页表）每一个页表也有1024项，每一项称为页表项，页目录中每一项中存储的都是对应二级页表的起始地址，所以总共$1024\times1024\times4=4MB$大小，此时当通过虚拟地址定位物理地址时，就直接通过32位地址依次查询，具体步骤如下：

1. 前10位（作为下标）定位页目录中指定项，此时就可以找到指定的页表
2. 中间10位（作为下标）定位页表中指定项，此时就可以找到虚拟地址对应的物理页框起始地址
3. 最后12位（作为偏移量）定位页框中具体的某一个字节的地址，此时就可以通过页框起始地址+偏移量找到指定字节的地址

整体的示意图如下：

<img src="1. Linux线程概念与线程操作.assets\download.png">

一旦找到一个字节，如果想通过这个字节作为起始值找不同类型的值，就可以通过类型的字节占用获取到完整的值，这就是为什么编译型语言层面需要有变量类型的原因。而之所以知道对应的页框是否被使用只需要通过前20位获取到对应的页框物理地址转换为下标访问对应页框的属性即可

对应的源码如下：

```c
typedef struct { unsigned long pte; } pte_t; // 页表目录
typedef struct { unsigned long pgd; } pgd_t; // 二级页表
```

最后，在操作系统中，存在一个指针`struct task_struct* current`，在前面[Linux进程状态与进程优先级](https://www.help-doc.top/Linux/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/8.%20Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.html?h=current#_6)部分提到这个指针指向的就是当前正在被调度的进程，具体来说就是进程中对应的线程，当CPU调度时，就会有对应的寄存器存储当前`current`指针中的内容，所以CPU一直都知道当前正在被调度的进程，而在前面提到过MMU寄存器负责将CPU读取到的虚拟地址进行查表找到对应的物理地址，而要找到页表就需要通过CR3寄存器，所以整个过程如下图所示：

<img src="1. Linux线程概念与线程操作.assets\screenshot-20250131-183242.png">

在CPU发展的过程中，查表行为一直都是一个非常高频的行为，所以其效率也是值得关注的，查表的操作本可以交给软件完成，但是软件的速度毕竟没有硬件快，所以最后还是在CPU中集成了一个硬件MMU，实际上，并不是每一次MMU都去查页表获取到物理地址，而是先看缓存中是否存在已经查到指定虚拟地址对应的物理地址，这个缓存也是通过硬件实现的，即TLB寄存器，所以整个过程就变为：查表时，先查看TLB是否存在需要的虚拟地址对应的物理地址，没有就去查表，并将这个映射存储到TLB，如下图所示：

<img src="1. Linux线程概念与线程操作.assets\download1.png">

### 理解页表标志位

在[Linux进程地址空间](https://www.help-doc.top/Linux/11.%20Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/11.%20%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.html#_7)部分提到过，页表中含有一些标记位，但是上面的理论只提到了物理地址，实际上，因为在32位系统中，一共由$2^{32}$个地址，因为每4kb为一个页框，所以总共有$\frac{2^{32}}{2^{12}}=2^{20}$，所以实际上在每一个二级页表项中，表示完所有的页框地址也只需要20位二进制，剩余的12位就可以用来作为标记位

### 细致理解缺页中断

CPU给MMU的虚拟地址，在TLB和页表都没有找到对应的物理页，该怎么办呢？其实这就是缺页异常`Page Fault`，它是个由硬件中断触发的可以由软件逻辑纠正的错误。假如目标内存页在物理内存中没有对应的物理页或者存在但无对应权限，CPU就无法获取数据，这种情况下CPU就会报告一个缺页错误。由于CPU没有数据就无法进行计算，CPU罢工了进程也就出现了缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的`Page Fault Handler`处理，如下图所示：

<img src="1. Linux线程概念与线程操作.assets\download2.png">

缺页中断会交给 PageFaultHandler 处理，其根据缺页中断的不同类型会进行不同的处理：

1. `Hard Page Fault`也被称为`Major Page Fault`，翻译为硬缺页错误/主要缺页错误，这时物理内存中没有对应的物理，需要CPU打开磁盘设备读取到物理内存中，再让MMU建⽴虚拟地址和物理地址的映射
2. `Soft Page Fault`也被称为`Minor Page Fault`，翻译为软缺页错误/次要缺页错误，这时物理内存中是存在对应物理页的，只不过可能是其他进程调入的，发出缺页异常的进程不知道而已，此时MMU只需要建立映射即可，⽆需从磁盘读取写入内存，一般出现在多进程共享内存区域
3. `Invalid Page Fault`翻译为无效缺页错误，⽐如进程访问的内存地址越界访问，又比如对空指针解引⽤内核就会报`segmentation fault`错误中断进程直接挂掉

## 线程的优点和缺点

对比进程，线程也有对应的优点，具体如下表所示：

| 特性 | 进程 | 线程 |
| --- | --- | --- |
| **创建代价** | 创建一个新进程的代价较大 | 创建一个新线程的代价较小 |
| **上下文切换工作量** | 进程之间的切换需要操作系统做较多的工作，涉及不同的虚拟内存空间 | 线程之间的切换需要操作系统做的工作较少，因为线程共享相同的虚拟内存空间 |
| **寄存器内容切换** | 切换时需要保存和恢复所有寄存器的内容 | 切换时需要保存和恢复较少的寄存器内容 |
| **缓存机制影响** | 上下文切换会扰乱处理器缓存机制，导致已缓存的内存地址失效，并且TLB会被刷新 | 上下文切换对处理器缓存机制影响较小，TLB不会被刷新 |
| **资源占用** | 占用较多系统资源 | 占用较少系统资源 |
| **多处理器利用** | 可以利用多处理器，但效率较低 | 能充分利用多处理器的并行处理能力 |
| **等待I/O操作** | 在等待慢速I/O操作结束时，无法执行其他计算任务 | 在等待慢速I/O操作结束时，可以执行其他计算任务 |

在线程的优点中，主要就是寄存器内容切换和缓存机制上，因为进程需要保存代码和数据，切换时需要全部切换，而线程只需要保存部分数据和代码，切换时只需要切换一部分内容，所以切换线程更方便且容易，另外一个影响切换性能的并不是进程本身的内容，而是缓存硬件，例如前面提到的TLB以及CPU中本身存在的Cache，如果是线程，因为页表不需要切换，并且相关的代码也不需要切换，所以在一定程度上节省了刷新缓存硬件的开销，但是进程就必须全部刷新，所以导致进程切换相对于线程就比较耗时

!!! info "局部性原理"

    局部性原理（Principle of Locality）是计算机科学中的一个重要概念，特别是在内存管理和缓存设计中。它描述了程序在访问数据时表现出的一种倾向，即程序倾向于访问最近访问过的数据或与其相邻的数据

    局部性原理分为两种主要类型：时间局部性和空间局部性：

    - 时间局部性指的是如果一个数据项被访问，那么在不久的将来它很可能再次被访问。这种现象通常出现在循环、递归调用等场景中，因为这些结构会反复访问相同的数据
    - 空间局部性指的是如果一个数据项被访问，那么与之相邻的数据项也很可能很快被访问。这是因为大多数程序在访问数据时，往往会按顺序访问连续存储的数据，如数组元素、结构体成员等

    局部性原理的应用

    1. CPU缓存（Cache）：
        
        - 时间局部性：缓存机制利用时间局部性，将最近访问的数据保存在快速缓存中，以便下次访问时能快速获取
        - 空间局部性：缓存通常以块（cache lines）为单位加载数据，这样当一个数据项被加载到缓存时，其邻近的数据也会一并加载进来，提高访问效率
    
    2. 虚拟内存管理：
    
        - 操作系统通过分页机制管理内存，页面大小的设计也考虑了局部性原理。较大的页面可以更好地利用空间局部性，但可能会增加内存浪费；较小的页面则更适合精细的内存管理
    3. 预取技术：
    
        - 现代处理器和存储系统常使用预取技术（prefetching），基于局部性原理预测即将访问的数据，并提前将其加载到缓存或更高层次的存储中，从而减少等待时间

    4. 文件系统和数据库：
    
        - 文件系统和数据库系统在设计时也会考虑局部性原理，例如通过缓存最近访问的文件块或数据库记录来提高性能

!!! info "在Linux中查看CPU信息"

    在Linux中查看CPU信息可以使用下面的指令：

    ```shell
    cat /proc/cpuinfo
    ```

同样，线程也有对应的缺点：

1. 性能损失：计算密集型线程往往无法与其他线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，可能会有较大的性能损失，增加额外的同步和调度开销
2. 健壮性降低：编写多线程需要更全面深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性很大，线程之间缺乏保护
3. 缺乏访问控制：进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响
4. 编程难度提高：编写与调试一个多线程程序比单线程程序困难得多

## 线程独有和共有的数据

在PCB中，线程独有的数据：

- 线程ID
- 一组寄存器
- 栈
- 错误码
- 信号屏蔽字
- 调度优先级

线程中共有的数据：

同一地址空间，因此代码段、数据段都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到除此之外，各线程还共享以下进程资源和环境：

- 文件描述符表
- 每种信号的处理方式(`SIG_IGN`、`SIG_DFL`或者自定义的信号处理函数)
- 当前工作目录
- 用户id和组id

## 线程操作

### 创建线程

如果想在Linux下创建进程可以使用下面的函数：

```c
int pthread_create(pthread_t * thread, 
                    const pthread_attr_t * attr, 
                    void *(*start_routine)(void *), 
                    void * arg);
```

需要注意，`pthread_create`函数并不是Linux提供的创建线程的系统调度，而是Linux中对轻量级进程已有的接口进行封装的动态库中的函数，既然是动态库，那么在编译链接时就需要在编译命令后带上`-lpthread`

该函数中，第一个参数表示创建的新线程的`id`值，第二个参数表示线程属性，一般情况下用不到，只需要传递`NULL`即可，第三个参数表示线程需要执行的代码，其为一个回调函数，第四个参数就是回调函数的参数

## 理解资源划分