# 生产者消费者模型（Producer-Consumer Model）

## 基本介绍

生产者消费者模型（或称生产消费模型）是一种常见的多线程并发控制模型，用于解决共享资源冲突问题。在这个模型中，存在着两种角色：

1. 生产者：表示数据的提供方或者数据的来源
2. 消费者：表示数据的接收方或者数据的处理

基本过程是在一个程序中生产和消费产品，两个行为分别对应着两个线程，一个线程负责生产，一个线程负责消费，并且消费模式为：生产一个产品紧接着消费一个产品，不可以产生同时生产和同时消费，基本示意图如下：

<img src="4. 生产者消费者模型（Producer-Consumer Model）.assets/image-20250213202112977.png">

因为存在着两个角色，所以本质上存在着3种关系：

1. 生产者与生产者：即同一任务的多个线程，因为彼此都执行着同一个任务（将数据放置到仓库中），所以彼此是互斥的
2. 消费者与消费者：即同一任务的多个线程，因为彼此都执行着同一个任务（从仓库中取出数据），所以彼此是互斥的
3. 生产者和消费者：执行不同任务的两个线程，当任意一个线程正在访问仓库时，另外一个线程不可以访问仓库，此时是互斥的。另外，为了保证消费者和生产者交替工作，还需要保证二者是同步的

所以，生产消费模型本质遵循着「321」原则：

1. 3种角色关系
2. 2个角色
3. 1个交易场所

生产消费模型就是通过一个容器来解决生产者和消费者的强耦合问题。具体来说就是生产者和消费者彼此之间不直接通讯，而通过阻塞队列（即交易场所）来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔进阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的

在本次实现中，首先考虑实现只有一个生产者和只有一个消费者的模式（单生产者单消费者），再进一步扩展到多生产者和多消费者的模式

## 基于线程同步与互斥实现基于单生产者单消费者的生产消费模型

### 设计阻塞队列

首先设计生产者和消费者的交易场所，对于这个阻塞队列来说，其要实现的功能实际上主要就只有两个，一个是生产者放入数据，另外一个是消费者读取数据。本次考虑底层使用到C++的队列结构作为阻塞队列的底层结构，所以基本代码结构如下：

```c++
class BlockQueue
{
public:
    BlockQueue()
    {
    }

    void pushData(int data)
    {
        _bq.push(data);
    }

    void popData(int *out)
    {
        *out = _bq.front();
        _bq.pop();
    }

    ~BlockQueue()
    {
    }

private:
    std::queue<int> _bq;
};
```

接着，既然是交易场所，那么肯定有大小限制，所以阻塞队列一定有最大容量，但是在C++中，队列结构会自动扩容，所以需要一个成员`_maxSize`表示当前阻塞队列的最大容量，至于这个容量为多少，可以设计为两种：

1. 给定缺省值，并且支持用户自行设定
2. 直接写死

本次考虑使用第一种方式。既然有了最大容量和最小容量（即没有任何数据），那么在插入和获取数据时一定要保证插入时阻塞队列不为满以及获取时阻塞队列不为空，所以还需要提供两个接口分别判断当前阻塞队列是否是满状态或者空状态，因为这两个接口只需要类内使用，所以可以考虑直接作为类内成员函数：

```c++
private:
    bool isFull()
    {
        return _bq.size() == _maxSize;
    }

    bool isEmpty()
    {
        return _bq.empty();
    }
```

对应地需要修改插入和获取函数。对于这两个函数，考虑下面的思路：

1. 插入数据函数：如果阻塞队列为满，说明此时不允许插入，那么一旦有线程调用插入函数判断当前阻塞队列已满就可以考虑进入等待，直到下一次阻塞队列为空时再唤醒其中一个生产线程。这种思路的好处是，一旦插入线程被唤醒，那么此时阻塞队列一定是至少有一个空位置插入数据的，而因为只唤醒了一个生产线程，所以也只会插入一个数据，空间是完全足够的，此时当前线程离开判满的分支后直接插入数据即可
2. 获取数据函数：如果阻塞队列为空，说明此时不允许获取数据，那么一旦有现成调用获取函数判断当前阻塞队列已经为空就可以考虑进入等待，直到下一次阻塞队列至少有一个数据时再唤醒其中一个消费线程。这种思路的好处是，一旦获取线程被唤醒，那么此时阻塞队列一定是至少有一个数据，而因为只唤醒了一个插入线程，所以也只会获取到一个数据，所以不会出现为空时获取的情况

根据上面的思路可以看出，需要一把锁和两个条件变量：

1. 一把锁：控制3种关系都实现互斥，保证阻塞队列同一时刻一定只有一个线程在访问
2. 两个条件变量：控制生产者和消费者。当生产者插入数据时发现阻塞队列已满，进入等待，一旦消费者获取数据，消费者根据生产者的条件变量唤醒生产者，代表生产者此时可以生产数据；当消费者读取数据时发现阻塞队列为空，进入等待，一旦生产者生产数据，生产者根据消费者的条件变量唤醒消费者，代表消费者此时可以获取数据

另外，为了确保代码的健壮性，可以考虑唤醒前先确定是否对应条件变量下有线程正在等待，可以通过设置两个计数器分别表示当前正在等待的生产者线程个数和消费者线程个数

所以修改后的代码如下：

!!! note

    下面的代码使用到前面对[互斥锁](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.html#_6)、[条件变量](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/3.%20Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.html#mutex)的封装

```c++
class BlockQueue
{
private:
    bool isFull()
    {
        return _bq.size() == _maxSize;
    }

    bool isEmpty()
    {
        return _bq.empty();
    }

public:
    BlockQueue(size_t maxSize = 5)
        : _maxSize(maxSize), _p_wait_num(0), _c_wait_num(0)
    {
    }

    void pushData(int data)
    {
        // 插入数据前抢锁
        MutexGuard mutex(_lock);
        if (isFull())
        {
            _p_wait_num++;
            // 满时生产者等待
            _p_cond.wait(_lock);
            _p_wait_num--;
        }

        // 此时一定有空位置
        _bq.push(data);

        // 通知消费者可以获取数据
        if (_c_wait_num)
            _c_cond.notify();
    }

    void popData(int *out)
    {
        // 获取数据前抢锁
        MutexGuard mutex(_lock);
        if (isEmpty())
        {
            _c_wait_num++;
            // 空则等待
            _c_cond.wait(_lock);
            _c_wait_num--;
        }

        // 此时一定有数据
        *out = _bq.front();
        _bq.pop();

        // 通知生产者可以生成数据
        if (_p_wait_num)
            _p_cond.notify();
    }

    ~BlockQueue()
    {
    }

private:
    std::queue<int> _bq;
    size_t _maxSize;    // 最大容量
    Mutex _lock;        // 一把锁
    Condition _p_cond;  // 生产者条件变量
    Condition _c_cond;  // 消费者条件变量
    size_t _p_wait_num; // 生产者等待数量
    size_t _c_wait_num; // 消费者等待数量
};
```

### 设计主逻辑

在主逻辑中，首先需要让两个线程看到阻塞队列，所以可以考虑将阻塞队列定义为全局变量，如下：

```c++
#include "BlockQueue.hpp"

using namespace BlockQueueModule;

// 阻塞队列
BlockQueue bq;

int main()
{

    return 0;
}
```

接着，在主函数中创建一个生产者线程和一个消费者线程，这两个线程分别执行自己的生成函数和消费函数，再启动线程和等待线程：

!!! note

    下面的代码使用到前面封装的[线程库](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/2.%20Linux%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%BA%93%E5%B0%81%E8%A3%85/2.%20Linux%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%BA%93%E5%B0%81%E8%A3%85.html#_4)

```c++
void producer()
{
}

void consumer()
{
}

int main()
{
    // 创建生产者线程
    Thread pro(producer);

    // 创建消费者线程
    Thread con(consumer);

    // 启动两个线程
    pro.start();
    con.start();

    // 等待两个线程
    pro.join();
    con.join();

    return 0;
}
```

在生产者的执行函数`producer`中，考虑让生产者持续生产数据，并且为了能看到生成的数据差异，可以考虑每一次生产完数据后改变该数据；在消费者的执行函数`consumer`中，考虑让消费者持续读取数据，代码如下：

```c++
void producer()
{
    int data = 10;
    while (true)
    {
        sleep(1);
        std::cout << "生产者：" << pthread_self() % 1000 << "生产了一个数据：" << data << std::endl;

        bq.pushData(data);

        data += 10;
    }
}

void consumer()
{
    while (true)
    {
        sleep(1);

        int data = 0;
        bq.popData(&data);

        std::cout << "消费者：" << pthread_self() % 1000 << "获取到一个数据：" << data << std::endl;
    }
}
```

编译运行上面的代码即可看到生产者先生产数据，消费者再拿数据，二者有序进行：

<img src="4. 生产者消费者模型（Producer-Consumer Model）.assets\Snipaste_2025-02-13_21-52-54.png">

