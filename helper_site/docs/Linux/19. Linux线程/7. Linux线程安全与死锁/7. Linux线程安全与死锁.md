# Linux线程安全与死锁

## 线程安全与重入问题

线程安全：就是多个线程在访问共享资源时，能够正确地执行，不会相互干扰或破坏彼此的执行结果。一般而言，多个线程并发同一段只有局部变量的代码时，不会出现不同的结果。但是对全局变量或者静态变量进行操作，并且没有锁保护的情况下，容易出现该问题

重入：同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，称之为重入。一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数被称为可重入函数，否则，是不可重入函数

根据前面的知识，目前重入情况分为两种：

1. 多线程重入函数
2. 信号导致一个执行流多次重入函数

=== "常见的线程不安全的情况"

    1. 函数中存在未被保护的全局变量
    2. 函数状态会随着调用每个线程调用而改变
    3. 函数返回指向静态变量
    4. 函数内部调用本身就是线程不安全的函数

=== "常见的线程安全的情况"

    1. 每个线程对全局变量或者静态变量只有读取的权限，而没有写入的权限，一般来说这些线程是安全的
    2. 类或者接口对于线程来说都是原子操作
    3. 多个线程之间的切换不会导致该接口的执行结果存在二义性

=== "常见的不可重入的情况"

    1. 调用了`malloc`/`free`函数，因为`malloc`/`new`函数是用全局链表来管理堆的
    2. 调用了标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构
    3. 可重入函数体内使用了静态的数据结构

=== "常见的可重入的情况"

1. 不使用全局变量或静态变量
2. 不使用`malloc`/`new`开辟的空间
3. 不调用不可重入函数
4. 

## 死锁

## STL容器、智能指针与线程安全

## 其他锁