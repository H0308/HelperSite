# UDP应用2：简易聊天室

## 本篇介绍

在前面的基本使用过程中已经完成了本地和网络通信，既然一个人和一台服务器可以进行通信，那么多个人连接一台服务器也可以和这台服务器实现通信。在这个基础上，如果服务器可以将某个人发给服务器的消息转发给所有连接到当前服务器的客户端，就可以实现一个人发消息，其他人看到消息的效果，这就是简易聊天室的原理

本篇就是利用UDP的操作实现上面提到的简易聊天室，其中客户端向服务端发送消息，服务端将收到的消息转发给所有连接到当前服务器的客户端

需要注意，本次实现基于[前面封装的服务端和客户端](https://www.help-doc.top/Linux/22.%20UDP%E7%BC%96%E7%A8%8B/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html)

## 主要功能实现思路

在实现具体功能之前，先了解本次设计聊天室的主要功能的实现思路：

既然要实现多个用户连接一台服务器，那么每一个用户就需要有相关的属性，并且多个用户还需要进行管理，所以必须先对用户模块进行设计

本次设计的用户模块可以采用观察者模式。观察者模式是一种行为型设计模式，用于定义对象之间的一对多依赖关系。当一个对象的状态发生变化时，所有依赖于它的对象都会自动收到通知并更新，其有下面的核心对象：

1. 主题（Subject）：被观察的对象。维护一组观察者，并提供添加、删除和通知观察者的方法
2. 观察者（Observer）：监听主题状态变化的对象。定义一个更新接口，用于接收主题的通知

根据上面的概念，考虑接下来的设计思路

首先是设计基类，在观察者模式中，基类可以分为两种：

1. 主题基类：声明主题需要实现的三个方法，在本次聊天室中分别对应着：添加用户、删除用户和将消息转发给所有用户
2. 观察者基类：声明观察者在检测到状态变化时需要做出的行为，在本次聊天室中对应着：将指定的信息发给自己

??? question "为什么观察者基类需要将信息发给自己？"

    在本次实现中，实际上是由服务器调用转发函数，此时就会调用主题实现类中的<a href="javascript:;" class="custom-tooltip" data-title="即将消息转发给所有用户">转发函数<span style="color: grey;">（鼠标悬浮/手指点击时显示更多信息）</span></a>，在转发函数中，每一个观察者都会收到服务器传递的信息，此时每一个观察者携带着该信息调用自己的<a href="javascript:;" class="custom-tooltip" data-title="即观察这在检测到状态变化时需要做出行为对应的函数">更新函数<span style="color: grey;">（鼠标悬浮/手指点击时显示更多信息）</span></a>，在更新函数中，每一个观察者就会将指定信息根据自己的IP地址发送给自己，这样就相当于是服务器将信息转发给所有在线的客户端。简单来说，就是通过服务器从没有收到信息到接收到某一信息这一状态的变化间接更新所有的客户端

接着，有了基类就需要有对应的实现类，那么对应的就是观察者实现类和主题实现类，主题实现类需要对所有的观察者进行管理，实现类只需要实现需要的更新方法即可，具体见后面的解析

设计完用户模块之后，就是服务器端的处理，本次设计的聊天室服务器需要完成下面的内容：

1. 当用户第一次向服务器发送信息时需要将用户添加为观察者
2. 一个用户向服务器发送信息时，服务器需要将这条信息转发给所有连接到当前服务器的用户

对于第一个任务，服务器可以完全胜任，因为完全就是调用主题实现类的添加方法，这一步不会有很大的消耗，但是对于第二个任务，因为`socketfd`是双工的，那么就会存在既接收信息又分发信息，而分发信息需要遍历到每一个观察者，此时只有服务器一个线程，那么这一个线程开销就会非常大，所以为了避免这个问题就可以考虑使用线程池完成分发任务

需要注意，本次会使用前面[封装的单例线程池](https://www.help-doc.top/Linux/19.%20Linux%E7%BA%BF%E7%A8%8B/8.%20Linux%E7%BA%BF%E7%A8%8B%E6%B1%A0/8.%20Linux%E7%BA%BF%E7%A8%8B%E6%B1%A0.html#_16)

## 实现用户模块

### 创建观察者基类

观察者基类最关键的方法就是更新数据，所以基本结构如下：

```c++
// 观察者基类
class UserObserver
{
public:
    virtual ~UserObserver() = default;
    virtual void sendMessage() = 0;
};
```

### 创建观察者实现类

既然是观察者实现类，那么少不了的就是对虚函数进行重写，在前面的主要功能中提到过，观察者的主要方法是将消息根据自己的IP地址，所以基本结构代码如下：

```c++
// 观察者实现类
class User : public UserObserver
{
public:
    virtual void sendMessage(int sockfd, const std::string& message) override
    {
    }
};
```

但是，为了这个类需要用于不同的用户，所以还需要相关的属性和构造方法，本次考虑用户可以有IP地址、端口和用户名作为属性，在构造时需要用户传递IP地址、端口和用户名：

!!! note

    需要注意，本次将使用前面封装的`struct sockaddr_in`结构

```c++
// 观察者实现类
class User : public UserObserver
{
public:
    User(uint16_t port, std::string ip, std::string name)
        : _name(name), _sa_in(port, ip)
    {
    }

    // ...

private:
    std::string _name;
    SockAddrIn _sa_in;
};
```

### 实现观察者实现类重写方法

在前面的主要功能中提到过，观察者的主要方法是将消息根据自己的IP地址发给自己，所以实现如下：

```c++
virtual void sendMessage(int sockfd, const std::string &message) override
{
    // 打印日志
    LOG(LogLevel::INFO) << "Client: " << _sa_in.getIp() << ":" << _sa_in.getPort() << "send message: " << message;

    // 发送信息给自己
    ssize_t = sendto(sockfd, message.c_str(), message.size(), 0, &_sa_in, _sa_in.getLength());
}
```

### 创建主题基类

根据前面的主要功能实现思路可以知道主题基类有三个主要方法：添加用户、删除用户和将消息转发给所有用户，所以代码如下：

```c++
// 主题基类
class UserManagerSubject
{
public:
    virtual ~UserManagerSubject() = default;
    // 添加方法
    virtual void addUser(const User &user) = 0;
    // 删除方法
    virtual void delUser(const User &user) = 0;
    // 通知方法
    virtual void dispathMessage(int sockfd, const std::string &message) = 0;
};
```

### 创建主题实现类

根据上面的基类实现对应的方法，但是除了有对应的方法外，还需要有一个用于管理所有用户的结构，本次考虑<a href="javascript:;" class="custom-tooltip" data-title="也可以使用其他结构，但是不论是哪一种结构都要涉及到遍历，所以不论是使用查找快速的哈希表还是线性结构实际上的时间消耗都是大差不差的">使用list结构<span style="color: grey;">（鼠标悬浮/手指点击时显示更多信息）</span></a>，基本代码如下：

```c++
// 主题实现类
class UserManager : public UserManagerSubject
{
public:
    UserManager()
    {
    }

    // 实现添加方法
    virtual void addUser(const User &user) override
    {
    }

    // 实现删除方法
    virtual void delUser(const User &user) override
    {
    }

    // 通知方法
    virtual void dispathMessage(int sockfd, const std::string &message) override
    {
    }

private:
    std::list<std::shared_ptr<User>> _u_list;
};
```

### 实现主题实现类重写方法

主题实现类中一共三个方法，下面针对这三个方法进行分别实现：

#### 添加方法

对于第一个方法，既然是添加数据，那么肯定涉及到访问链表，因为后面会存在服务器线程访问这个链表，线程池中的线程也会访问这个链表，所以为了保证线程安全，每一个线程在访问链表时需要先申请锁，申请锁成功后再修改链表中的内容，所以在此基础之上还需要一个互斥锁成员

接着在主要逻辑中，因为是插入用户，所以首先需要判断插入的用户是否存在，如果存在就插入，否则就不插入。但是这里涉及到一个问题，需要判断用户是否存在就必然涉及到比较用户的属性，在前面观察者实现类中一共有两个属性，一个是字符串，这个类型的属性已经重载了比较运算符，所以可以直接比较，但是对于封装的结构`SockAddrIn`并没有重载对应的操作符，所以此处还需要在观察者实现类中实现`==`运算符重载函数

判断两个`SockAddrIn`类成员是否相同主要是判断端口和IP地址是否相同，注意不能本次不建议单独判断IP地址或者端口，假设只判断IP地址，那么如果当前用户与服务器断开再连接就会出现误判断，但是实际上这个用户是已经退出再添加的。同理，如果只是判断端口，那么可能存在两个端口相同的客户端连接服务器，当其中一个客户端连接服务器，第二个用户再连接也会出现误判断。所以在`SockAddrIn`类需要实现下面的方法：

```c++
// 重载==
bool operator==(const SockAddrIn &s)
{
    return _ip == s._ip && _port == _port;
}
```

接着，为了比较两个用户是否是同一个用户，还需要在`User`类中重载`==`运算符，比较方式是比较用户名和`SockAddrIn`对象，即：

```c++
// 重载==
bool operator==(const User &u)
{
    return _name == u._name && _sa_in == u._sa_in;
}
```

有了这两个重载函数之后，就可以比较两个用户是否相同。回到上面的逻辑，有了比较两个用户是否相等的方式后，只要判断插入的用户不存在于链表中，那么就可以插入，即：

```c++
// 实现添加方法
virtual void addUser(const User &user) override
{
    // 先申请锁
    MutexGuard guard(_mutex);
    // 确保用户不存在
    for (auto &u : _u_list)
        if (*u == user)
            return;

    // 不存在时插入
    _u_list.push_back(std::make_shared<User>(user));
}
```

!!! note

    上面的代码使用到了默认的拷贝构造，因为需要深拷贝的结构string有对应的拷贝构造函数，而`uint16_t`本质是一个内置类型，所以直接拷贝也不会有问题

#### 删除方法

删除方法的实现步骤就是找到指定的用户将其从链表中移除即可，此处可以考虑使用`remove_if`接口，该接口会将指定的用户节点移动到链表的最后，之后只需要删除最后一个节点即可

同样，为了确保多个线程下的线程安全，同样需要先申请锁，再进行删除操作：

```c++
// 实现删除方法
virtual void delUser(const User &user) override
{
    MutexGuard guard(_mutex);

    auto pos = std::remove_if(_u_list.begin(), _u_list.end(), [&user](const std::shared_ptr<User> &u)
                                { return *u == user; });

    _u_list.erase(pos, _u_list.end());
}
```

#### 通知方法

在主要功能实现思路部分重点提到了通知方法的本质就是让每一个客户端自己个自己发消息，所以只需要遍历用户链表，让每一个成员调用自己的发送更新方法即可

同样，为了确保多个线程下的线程安全，同样需要先申请锁，再进行删除操作：

```c++
// 通知方法
virtual void dispathMessage(int sockfd, const std::string &message) override
{
    MutexGuard guard(_mutex);
    for (auto &u : _u_list)
        u->sendMessage(sockfd, message);
}
```

## 