# TCP编程接口基本使用

## 本篇介绍

在[UDP编程接口基本使用](https://www.help-doc.top/Linux/22.%20UDP%E7%BC%96%E7%A8%8B/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html#udp)已经介绍过UDP编程相关的接口，本篇开始介绍TCP编程相关的接口。有了UDP编程的基础，理解TCP相关的接口会更加容易，下面将按照两个方向使用TCP编程接口：

1. 基本使用TCP编程接口实现服务端和客户端通信
2. 使用TCP编程实现客户端控制服务器执行相关命令的程序

## 创建并封装服务端

### 创建服务器类

与UDP一样，首先创建服务器类的基本框架，本次设计的服务器一旦启动就不再关闭，除非手动关闭，所以可以提供两个接口：

1. `start`：启动服务器
2. `stop`：停止服务器

基本结构如下：

```c++
class TcpServer
{
public:
    TcpServer()
    {
    }

    // 启动服务器
    void start()
    {
    }

    // 停止服务器
    void stop()
    {
    }

    ~TcpServer()
    {
    }
};
```

### 创建服务器套接字

创建方式与UDP基本一致，只是在`socket`接口的第二个参数使用`SOCK_STREAM`而不再是`SOCK_DGRAM`，代码如下：

```c++
class TcpServer
{
public:
    TcpServer()
        : _socketfd(-1)
    {
        // 创建服务器套接字
        _socketfd = socket(AF_INET, SOCK_STREAM, 0);

        if (_socketfd < 0)
        {
            LOG(LogLevel::FATAL) << "Server initiated error: " << strerror(errno);
            exit(static_cast<int>(ErrorNumber::SocketFail));
        }
        LOG(LogLevel::INFO) << "Server initated: " << _socketfd;
    }

    // ...

private:
    int _socketfd;  // 服务器套接字
};
```

### 绑定服务器IP地址和端口

绑定方式与UDP基本一致，先使用原生的方式而不是直接使用封装后的`sockaddr_in`结构。在[UDP编程接口基本使用](https://www.help-doc.top/Linux/22.%20UDP%E7%BC%96%E7%A8%8B/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html#linux)部分已经提到过服务器不需要指定IP地址，所以本次一步到位，代码如下：

```c++
// 默认端口
const uint16_t default_port = 8080;

class TcpServer
{
public:
    TcpServer(uint16_t port = default_port)
        : // ...
        , _port(port)
    {
        // ...

        struct sockaddr_in server;
        server.sin_family = AF_INET;
        server.sin_port = htons(_port);
        server.sin_addr.s_addr = INADDR_ANY;

        int ret = bind(_socketfd, reinterpret_cast<const struct sockaddr *>(&server), sizeof(server));
        if (ret < 0)
        {
            LOG(LogLevel::FATAL) << "Bind error：" << strerror(errno);
            exit(static_cast<int>(ErrorNumber::BindSocketFail));
        }
        LOG(LogLevel::INFO) << "Bind Success";
    }

    // ...

private:
    int _socketfd;  // 服务器套接字
    uint16_t _port; // 服务器端口
};
```

### 开启服务器监听

在UDP部分，走完上面的步骤就已经完成了基本工作，一旦服务器启动就会等待连接。但是在TCP部分则不行，因为TCP是面向连接的，也就是说，使用客户端需要连接使用TCP的客户端必须先建立连接，只有连接建立完成了才可以开始通信。为了可以让客户端和服务端成功建立连接，首先需要让服务器处于监听状态，此时服务器只会一直等待客户端发起连接请求

在Linux中，实现服务器监听可以使用`listen`接口，其原型如下：

```c++
int listen(int sockfd, int backlog);
```

该接口的第一个参数表示当前需要作为传输的套接字，第二个参数表示等待中的客户端的最大个数。之所以会有第二个参数是因为一旦请求连接的客户端太多但是服务器又无法快速得做出响应就会导致用户一直处于等待连接状态从而造成不必要的损失。一般情况下第二个参数不建议设置比较大，而是因为应该根据实际情况决定，但是一定不能为0，本次大小定为8

当监听成功，该接口会返回0，否则返回-1并设置对应的错误码

在TCP中，服务器一旦被创建那么久意味着其需要开始进行监听，所以本次考虑将监听放在构造中：

```c++
// 默认最大支持排队等待连接的客户端个数
const int max_backlog = 8;

class TcpServer
{
public:
    TcpServer(uint16_t port = default_port)
        : _socketfd(-1), _port(port)
    {
        // ...

        ret = listen(_socketfd, max_backlog);
        if (ret < 0)
        {
            LOG(LogLevel::ERROR) << "Listen error：" << strerror(errno);
            exit(static_cast<int>(ErrorNumber::ListenFail));
        }
        LOG(LogLevel::INFO) << "Listen Success";
    }

    // ...
};
```

### 启动服务器

在TCP中，启动服务器的逻辑和UDP的逻辑有一点不同，因为TCP服务器在启动之前先要进行监听，所以实际上此时服务器并没有进入IO状态，所以一旦启动服务器后，首先要做的就是一旦成功建立连接就需要进入收发消息的状态

首先判断服务器是否启动，如果服务器本身已经启动就不需要再次启动，所以还是使用一个`_isRunning`变量作为判断条件，基本逻辑如下：

```c++
// 启动服务器
void start()
{
    if (!_isRunning)
    {
        _isRunning = true;
        while (true)
        {
        }
    }
}
```

接着就是在监听成功的情况下进入IO状态，这里使用的接口就是`accept`，其原型如下：

```c++
int accept(int sockfd, struct sockaddr * addr, socklen_t * addrlen);
```

该接口的第一个参数表示需要绑定的服务器套接字，第二个参数表示对方的套接字结构，第二个参数表示对方套接字结构的大小，其中第二个参数和第三个参数均为输出型参数

需要注意的是该接口的返回值，当函数执行成功时，该接口会返回一个套接字，这个套接字与前面通过`socket`接口获取到的套接字不同。在UDP中，只有一个套接字，就是`socket`的返回值，但是在TCP中，因为首先需要先监听，此时需要用到的实际上是监听套接字，一旦监听成功，才会给定用于IO的套接字。所以实际上，在TCP中，`socket`接口的返回值对应的是`listen`用的套接字，而`accept`的套接字就是用于IO的套接字

基于上面的概念，现在对前面的代码进行一定的修正：对于前面的成员`_socketfd`，应该修改为`_listen_socketfd`：

```c++
class TcpServer
{
public:
    TcpServer(uint16_t port = default_port)
        : _listen_socketfd(-1), _port(port), _isRunning(false)
    {
        // 创建服务器套接字
        _listen_socketfd = socket(AF_INET, SOCK_STREAM, 0);

        if (_listen_socketfd < 0)
        {
            LOG(LogLevel::FATAL) << "Server initiated error: " << strerror(errno);
            exit(static_cast<int>(ErrorNumber::SocketFail));
        }
        LOG(LogLevel::INFO) << "Server initated: " << _listen_socketfd;
        
        int ret = bind(_listen_socketfd, reinterpret_cast<const struct sockaddr *>(&server), sizeof(server));
        // ...

        ret = listen(_listen_socketfd, max_backlog);
        // ...
    }

    // ...
private:
    int _listen_socketfd; // 服务器监听套接字
    // ...
};
```

接着，对于接收成功也可以创建一个成员变量`_ac_socketfd`，并用其接收`accept`接口的返回值：

```c++
class TcpServer
{
public:
    TcpServer(uint16_t port = default_port)
        : // ...
        , _ac_socketfd(-1)
    {
        // ...
    }

    // 启动服务器
    void start()
    {
        if (!_isRunning)
        {
            while (true)
            {
                struct sockaddr_in peer;
                socklen_t length = sizeof(peer);
                _ac_socketfd = accept(_listen_socketfd, reinterpret_cast<struct sockaddr *>(&peer), &length);

                if (_ac_socketfd < 0)
                {
                    LOG(LogLevel::WARNING) << "Accept failed：" << strerror(errno);
                    exit(static_cast<int>(ErrorNumber::AcceptFail));
                }
                LOG(LogLevel::INFO) << "Accept Success: " << _ac_socketfd;
            }
        }
    }
    
    // ...

private:
    // ...
    int _ac_socketfd;     // 服务器接收套接字
    // ...
};
```

后续的代码与UDP思路类似，但是具体实现有些不同。因为UDP是面向数据包的，所以只能「整发整取」，但是TCP是面向字节流的，所以可以「按照需求读取」而不需要「一定完整读取」，而在文件部分，读取和写入文件也是面向字节流的，所以在TCP中，读取和写入就可以直接使用文件的读写接口：

```c++
// 启动服务器
void start()
{
    if (!_isRunning)
    {
        while (true)
        {
            // ...

            // 读取客户端消息
            char buffer[4096] = {0};
            ssize_t ret = read(_ac_socketfd, buffer, sizeof(buffer) - 1);
            if (ret > 0)
            {
                LOG(LogLevel::INFO) << "Client: " << inet_ntoa(peer.sin_addr) << ":" << std::to_string(ntohs(peer.sin_port)) << " send: " << buffer;

                // 向客户端回消息
                ret = write(_ac_socketfd, buffer, sizeof(buffer));
            }
        }
    }
}
```

### 停止服务器

停止服务器和UDP思路一致，但是需要注意，除了要关闭接收套接字以外还需要关闭监听套接字，此处不再赘述：

=== "停止服务器函数"

    ```c++
    // 停止服务器
    void stop()
    {
        if (_isRunning)
        {
            close(_listen_socketfd);
            close(_ac_socketfd);
        }
    }
    ```

=== "析构函数"

    ```c++
    ~TcpServer()
    {
        stop();
    }
    ```

## 创建并封装客户端

### 创建客户端类

与UDP一致，代码如下：

```c++
class TcpClient
{
public:
    TcpClient()
    {
    }

    // 启动客户端
    void start()
    {
    }

    // 停止客户端
    void stop()
    {
    }

    ~TcpClient()
    {
    }
};
```

### 创建客户端套接字

与UDP一致，此处不再赘述：

```c++
class TcpClient
{
public:
    TcpClient()
        : _socketfd(-1)
    {
        _socketfd = socket(AF_INET, SOCK_STREAM, 0);

        if (_socketfd < 0)
        {
            LOG(LogLevel::FATAL) << "Client initiated error：" << strerror(errno);
            exit(static_cast<int>(ErrorNumber::SocketFail));
        }
        LOG(LogLevel::INFO) << "Client initiated";
    }

    // ...

private:
    int _socketfd;
};
```

### 启动客户端

因为当前是TCP，所以客户端必须先与服务端建立连接才可以进行数据传输。在Linux中，让客户端连接服务端的接口是`connect`，其原型如下：

```c++
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

该接口的第一个参数表示传送数据需要的套接字，第二个参数表示服务器的套接字结构，第三个参数表示第二个参数的大小

如果该接口连接成功或者绑定成功，则返回0，否则返回-1并且设置错误码

!!! note

    需要注意，该接口会在成功连接后自动绑定端口和IP地址，与UDP一样不需要用户手动设置客户端的IP地址和端口

因为需要用到服务器的端口和IP地址，所以在创建客户端对象时需要让用户传递IP地址和端口，所以基本代码如下：

```c++
// 默认服务器端口和IP地址
const std::string default_ip = "127.0.0.1";
const uint16_t default_port = 8080;

class TcpClient
{
public:
    TcpClient(const std::string &ip = default_ip, uint16_t port = default_port)
        : // ...
        , _isRunning(false), _ip(ip), _port(port)
    {
        // ...
    }

    // 启动客户端
    void start()
    {
        if (!_isRunning)
        {
            _isRunning = true;
            // 启动后就进行connect
            struct sockaddr_in server;
            server.sin_family = AF_INET;
            server.sin_addr.s_addr = inet_addr(_ip.c_str());
            server.sin_port = htons(_port);
            int ret = connect(_socketfd, reinterpret_cast<const struct sockaddr *>(&server), sizeof(server));
            if (ret < 0)
            {
                LOG(LogLevel::WARNING) << "Connect failed" << strerror(errno);
                exit(static_cast<int>(ErrorNumber::ConnectFail));
            }
            LOG(LogLevel::INFO) << "Connect Success: " << _socketfd;
            while (true)
            {
                // ...
            }
        }
    }

    // ...

private:
    // ...
    std::string _ip; // 服务器IP地址
    uint16_t _port;  // 服务器端口
    bool _isRunning; // 判断是否正在运行
};
```

在上面的代码中需要注意，不要把`connect`放在循环里，因为建立连接需要一次而不需要每一次发送都建立连接

接着就是写入和读取消息，基本思路与UDP相同，代码如下：

```c++
// 启动客户端
void start()
{
    if (!_isRunning)
    {
        // ...
        while (true)
        {
            // 向服务器写入
            std::string message;
            std::cout << "请输入消息：";
            std::getline(std::cin, message);
            ssize_t ret = write(_socketfd, message.c_str(), message.size());

            // 收到消息
            char buffer[4096] = {0};
            ret = read(_socketfd, buffer, sizeof(buffer));
            if (ret > 0)
                LOG(LogLevel::INFO) << "收到服务器消息：" << buffer;
        }
    }
}
```

### 停止客户端

停止客户端的思路与UDP一致，此处不再赘述：

=== "停止客户端函数"

    ```c++
    // 停止客户端
    void stop()
    {
        if (_isRunning)
            close(_socketfd);
    }
    ```

=== "析构函数"

    ```c++
    ~TcpClient()
    {
        stop();
    }
    ```

## 本地通信测试

**测试步骤：**

1. 先启动服务端，再启动客户端
2. 客户端向服务器端发送信息

**测试目标：**

1. 客户端可以正常向服务器端发送信息
2. 服务端可以正常显示客户端信息并正常向客户端返回客户端发送的信息
3. 客户端可以正常显示服务端回复的信息

测试代码如下：

=== "客户端"

    ```c++
    #include "tcp_client.hpp"
    #include <memory>
    
    using namespace TcpClientModule;
    
    int main(int argc, char *argv[])
    {
        std::shared_ptr<TcpClient> tcp_client;
        if (argc == 1)
        {
            // 使用默认端口和IP地址
            tcp_client = std::make_shared<TcpClient>();
        }
        else if (argc == 3)
        {
            std::string ip = argv[1];
            std::uint16_t port = std::stoi(argv[2]);
            // 使用自定义端口和IP地址
            tcp_client = std::make_shared<TcpClient>(ip, port);
        }
        else
        {
            LOG(LogLevel::ERROR) << "错误使用，正确使用为：" << argv[0] << " IP地址 端口号（或者二者都不存在）";
            exit(7);
        }
        
        tcp_client->start();
    
        tcp_client->stop();
    
        return 0;
    }
    ```

=== "服务端"

    ```c++
    #include "tcp_server.hpp"
    #include <memory>
    
    using namespace TcpServerModule;
    
    int main(int argc, char *argv[])
    {
        std::shared_ptr<TcpServer> tcp_server;
        if (argc == 1)
        {
            // 使用默认的端口
            tcp_server = std::make_shared<TcpServer>();
        }
        else if (argc == 2)
        {
            // 使用自定义端口
            std::string port = argv[1];
            tcp_server = std::make_shared<TcpServer>(port);
        }
        else
        {
            LOG(LogLevel::ERROR) << "错误使用，正确方式：" << argv[0] << " 端口（可以省略）";
            exit(6);
        }
    
        tcp_server->start();
    
        tcp_server->stop();
    
        return 0;
    }
    ```

本次设计的客户端支持用户从命令行输入端口和IP地址，否则就直接使用默认，下面是一种结果：

<img src="23. TCP编程接口基本使用.assets/image-20250303212358636.png">

## 测试云服务器与本地进行通信

### 相同操作系统

### 不同操作系统

## 多个客户端同时连接服务器

### 基本现象

### 子进程版本

### 新线程版本

### 线程池版本

## 客户端控制服务器执行相关命令的程序

