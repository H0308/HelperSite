# 深入HTTP序列化和反序列化

## 本篇介绍

在上一节已经完成了客户端和服务端基本的HTTP通信，但是前面的传递并没有完全体现出HTTP的序列化和反序列化，为了更好得理解其工作流程，在本节会以更加具体的方式分析到HTTP序列化和反序列化

!!! note

    本节会在[介绍HTTP协议基本结构与基本实现HTTPServer](https://www.help-doc.top/Linux/26.%20%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/1.%20%E4%BB%8B%E7%BB%8DHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0HTTPServer/1.%20%E4%BB%8B%E7%BB%8DHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0HTTPServer.html#httphttpserver)的基础之上继续完善HTTP服务器，所以需要有对应的知识作为铺垫才可以开始本节

## 基本实现思路

本次实现的`HttpServer`类主要完成接收客户端发送的HTTP请求，也就是说，服务器需要根据客户端的HTTP请求回复一个HTTP响应，所以必须要有的方法就是处理请求方法，但是前面已经提到过，HTTP的请求属于结构化的数据，并且这个数据在传递给服务器时就已经做了序列化，服务器需要处理的就是将结构化的数据进行反序列化；同样，服务器处理完毕后还需要发给客户端，所以此处就需要服务器对处理的结果填充到HTTP响应结构对象中再返回给客户端，此处就需要进行序列化

基于上面的原因，与前面[序列化和反序列化与网络计算器](https://www.help-doc.top/Linux/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8.html#_5)一样，需要实现一个协议，包含`HttpRequest`和`HttpResponse`类，用于处理序列化和反序列化

??? "HTTP不是自己做序列化和反序列化吗，为什么上面还需要手动进行序列化和反序列化"

    需要注意的是，HTTP自己做序列化前提是基于一个已经存在的HTTP服务器，首先对于客户端，如果是浏览器，浏览器会自动将传送给服务器的数据进行序列化，此时服务器必须要进行反序列化提取其中的有效内容，同样，因为实现的是HTTP服务器，所以现在的服务器本身不具备任何自动序列化的行为，需要手动去实现，因此实现的`HttpServer`必须将响应给客户端的数据进行序列化再发送给客户端，这样客户端才可以正常获取到HTTP响应中的数据

本次为了更好得理解序列化和反序列化，以HTTP请求为例，首先以请求行、请求报头和请求体三个整体做序列化和反序列化，接着再深入请求行、请求报头和请求体中的字段

根据这个两个阶段，需要实现的目标如下：

1. 第一阶段：打印出反序列化和序列化的结果
2. 第二阶段：向客户端返回具体的静态资源文件

## 第一阶段

### 创建`HttpRequest`类

根据前面的基本思路，实现`HttpRequest`类就需要实现对应的反序列化。因为HTTP请求中带有三种数据：

1. 请求行
2. 请求报头
3. 请求体

所以需要定义三个成员分别存放从请求获取到的内容，所以基本结构如下：

```c++
class HttpRequest
{
public:
    HttpRequest()
    {

    }

    // 反序列化
    bool deserialize(std::string& in_str)
    {
        
    }

    ~HttpRequest()
    {

    }
private:
    std::string _req_line;              // 请求行
    std::vector<std::string> _req_head; // 请求报头
    std::string _req_body;              // 请求体
};
```

### 实现`HttpRequest`反序列化接口

在HTTP中的反序列化本质就是根据基本的格式去除掉多余的部分，从而提取出有效的数据放在相应的字段中，所以根据这个思路依次进行提取

!!! note

    注意，前面提到过，HTTP是基于TCP的，而TCP是面向字节流的，这就导致可能服务器接收到的HTTP请求不完整，对此还需要对接收到的HTTP请求进行完整性判断，但是本次不考虑这一步

#### 截取请求行

首先提取请求行中的数据，根据前面对HTTP请求结构的描述可以知道HTTP请求的请求行以`\r\n`结尾，所以只需要找到第一个`\r\n`，就说明找到了请求行，这里定义一个成员函数用来处理这个逻辑：

```c++
// 获取请求行
bool parseReqLineFromTotal(std::string& in_str)
{
    auto pos = in_str.find(default_sep);
    if(pos == std::string::npos)
    {
        LOG(LogLevel::WARNING) << "未找到请求行";
        return false;
    }

    // 获取到请求行
    _req_line = in_str.substr(0, pos);

    // 从原始字符串中移除请求头和第一个分隔符
    in_str.erase(0, pos + default_sep.size());

    LOG(LogLevel::DEBUG) << "请求行处理后：" << in_str;

    return true;
}
```

这里考虑到后面的请求体也是以`\r\n`结尾，所以考虑将该函数更改为更通用的版本：

```c++
// 截取以\r\n结尾的数据
bool parseOneLineFromTotal(std::string& in_str, std::string& out_str)
{
    auto pos = in_str.find(default_sep);
    if(pos == std::string::npos)
        return false;

    // 获取到截取数据
    out_str = in_str.substr(0, pos);

    // 从原始字符串中移除截取的字符串和对应的分隔符
    in_str.erase(0, pos + default_sep.size());

    return true;
}
```

接着完善反序列化接口：

```c++
// 反序列化
bool deserialize(std::string& in_str)
{
    bool getReqLineFlag = parseOneLineFromTotal(in_str, _req_line);
    if(!getReqLineFlag)
    {
        LOG(LogLevel::WARNING) << "反序列化获取请求行失败";
        return false;
    }
    LOG(LogLevel::INFO) << "截取的请求行为：" << _req_line;
    
    // 未完...
}
```

#### 截取请求报头

截取请求报头的方式与请求行非常类似，无非就是需要多次截取，但是需要考虑截取何时结束。根据HTTP请求体的特点，最后一行就是一个空行，即`\r\n`，所以可以考虑利用这个空行进行处理，具体思路如下：

因为每一次截取都会截取到分隔符之前的内容，所以可以考虑定义一个变量用于接收请求报头的结果，那么根据截取一行的函数的逻辑，只有成功找到了`\r\n`时才会进行截取，而截取的结果不会包含`\r\n`，那么一旦截取的结果是空且找到了`\r\n`，就说明找到了最后一行

根据这个思路，将获取请求报头数据的逻辑放在一个单独的函数中，如下：

```c++
// 获取请求报头
bool getReqHeadFromTotal(std::string &in_str)
{
    // 保存以\r\n结尾的一行数据
    std::string oneLine;
    while (true)
    {
        bool getOneLineFlag = parseOneLineFromTotal(in_str, oneLine);

        // 如果getOneLineFlag为true并且oneLine不为空，说明当前行有效，否则代表已经找到了结尾
        if(getOneLineFlag && !oneLine.empty())
        {
            _req_head.push_back(oneLine);
        }
        else if(getOneLineFlag && oneLine.empty())
        {
            break;
        }
        else
        {
            return false;
        }
    }
    
    return true;
}
```

继续完善反序列化接口：

```c++
// 反序列化
bool deserialize(std::string &in_str)
{
    // ...

    bool getReqHeadLine = getReqHeadFromTotal(in_str);
    if (!getReqHeadLine)
    {
        LOG(LogLevel::WARNING) << "反序列化获取请求报头失败";
        return false;
    }

    LOG(LogLevel::INFO) << "获取到的请求行为：";
    std::for_each(_req_head.begin(), _req_head.end(), [&](int i){
        std::cout << _req_head[i] << std::endl;
    });

    // 未完...
}
```

#### 截取请求体

因为在前面截取请求行和截取请求报头时已经修改了HTTP请求字符串，所以剩下的就是请求体，直接赋值即可：

```c++
// 反序列化
bool deserialize(std::string &in_str)
{
    // ...

    // 获取请求体
    _req_body = in_str;

    return true;
}
```

### 创建`HttpResponse`类

服务器需要给客户端返回内容，所以在这之前必须对整个`HttpResponse`结构进行序列化。同样，HTTP响应也有对应的三种数据：

1. 请求行
2. 请求报头
3. 请求体

所以需要定义三个成员分别存放从请求获取到的内容，所以基本结构如下：

```c++
// HTTP响应
class HttpResponse
{
public: 
    HttpResponse(std::string &rl, std::vector<std::string> &rq, std::string &rb)
        : _resp_line(rl), _resp_head(rq), _resp_body(rb)
    {
    }

    HttpResponse(std::string &rl, std::string &rb)
        : _resp_line(rl), _resp_body(rb)
    {
    }

    // 序列化
    bool serialize(std::string &out_str)
    {

    }

    ~HttpResponse()
    {

    }
private:
    std::string _resp_line;              // 响应头
    std::vector<std::string> _resp_head; // 响应报头
    std::string _resp_body;             // 响应体
};
```

### 实现`HttpResponse`序列化接口

实现`serialize`就会比实现`deserialize`接口简单，只需要根据对应的字段加上`\r\n`即可，所以基本代码如下：

```c++
// 序列化
bool serialize(std::string &out_str)
{
    // 给请求行添加\r\n
    _resp_line += default_sep;
    out_str += _resp_line;

    // 给请求报头的每一个字段加上\r\n
    std::for_each(_resp_head.begin(), _resp_head.end(), [&](std::string &str)
                    {
        str += default_sep;
        out_str += str; });

    // 添加空行
    out_str += default_sep;

    out_str += _resp_body;

    return true;
}
```

### 修改`HttpServer`类

只需要改变`HttpServer`类中的请求处理函数，但是如果要打印反序列的结果就必须提供对应的接口或者在`HttpRequest`类内提供打印函数，本次考虑后者：

```c++
void print()
{
    // 请求行
    LOG(LogLevel::INFO) << "请求行：" << _req_line;
    // 请求报头
    std::for_each(_req_head.begin(), _req_head.end(), [&](std::string& str)
                    { LOG(LogLevel::INFO) << "请求报头：" << str; });
    // 请求体
    LOG(LogLevel::INFO) << "请求体：" << _req_body;
}
```

接着修改`HttpServer`的`handleHttpRequest`函数：

```c++
void handleHttpRequest(SockAddrIn sock_addr_in, int ac_socketfd)
{
    LOG(LogLevel::INFO) << "收到来自：" << sock_addr_in.getIp() << ":" << sock_addr_in.getPort() << "的连接";

    // 获取客户端传来的HTTP请求
    base_socket_ptr bs = _tp->getSocketPtr();
    std::string in_str;
    bs->recvData(in_str, ac_socketfd);
    // 反序列化
    HttpRequest req;
    req.deserialize(in_str);
    // 打印反序列结果
    req.print();

    // 构建HttpResponse返回
    std::string line = "HTTP 1.1 200 OK";
    std::string body = "<h1>Build HttpResponse success</h1>";

    HttpResponse resp(line, body);
    std::string out_str;
    // 序列化
    resp.serialize(out_str);

    LOG(LogLevel::INFO) << out_str;

    bs->sendData(out_str, ac_socketfd);
}
```

### 测试

主函数与上一节一样，测试结果如下：

<img src="2. 深入HTTP序列化和反序列化.assets/87eef67970cad0d241c4063d5989f9bd.jpg">

<img src="2. 深入HTTP序列化和反序列化.assets/image-20250314205018056.png">

从上图可以看到可以成功获取到HTTP请求结果并且正常回复HTTP响应，第一阶段目标完成

## 第二阶段

在第一阶段的基础之上，现在需要对HTTP请求和HTTP响应的每一个字段进行细化，本次不考虑某个字段或者属性是什么含义，只需要将其进行提取即可

### 修改`HttpRequest`类

#### 提取HTTP请求行中的字段

因为HTTP请求行中的每个字段是根据空格进行分隔的，回忆C/C++的输入和输出，默认也是以空白字符进行分隔，所以就可以利用这一点，可以使用C语言的`sscanf()`进行读取，也可以考虑使用C\+\+的stringstream进行

因为需要读取到每个字段，所以需要对应的成员进行接收，这里就使用三个成员`_req_method`、`_req_uri`和`_req_ver`作为补充成员：

```c++
class HttpRequest
{
public:
    // ...

private:
    std::string _req_method;            // 请求方法
    std::string _req_uri;               // 请求资源路径
    std::string _req_ver;               // HTTP请求版本
    // ...
};
```

接着就是实现一个函数用于从`req_line`中提取对应的字段填充`_req_method`、`_req_uri`和`_req_ver`三个成员：

=== "`sscanf`版本"

    ```c++
    // sscanf版本
    bool getContentFromReqLine()
    {
        char method[1024] = {0};
        char uri[1024] = {0};
        char ver[1024] = {0};
        sscanf(_req_line.c_str(), "%s%s%s", method, uri, ver);
        LOG(LogLevel::INFO) << "请求行：" << method << "-" << uri << "-" << ver;
        _req_method = method;
        _req_uri = uri;
        _req_ver = ver;

        return true;
    }
    ```

=== "`stringstream`版本"

    ```c++
    // stringstream版本
    bool getContentFromReqLine()
    {
        std::stringstream ss;
        // 读取到stringstream中
        ss << _req_line;
        // 输出到成员中
        ss >> _req_method >> _req_uri >> _req_ver;
        LOG(LogLevel::INFO) << "请求行：" << _req_method << "-" << _req_uri << "-" << _req_ver;

        return true;
    }
    ```

接下来修改`deserialize`的逻辑：

```c++
bool deserialize(std::string &in_str)
{
    // 截取请求行
    bool getReqLineFlag = parseOneLineFromTotal(in_str, _req_line);
    if (!getReqLineFlag)
    {
        LOG(LogLevel::WARNING) << "反序列化获取请求行失败";
        return false;
    }
    LOG(LogLevel::INFO) << "截取的请求头为：" << _req_line;

    // 填充请求行的字段
    getContentFromReqLine();

    // ...

    return true;
}
```

#### 提取HTTP请求报头中的字段

前面完成了获取到HTTP请求报头中的每一条数据，但是请求报头实际上是`key-value`结构的数据，服务器需要拿到其中的`key`以及`value`进行后续的处理，所以这里就需要分别取出`key`和对应的`value`

为了存储对应的`key`和`value`，可以考虑使用一个哈希表。这里，因为处理每一个每一条报头数据不需要经过`_req_head`过渡，所以可以考虑直接将分割出的字符串传递给处理分隔的函数，在该函数中直接将对应的键值对添加到哈希表即可

!!! note

    每一个键值对字符串以`: `分隔，而不是`:`

首先完成分割逻辑：

```c++
bool getPairFromReqHead(std::string& oneLine)
{
    // 找到分隔符
    auto pos = oneLine.find(default_head_sep);
    // 左侧即为key
    std::string key = oneLine.substr(0, pos);
    // 右侧即为value
    std::string value = oneLine.substr(pos + default_head_sep.size());

    // 插入到哈希表中
    _kv.insert({key, value});

    return true;
}
```

接下来修改`deserialize`和`getReqHeadFromTotal`的逻辑：

=== "`getReqHeadFromTotal`"

    ```c++
    // 获取请求报头
    bool getReqHeadFromTotal(std::string &in_str)
    {
        // 保存以\r\n结尾的一行数据
        std::string oneLine;
        while (true)
        {
            bool getOneLineFlag = parseOneLineFromTotal(in_str, oneLine);

            // 如果getOneLineFlag为true并且oneLine不为空，说明当前行有效，否则代表已经找到了结尾
            if (getOneLineFlag && !oneLine.empty())
            {
                getPairFromReqHead(oneLine);
            }
            // ...
        }

        return true;
    }
    ```

=== "`deserialize`"

    ```c++
    // 反序列化
    bool deserialize(std::string &in_str)
    {
        // ...

        // 截取请求报头
        bool getReqHeadLine = getReqHeadFromTotal(in_str);
        if (!getReqHeadLine)
        {
            LOG(LogLevel::WARNING) << "反序列化获取请求报头失败";
            return false;
        }

        LOG(LogLevel::INFO) << "获取到的请求报头为：";
        std::for_each(_kv.begin(), _kv.end(), [&](std::pair<std::string, std::string> kv){
            LOG(LogLevel::INFO) << kv.first << "-" << kv.second;
        });

        // ...

        return true;
    }
    ```

#### 提取HTTP请求体中的字段

保持和第一阶段的处理方式一样

### 修改`HttpResponse`类

第一阶段的`HttpResponse`类只是使用一个固定的字符串进行序列化再发送给客户端，这个做法明显是不妥的。实际上，对于HTTP响应