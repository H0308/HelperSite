# 深入HTTP序列化和反序列化

本次实现的`HttpServer`类主要完成接收客户端发送的HTTP请求，也就是说，服务器需要根据客户端的HTTP请求回复一个HTTP响应，所以必须要有的方法就是处理请求方法，但是前面已经提到过，HTTP的请求属于结构化的数据，并且这个数据在传递给服务器时就已经做了序列化，服务器需要处理的就是将结构化的数据进行反序列化；同样，服务器处理完毕后还需要发给客户端，所以此处就需要服务器对处理的结果填充到HTTP响应结构对象中再返回给客户端，此处就需要进行序列化

基于上面的原因，与前面[序列化和反序列化与网络计算器](https://www.help-doc.top/Linux/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8.html#_5)一样，需要实现一个协议，包含`HttpRequest`和`HttpResponse`类，用于处理序列化和反序列化

??? "HTTP不是自己做序列化和反序列化吗，为什么上面还需要手动进行序列化和反序列化"

    需要注意的是，HTTP自己做序列化前提是基于一个已经存在的HTTP服务器，首先对于客户端，如果是浏览器，浏览器会自动将传送给服务器的数据进行序列化，此时服务器必须要进行反序列化提取其中的有效内容，同样，因为实现的是HTTP服务器，所以现在的服务器本身不具备任何自动序列化的行为，需要手动去实现，因此实现的`HttpServer`必须将响应给客户端的数据进行序列化再发送给客户端，这样客户端才可以正常获取到HTTP响应中的数据

### 创建`HttpRequest`类

根据前面的基本思路，实现`HttpRequest`类就需要实现对应的反序列化。因为HTTP请求中带有三种数据：

1. 请求行
2. 请求报头
3. 请求体

所以需要定义三个成员分别存放从请求获取到的内容，所以基本结构如下：

```c++
class HttpRequest
{
public:
    HttpRequest()
    {

    }

    // 反序列化
    bool deserialize(std::string& in_str)
    {
        
    }

    ~HttpRequest()
    {

    }
private:
    std::string _req_line;              // 请求行
    std::vector<std::string> _req_head; // 请求报头
    std::string _req_body;              // 请求体
};
```

### 实现`HttpRequest`反序列化接口

在HTTP中的反序列化本质就是根据基本的格式去除掉多余的部分，从而提取出有效的数据放在相应的字段中，所以根据这个思路依次进行提取

#### 截取请求行

首先提取请求行中的数据，根据前面对HTTP请求结构的描述可以知道HTTP请求的请求行以`\r\n`结尾，所以只需要找到第一个`\r\n`，就说明找到了请求行，这里定义一个成员函数用来处理这个逻辑：

```c++
// 获取请求行
bool parseReqLineFromTotal(std::string& in_str)
{
    auto pos = in_str.find(default_sep);
    if(pos == std::string::npos)
    {
        LOG(LogLevel::WARNING) << "未找到请求行";
        return false;
    }

    // 获取到请求行
    _req_line = in_str.substr(0, pos);

    // 从原始字符串中移除请求头和第一个分隔符
    in_str.erase(0, pos + default_sep.size());

    LOG(LogLevel::DEBUG) << "请求行处理后：" << in_str;

    return true;
}
```

这里考虑到后面的请求体也是以`\r\n`结尾，所以考虑将该函数更改为更通用的版本：

```c++
// 截取以\r\n结尾的数据
bool parseOneLineFromTotal(std::string& in_str, std::string& out_str)
{
    auto pos = in_str.find(default_sep);
    if(pos == std::string::npos)
        return false;

    // 获取到截取数据
    out_str = in_str.substr(0, pos);

    // 从原始字符串中移除截取的字符串和对应的分隔符
    in_str.erase(0, pos + default_sep.size());

    return true;
}
```

接着完善反序列化接口：

```c++
// 反序列化
bool deserialize(std::string& in_str)
{
    bool getReqLineFlag = parseOneLineFromTotal(in_str, _req_line);
    if(!getReqLineFlag)
    {
        LOG(LogLevel::WARNING) << "反序列化获取请求行失败";
        return false;
    }
    LOG(LogLevel::INFO) << "截取的请求行为：" << _req_line;
    
    // 未完...
}
```

#### 截取请求报头

截取请求报头的方式与请求行非常类似，无非就是需要多次截取，但是需要考虑截取何时结束。根据HTTP请求体的特点，最后一行就是一个空行，即`\r\n`，所以可以考虑利用这个空行进行处理，具体思路如下：

因为每一次截取都会截取到分隔符之前的内容，所以可以考虑定义一个变量用于接收请求报头的结果，那么根据截取一行的函数的逻辑，只有成功找到了`\r\n`时才会进行截取，而截取的结果不会包含`\r\n`，那么一旦截取的结果是空且找到了`\r\n`，就说明找到了最后一行

根据这个思路，将获取请求报头数据的逻辑放在一个单独的函数中，如下：

```c++
// 获取请求报头
bool getReqHeadFromTotal(std::string &in_str)
{
    // 保存以\r\n结尾的一行数据
    std::string oneLine;
    while (true)
    {
        bool getOneLineFlag = parseOneLineFromTotal(in_str, oneLine);

        // 如果getOneLineFlag为true并且oneLine不为空，说明当前行有效，否则代表已经找到了结尾
        if(getOneLineFlag && !oneLine.empty())
        {
            _req_head.push_back(oneLine);
        }
        else if(getOneLineFlag && oneLine.empty())
        {
            break;
        }
        else
        {
            return false;
        }
    }
    
    return true;
}
```

继续完善反序列化接口：

```c++
// 反序列化
bool deserialize(std::string &in_str)
{
    // ...

    bool getReqHeadLine = getReqHeadFromTotal(in_str);
    if (!getReqHeadLine)
    {
        LOG(LogLevel::WARNING) << "反序列化获取请求报头失败";
        return false;
    }

    LOG(LogLevel::INFO) << "获取到的请求行为：";
    std::for_each(_req_head.begin(), _req_head.end(), [=](int i){
        std::cout << _req_head[i] << std::endl;
    });

    // 未完...
}
```

#### 截取请求体

因为在前面截取请求行和截取请求报头时已经修改了HTTP请求字符串，所以剩下的就是请求体，直接赋值即可：

```c++
// 反序列化
bool deserialize(std::string &in_str)
{
    // ...

    // 获取请求体
    _req_body = in_str;

    return true;
}
```