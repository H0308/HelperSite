# 五种IO模型与Select多路转接

## 何为IO

不论是在前面文件部分，还是后面的网络部分，IO都是非常常见的。但是当时只是简单对IO进行提及，并没有对IO的本质进行介绍。那么到底何为IO？IO全称为输入和输出，而任何一个IO过程都需要涉及到两个过程：

1. 等待
2. 拷贝

所以，此处就可以得出一个关于IO的简单结论：IO实际上是由等待+拷贝两个行为构成的

通过前面对`read`、`write`等接口的学习可以知道一个非常直观的现象：如果写方并没有写入内容，那么读方会进入阻塞；反过来，如果当前写方的缓冲区已满，那么写方也会阻塞。这里的两个阻塞本质上就是等待。对于这种存在一种等待条件的称为**阻塞式IO**，而从等待到不等待或者从不等待到等待本质都属于一种条件的变化，在IO部分，称这一现象为**IO事件**，而一旦条件发生改变（例如从等待变为不等待），那么就称为**IO事件就绪**

## 何为高效IO

从前面学习到的IO可以看到，IO实际上大部分的时间都是在等待而并非拷贝。例如在[Linux进程间通信](https://www.help-doc.top/Linux/17.%20Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/1.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93.html#linux)一节可以看到只有写方写入，读方才可以开始读，而读只是一瞬间的事情，又比如在[UDP编程接口基本使用](https://www.help-doc.top/Linux/22.%20UDP%E7%BC%96%E7%A8%8B/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html#udp)一节可以看到只有客户端写入，服务端才会读取到信息，而其中的读取也是一瞬间的事情，这两个例子最明显的共同点就是读取都必须等待，而拷贝消耗的时间相比于等待消耗的时间非常少。所以，所谓的高效IO**实际上解决的主要矛盾就是减少IO中等待的时间以提高整机的资源利用率**

既然如此，那么有没有可以让等待的时间尽可能减少从而减少IO整体的时间消耗的方式呢？**答案是有**，具体是什么方式在接下来会介绍

## 五种IO模型与对比

在介绍高效的IO方式之前，先了解常见的五种IO模型：

1. 阻塞式IO：在内核将数据准备好之前，系统调用会一直等待。所有的套接字，默认都是阻塞方式。这是比较常见的IO方式。以`read`接口为例，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\1.png">

2. 非阻塞式IO：如果内核已经将数据准备好，直接返回数据；如果内核还未将数据准备好，系统调用仍然会直接返回，并且返回`EWOULDBLOCK`错误码或者`EAGAIN`错误码。但是非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符，这个过程称为**轮询**，这个过程对于CPU来说是较大的浪费，一般只有特定场景下才使用。示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\2.png">

3. 信号驱动式IO：内核将数据准备好的时候，使用`SIGIO`信号通知应用程序进行IO操作

    <img src="32. 五种IO模型与Select多路转接.assets\3.png">

4. 多路转接（也称为多路复用）：进程同时管理多个文件描述符，只要有一个文件描述符有数据就立即通知给进程进行数据读取。以`select`为例，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\4.png">

5. 异步IO：当前一方向另外一放发起IO处理，当前一方不再参与IO行为，当数据准备完毕时，由通知到的一方处理完成（等待+拷贝），再交给发起IO的一方，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\5.png">

下面依次探讨上面的五种IO模型：

首先考虑阻塞式IO和非阻塞式IO，阻塞式IO在进程读取到数据之前会一直阻塞而不会去做其他的事情，非阻塞式IO不会阻塞在IO的过程之中，这个阶段会在做其他事情与检测是否有数据中轮询执行，二者最本质的区别就是一个在卡主等待，另外一个并不会卡主。从这个角度来看，非阻塞式IO的效率的确会比较高，因为进程可以去完成其他的事情，但是实际上，阻塞式IO和非阻塞式IO从当前IO单一过程来看，并没有实际上的效率区别，本质都是需要等待。换句话说，二者的等待时间占比是基本一致的。所以，从IO层面来看，非阻塞式IO并没有比阻塞式IO有很大的IO效率提升，所以理解所谓的「非阻塞式IO效率高」这句话并不是单纯看IO效率，而是看整机效率

接着看第三种方式：信号驱动式IO。这种方式可以理解为是非阻塞式IO的一种升级，非阻塞式IO需要一直轮询检测数据是否就绪，也就是说是否有数据需要自己判断，而信号驱动式IO数据是否就绪由操作系统判断，一旦操作系统发现数据就绪就通过信号通知进程，所以本质信号驱动式IO是**逆转了判断数据就绪的方式，从而减少IO过程中等待的占比时间**，因为等待的一方是操作系统而不是当前进程，所有从当前进程来看IO过程中等待占比时间减少

接着看第四种方式：多路转接。这种方式最大的特点就是一个进程可以持有多个文件描述符，因为在Linux下，一切皆文件，所以拥有多个文件描述符也就意味着可以读取到多个文件描述符中的内容，如果此时当前进程告知发送方只要有数据就向这些文件描述符中的任意一个写入数据，那么整体来看当前进程的等待时间就会减少，因为只要有一个文件描述符有数据，当前进程就会进入数据拷贝，所以多路转接方式中进程更多的时间在做拷贝而不是等待从而效率变高

最后看第五种方式：异步IO。了解异步IO之前，首先区分**同步IO**与**异步IO**，区分二者的方式很简单：判断是否是发起IO行为的进程本身参与IO的任意一个过程（等待或者拷贝），只要参与了任意一种行为，就属于同步IO，否则属于异步IO。很明显，异步IO的核心特点是IO操作和程序逻辑可以并行执行。异步IO特别适合密集型任务和高并发场景

既然有五种IO模型，那么效率最高的是哪一种呢？**第四种：多路转接**。因为异步IO虽然效率高，但是实现起来非常复杂，这就导致实现出的异步IO代码难度高且可维护性并没有多路转接好，另外现在的服务器大部分都是基于Linux，而Linux下的多路转接技术相对容易实现，所以相对多的情况下还是使用多路转接。而其余三种IO方式，与多路转接最大的不同就是**只有一个文件描述符**，能否及时数据的概率始终是取决于对方，而多路转接因为存在多个文件描述符，增加了收到数据的概率，所以此时能否及时处理数据就取决于自己，但是取决于自己就可以保证最大程度上利用CPU资源，所以还是**更推荐多路转接**

## 非阻塞式IO

为了后面更好得理解多路转接，先了解一下阻塞式IO的特点，以下面的代码为例：

```cpp
#include <iostream>
#include <string>
#include <unistd.h>

using namespace std;

int main()
{
    std::string message = "请输入信息：";
    while (true)
    {
        // 先向标准输出中写入数据
        write(1, message.c_str(), message.size());
        char buffer[1024] = {0};
        // 再从标准输入中读取数据
        ssize_t n = read(0, buffer, sizeof(buffer) - 1);
        
        if(n > 0)
            std::cout << buffer << std::endl;
    }
    
    return 0;
}
```

上面的代码是阻塞式IO，实际的效果就是如果用户没有输入，那么控制台就会一直卡在下面的位置：

```
请输入信息：
```

一旦用户输入一条信息，控制台就会打印出对应的信息，之后继续卡在同样的位置

如果需要将上面的阻塞式IO修改为非阻塞式IO可以使用`fcntl`接口，这个接口可以针对特定文件描述符进行操作，就不用再针对某一个接口设置非阻塞，其原型如下：

```c
int fcntl(int fd, int op, ... /* arg */ );
```

该函数有三个参数，第一个参数表示要指定的文件描述符，第二个参数为操作标记，有下面几种值：

- 复制一个现有的描述符（`F_DUPFD`）
- 获得/设置文件描述符标记（`F_GETFD`或`F_SETFD`）
- 获得/设置文件状态标记（`F_GETFL`或`F_SETFL`）
- 获得/设置异步IO所有权（`F_GETOWN`或`F_SETOWN`）
- 获得/设置记录锁（`F_GETLK`、`F_SETLK`或`F_SETLKW`）

第三个参数表示根据对应操作标记需要设置的值

本次因为需要更改是否为阻塞，就需要使用到`F_GETFL`和`F_SETFL`，如果是`F_GETFL`，那么`fcntl`函数对应的文件描述符的状态，表示获取，并且不需要设置第三个参数；如果是`F_SETFL`，则没有返回值，表示设置，如果要设置为非阻塞IO，那么对应的第三个参数设置为`O_NONBLOCK`

基于上面的理论，可以设计出下面的函数：

```cpp
void setNonBlock(int fd)
{
    // 获取当前文件描述符状态
    int stat = fcntl(fd, F_GETFL);
    if(stat < 0)
    {
        std::cerr << "状态错误" << std::endl;
        return;
    }
    // 设置为非阻塞
    fcntl(fd, F_SETFL, stat | O_NONBLOCK);
}
```

接着，设置标准输入为非阻塞：

```cpp
int main()
{
    // ...
    setNonBlock(0);
    while (true)
    {

    }
    // ...
}
```

此时，如果直接运行就会看到控制台一直在打印`请输入信息：`。为了减慢打印速度，可以在循环内部考虑加一个`sleep(1);`：

```cpp
int main()
{
    std::string message = "请输入信息：";
    setNonBlock(0);
    while (true)
    {
        // ...

        sleep(1);
    }
    
    return 0;
}
```

这就已经完成了阻塞IO到非阻塞IO的转变。但是了解这个内容还不够，下面需要再进一步了解读写接口，以`read`为例，`read`接口的返回值如果为正数，那么此时就代表正常读取到的字符个数，如果返回值为0，那么此时就代表写端关闭，但是如果返回值为负数，那么存在两种情况：

1. 内核数据未准备好
2. 读取失败

基于上面的三种返回值，可以修改上面的代码：

```cpp
int main()
{
    std::string message = "请输入信息：";
    setNonBlock(0);
    while (true)
    {
        // 先向标准输出中写入数据
        write(1, message.c_str(), message.size());
        char buffer[1024] = {0};
        // 再从标准输入中读取数据
        ssize_t n = read(0, buffer, sizeof(buffer) - 1);
        
        // 针对三种返回值考虑三种情况
        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
            std::cout << "写端关闭" << std::endl;
        else
            std::cout << "错误" << std::endl;

        sleep(1);
    }
    
    return 0;
}
```

因为此时是非阻塞IO，运行且不输入任何数据就会看到下面的结果：

```
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
...
```

这一结果也印证了如果底层数据还没有准备好，那么`read`接口会直接返回为-1

但是，上面提到了`read`接口返回-1有两种情况，现在就面临着一个问题：既然-1不但代表失败，还代表底层数据没有准备好，而对于数据还没有准备好一般处理逻辑和失败的处理逻辑是不一样的，那么这种情况下如何做出写出不同的处理逻辑？**答案是通过错误码**，在[Linux进程控制](https://www.help-doc.top/Linux/12.%20Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/12.%20Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html#_2)部分提到过库函数如果出错会设置对应的错误码，实际上，除了库函数以外，系统调用出错也会设置对应的错误码，而这个错误码一般记录着最近一次出错的系统调用或者库函数调用的出错信息编号

对于`read`函数来说，如果底层数据还没有准备好，那么错误码会被设置为11，表示`EAGAIN`或者`EWOULDBLOCK`，而不是这两个错误码就说明当前-1代表读取失败，所以进一步修改上面的代码：

```cpp
int main()
{
    // ...
    while (true)
    {
        // ...

        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
        {
            std::cout << "写端关闭" << std::endl;
            break;
        }
        else
        {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                std::cout << "底层数据还没有准备好" << std::endl;
                sleep(1);
                continue;
            }
            else
            {
                std::cout << "错误" << std::endl;
                break;
            }
        }

        sleep(1);
    }
    
    return 0;
}
```

此时再次编译运行上面的代码就可以看到打印的消息变为：

```
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
...
```

对于阻塞IO来说，如果当前陷入内核后被调度，那么调度完成后再次回到上一次的位置依旧会保持阻塞状态，因为对于大部分的IO类系统调用本身就包含了IO事件的判断以及对进程进行挂起的逻辑，但是如果是非阻塞IO，其阻塞状态几乎不存在，但是很有可能处于数据拷贝的状态，如果此时被切换，错误码就会被设置为`EINTR`，一旦收到错误码为`EINTR`，那么就说明此时正常行为被打断，例如拷贝过程，需要上层自行处理这种情况

所以，再次修改上面的代码如下：

```cpp
int main()
{
    // ...
    while (true)
    {
        // ...

        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
        {
            std::cout << "写端关闭" << std::endl;
            break;
        }
        else
        {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                std::cout << "底层数据还没有准备好" << std::endl;
                sleep(1);
                continue;
            }
            else if(errno == EINTR)
            {
                std::cout << "进程中断，请重试" << std::endl;
                sleep(1);
                continue;
            }
            else
            {
                std::cout << "错误" << std::endl;
                break;
            }
        }

        sleep(1);
    }
    
    return 0;
}
```

基于对非阻塞IO的介绍，思考：对于`read`等IO接口来说，什么错误是可接受（可以在运行程序时直接处理）的？**即错误码被设置为`EAGAIN`、`EWOULDBLOCK`或者`EINTR`时**（腾讯C++后端一面）

如果在当前情况下想看第二个分支结果，可以按下键盘的++ctrl+d++，这个快捷键表示终止键盘输入，此时就会看到下面的结果：

```
写端关闭
```

## `select`实现多路转接

在上面已经基本介绍了多路转接的基本原理，基于这个原理，可以推出多路转接的作用：

1. 等待：等待多个文件描述符中的任意一个就绪
2. 通知：一旦某个文件描述符就绪，就通知进程可以开始进行数据拷贝

所以多路转接本质就是IO事件就绪的通知机制

下面结合代码来理解多路转接，在Linux下，实现多路转接可以使用`select`接口，其原型如下：

```c
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
```

该接口一共有五个参数，首先介绍第一个参数和最后一个参数：

对于第一个参数来说，其表示文件描述符的个数，根据官方手册的描述，<a href="javascript:;" class="custom-tooltip" data-title="This  argument  should  be  set to the highest-numbered file descriptor in any of the three sets, plus 1">这个参数的值为三个文件描述符集中最大文件描述符+1</a>，所以想要确定这个值，就必须要遍历三个文件描述符集

对于最后一个参数来说，这是一个输入、输出型参数，其表示等待时间，有三种情况：

1. 阻塞等待：将其设置为`nullptr`，如果有一个文件描述符就绪，`select`就会立即返回
2. 非阻塞等待：将`timeval`结构体中所有字段初始化为0，不论是否有数据就绪，`select`都会立即返回
3. 等待指定时间：分别设置结构体`timeval`中的两个字段值，操作系统会以当前系统时间为起点设置超时时间。此时如果在等待时间内没有数据就绪或者到达指定的之间，那么`select`就会立即返回并将该结构体中的两个字段值设置为0；如果在等待时间内有数据就绪或者到达指定的时间，那么`select`会将该结构体中的两个字段值设置为实际剩余的时间

`timeval`结构体的定义如下：

```c
struct timeval 
{
    time_t      tv_sec;     /* seconds */
    suseconds_t tv_usec;    /* microseconds */
};
```

接下来看剩余的三个参数，但是在具体介绍三个参数的作用之前，先了解一下`fd_set`这个数据类型。`fd_set`表示文件描述符集，其本质是一个位图，但是位图的元素值只能是0或者1，所以`fd_set`要想表示具体的文件描述符就需要借助下标，所以这个位图每一个比特位和对应的位置含义如下：

1. 当前比特位位置表示文件描述符
2. 当前比特位的值表示需要关心当前文件描述符的IO事件

但是，在Linux中`fd_set`底层本质上就是一个数组，其每一个元素类型为`unsigned long`，其原型如下：

```c
#define __FDSET_LONGS	(__FD_SETSIZE/__NFDBITS)

typedef struct {
	unsigned long fds_bits [__FDSET_LONGS];
} __kernel_fd_set;
```

这就意味着在Linux中，每个文件描述符集能管理的文件描述符都是有限的，这就是`select`接口的局限性，所以一般使用`select`接口都是在比较小型的项目中使用。如果要判断当前Linux系统中的`fd_set`位图大小，可以使用下面的代码：

```cpp
#include <iostream>

#include <sys/select.h>

int main()
{
    fd_set fds;
    std::cout << sizeof(fds) * 8 << std::endl;
    
    return 0;
}
```

例如，下面的结果：

```
1024
```

在上面的代码中，之所以要乘以8，是因为`fd_set`本质是对一个数组进行的封装，这个数组中每一个元素是`unsigned long`类型，所以为了计算出每一个比特位，需要将元素个数乘以8

接下来再看`select`的三个参数：

1. `readfds`：表示关心指定文件描述符的读事件，对应的就是关心对应的读缓冲区是否有数据
2. `writefds`：表示关心指定文件描述符的写事件，对应的就是关心对应的写缓冲区是否有空间
3. `exceptfds`：表示关心指定文件描述符的异常事件，对应的就是关心对应的文件描述符是否发生异常

既然这三个参数都是位图，那么必然需要借助位图的相关操作来对这三个参数进行操作，在Linux中提供了下面的接口来对这三个参数进行操作：

```c
void FD_CLR(int fd, fd_set *set); // 移除指定位图中的指定文件描述符
int  FD_ISSET(int fd, fd_set *set); // 判断指定位图中是否存在指定文件描述符
void FD_SET(int fd, fd_set *set); // 添加指定位图中的指定文件描述符
void FD_ZERO(fd_set *set); // 清空指定位图
```

与`select`最后一个参数相同，`select`的前三个参数也是输入、输出型参数，所以在调用`select`接口时，需要先将这三个参数设置为需要关心的文件描述符，在`select`接口中会判断关心的文件描述符是否就绪，如果就绪对应的描述符（下标）对应的比特位就会被置为1，而其他没有就绪的文件描述符对应的比特位就会被置为0，所以在调用`select`接口之后，判断哪些文件描述符就绪，进而进行数据拷贝。例如，以`readfds`为例，在调用`select`接口之前，需要先设置需要关心读的文件描述符，调用完`select`接口之后，如果关心的文件描述符对应的比特位被置为1，就说明当前文件描述符有数据可读

了解完所有参数后，接下来考虑`select`接口的返回值，`select`接口的返回值也有三种情况：

1. 存在文件描述符就绪：返回大于0的值，表示就绪的文件描述符个数
2. 等待失败：返回-1
3. 底层没有文件描述符的数据就绪：返回0

下面创建基于`select`的TCP服务器为例，演示使用`select`接口实现多路转接：

!!! note

    本次利用到了在[介绍HTTP协议基本结构与基本实现HTTPServer](https://www.help-doc.top/Linux/26.%20%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AEHTTP/1.%20%E4%BB%8B%E7%BB%8DHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0HTTPServer/1.%20%E4%BB%8B%E7%BB%8DHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0HTTPServer.html#_6)时封装的`TcpSocket`

首先创建一个`selectServer`类，这个类表示基于`select`的TCP服务器，所以少不了需要用到`TcpSocket`类对象，所以首先考虑`selectServer`中创建一个基类指针成员，并在构造函数的初始化列表中进行初始化，并在构造函数体中调用父类的`BaseSocket`中的`initSocket`接口执行创建、绑定和监听：

```cpp
class SelectServer
{
public:
    SelectServer(uint16_t port = default_port)
        :bs_(std::make_shared<TcpSocket>())
    {
        bs_->initSocket();
    }
private:
    std::shared_ptr<BaseSocket> bs_;
};
```

接着，创建一个函数用于启动服务器。同样，为了更好得表示启动状态一个服务器对象防止重复启动，考虑加上一个成员变量`isRunning_`用于判断当前服务器是否正在运行：

```cpp
class SelectServer
{
public:
    // ...

    void startServer()
    {
        isRunning_ = true;
        while (isRunning_)
        {
            
        }
        isRunning_ = false;
    }
private:
    // ...
    bool isRunning_;
};
```

按照之前的逻辑，下一步就需要开始接收客户端连接，即调用`TcpSocket`中的`toAccept`接口，通过`toAccept`接口的返回值判断是否可以开始读取客户端发送的内容。但是，`toAccept`接口中的`accept`默认是阻塞式等待，这就导致当前进程只能处理一个客户端的请求，所以在之前使用的就是多线程（或者子进程）的方式来解决这个问题

但是，不需要创建多线程或者子进程，只需要使用`select`接口即可完成。具体思路如下：

因为在TCP中，服务端和客户端想要建立连接必须进行三次握手，也就是说，客户端肯定会给服务端发送建立连接的请求，此时的服务端就需要读取对应的请求信息，所以对于监听套接字描述符`_listen_socketfd`来说，需要关注的就是这个套接字上的读事件，所以在`select`接口中需要将`_listen_socketfd`添加到`readfds`中，并且在`select`接口返回时，判断`_listen_socketfd`对应的比特位是否为1，如果为1，就说明有客户端连接请求

根据上面的思路，首先需要再`TcpSocket`中提供一个获取`_listen_socketfd`的方法，同样，为了保证模版的灵活性，这个方法需要先在父类`BaseSocket`中进行声明，再在子类`TcpSocket`中进行定义：

=== "`BaseSocket`类"

    ```cpp
    class BaseSocket
    {
    public:
        //...

        virtual int getListenSocketFd() = 0;
    };
    ```

=== "`TcpSocket`类"

    ```cpp
    class TcpSocket : public BaseSocket
    {
    public:
        //...

        // 获取监听套接字
        int getListenSocketFd() override
        {
            return _listen_socketfd;
        }	
    }
    ```

接着，在`selectServer`中实现`startServer`函数，先以阻塞版本的`select`为例：

```cpp
void startServer()
{
    isRunning_ = true;
    fd_set rfds;
    // 清空读文件描述符集
    FD_ZERO(&rfds);
    // 设置监听套接字到读文件描述符集中
    FD_SET(bs_->getListenSocketFd(), &rfds);
    while (isRunning_)
    {
        // 交给select等待
        // 当前只有一个监听套接字，所以nfds即为监听套接字+1
        // 只关心读事件的文件描述符集
        int n = select(bs_->getListenSocketFd() + 1, &rfds, nullptr, nullptr, nullptr);
        if (n > 0)
        {
            // 监听套接字文件描述符准备完毕
        }
    }
    isRunning_ = false;
}
```

一旦进入`n > 0`的逻辑，此时就可以启动`toAccept`接口进行客户端连接了，封装为一个函数处理这段逻辑：

```cpp
void handler(fd_set& rfds)
{
    if(FD_ISSET(bs_->getListenSocketFd(), &rfds))
    {
        // 存在即可开始获取
        SockAddrIn client;
        int ac_socketfd = bs_->toAccept(std::addressof(client));
    }
}
```

为了验证是否可以获取到客户端，可以在`handler`函数中打印客户端的IP和端口：

```cpp
void handler(fd_set& rfds)
{
    if(FD_ISSET(bs_->getListenSocketFd(), &rfds))
    {
        // ...

        LOG(LogLevel::DEBUG) << "当前接收到了客户端：" << client.getIp() << ":" << client.getPort() << "文件描述符为：" << ac_socketfd;
    }
}
```

编译运行上面的代码，就可以看到不论是多个客户端还是一个客户端，都可以正常获取到每一个客户端建立连接时的IP和端口

但是，如果此时将`select`改为非阻塞版本，就会发现没有客户端可以正常连接上服务器：

```cpp
void startServer()
{
    // ...
    // 非阻塞
    struct timeval t = {0, 0};
    while (isRunning_)
    {
        // 交给select等待
        // 当前只有一个监听套接字，所以nfds即为监听套接字+1
        // 只关心读事件的文件描述符集
        int n = select(bs_->getListenSocketFd() + 1, &rfds, nullptr, nullptr, &t);
        // ...
    }
    isRunning_ = false;
}
```

根据前面的对`select`返回值的分析，如果返回值为0，就说明没有一个文件描述符有数据就绪，基于这个原理，修改代码如下：

```cpp
void startServer()
{
    //...
    while (isRunning_)
    {
        // ...
        if (n > 0)
        {
            // 监听套接字文件描述符准备完毕
            handler(rfds);
        }
        else if(n == 0)
        {
            LOG(LogLevel::INFO) << "没有客户端连接";
        }
    }
    isRunning_ = false;
}
```

再次运行上面的代码，会发现控制台持续在打印`没有客户端连接`，出现这个问题的本质原因就是`select`是非阻塞的。但是为什么会出现有客户端发起连接，但是`select`却没有进入数据就绪的逻辑？下面具体分析上面代码存在的问题：

在`startServer`中，首先设置了对应的`_listen_socketfd`，这符合前面提到的逻辑。但是在`while`循环中，因为`select`的第二个参数是输入、输出型参数，所以在执行`select`时首先是将设置好`_listen_socketfd`交给`select`让其知道需要关心这个文件描述符。因为是非阻塞版本，所以一旦进入`select`，该函数会发现一开始并没有任何客户端连接，从而会立即返回并且**修改提供给`select`的关心读的文件描述符集`rfds`**，这也就意味着，一旦启动服务器，`select`就会将已有的`rfds`修改为全0并且返回0，这就导致两种情况：

1. 返回值为0，一直进入`n == 0`的逻辑
2. `rfds`被修改为全0，之后的循环中交给`select`的`rfds`一直都是全0，导致始终返回0

最后，尽管有客户端连接，但是因为`select`不再监听任何文件描述符，所以永远不会执行`handler`函数，也就无法获取到客户端的连接信息

解决这个问题的方法就是将清空关心读的文件描述符逻辑和设置`_listen_socketfd`到关心读的文件描述符集逻辑全都放到`while`循环中，这样就可以保证每次`select`都能监听到`_listen_socketfd`对应的文件描述符，从而保证可以获取到客户端的连接信息。修改代码如下：

```cpp
void startServer()
{
    isRunning_ = true;
    fd_set rfds;
    // 非阻塞
    struct timeval t = {0, 0};
    while (isRunning_)
    {
        // 清空读文件描述符集
        FD_ZERO(&rfds);
        // 设置监听套接字到读文件描述符集中
        FD_SET(bs_->getListenSocketFd(), &rfds);
        // ...
    }
    isRunning_ = false;
}
```

但是现在还有一个问题，在当前代码中，除了`select`的第二个参数是输入、输出型参数外，最后一个参数也是输入、输出型参数，那么是否也需要将设置`timeval`的逻辑放到`while`循环中呢？**理论上是需要的**，但是此处可以不需要，因为根据`select`处理`timeval`的逻辑，进入`select`后，如果在设定的超时时间内关心的文件描述符集中没有文件描述符就绪，就会返回将`timeval`中每个字段设置为0的结构体对象，此时下一次设置时`t`对象中的值依旧是`{0, 0}`。但是，尽管如此，还是更建议将设置超时时间的逻辑放到`while`循环中。修改代码如下：

```cpp
void startServer()
{
    isRunning_ = true;
    fd_set rfds;
    while (isRunning_)
    {
        // 清空读文件描述符集
        FD_ZERO(&rfds);
        // 设置监听套接字到读文件描述符集中
        FD_SET(bs_->getListenSocketFd(), &rfds);
        // 非阻塞
        struct timeval t = {0, 0};
        // ...
    }
    isRunning_ = false;
}
```

为了更好得显示出打印信息，考虑在`n == 0`的逻辑添加一个`sleep(1)`减少打印的频率，再次运行代码，就可以看到客户端连接成功，并且服务器会打印出客户端的IP和端口信息

既然完成了客户端和服务端的连接，接下来是否可以考虑在`toAccept`的逻辑之后直接接收信息呢？**不可以**，因为`recvData`函数中的`recv`接口默认也是阻塞式的，如果直接接收信息，依旧会出现服务端卡在接收的位置。解决这个问题的方法同样需要借助`select`，下面思考具体的思路：

因为客户端读取本质还是访问对应的文件描述符，所以让`select`除了关心`_listen_socketfd`以外，还需要关心获取到的`ac_socketfd`。但是现在出现了第二个问题，如何将`ac_socketfd`添加到`select`中呢？**借助一个辅助数组**，这个辅助数组的作用就是存储有效的且同类的所有文件描述符，例如以关心读为例，当前辅助数组中就需要存储所有关心读的文件描述符。基于这个思路，首先需要在`SelectServer`类中添加一个成员变量`fds_`，这个成员变量就是辅助数组。此处考虑使用定长数组，这个数组的长度就设置为`fd_set`可以表示的所有文件描述符个数，并且在构造函数中将该数组全部初始化为-1：

```cpp
// 定长数组大小
constexpr int g_fd_array_num = sizeof(fd_set) * 8;

class SelectServer
{
public:
    SelectServer(uint16_t port = default_port)
        : /* ... */
        , fd_array_(std::make_shared<std::array<int, g_fd_array_num>>())
    {
        // ...
        // 数组元素全部初始化为-1
        fd_array_->fill(-1);
    }

    // ...

private:
    // ...
    std::shared_ptr<std::array<int, g_fd_array_num>> fd_array_;
    // ...
};
```

接着，因为要确保`_listen_socketfd`可以成功添加到`select`中，所以在构造中单独设定第一个元素为`_listen_socketfd`：

```cpp
SelectServer(uint16_t port = default_port)
    : /* ... */
    , fd_array_(std::make_shared<std::array<int, g_fd_array_num>>())
{
    // ...

    // 固定第一个元素为监听套接字
    (*fd_array_)[0] = bs_->getListenSocketFd();
}
```

接着，为了将`fd_array_`中的文件描述符添加到`select`中，在每一次`select`之前，都需要遍历`fd_array_`，将其中不为-1的文件描述符添加到`select`中，并且为了设置`select`的第一个参数，需要获取到当前数组的最大值，修改`startServer`函数如下：

```cpp
void startServer()
{
    // ...
    while (isRunning_)
    {
        // 清空读文件描述符集
        FD_ZERO(&rfds);
        // 设置监听套接字到读文件描述符集中
        for (auto &fd : *fd_array_)
            if(fd != -1)
                FD_SET(fd, &rfds);

        int maxVal = 0;
        auto pos = std::max_element(fd_array_->begin(), fd_array_->end());
        if(pos)
            maxVal = *pos;

        // ...

        int n = select(maxVal + 1, &rfds, nullptr, nullptr, &t);
        // ...
    }
    isRunning_ = false;
}
```

接着，为了保证`select`可以正常接收到后续的`ac_socketfd`，需要在`handler`函数中判断监听套接字存在于`rfds`的分支中将获取到的`ac_socketfd`添加到辅助数组中，对应的代码如下：

```cpp
void handler(fd_set& rfds)
{
    if(FD_ISSET(bs_->getListenSocketFd(), &rfds))
    {
        // 存在即可开始获取
        SockAddrIn client;
        int ac_socketfd = bs_->toAccept(std::addressof(client));

        // ...

        // 将获取到的新ac_socketfd添加到辅助数组
        for (auto &fd : *fd_array_)
        {
            if (fd == -1)
            {
                fd = ac_socketfd;
                break;
            }
        }
    }
}
```

添加完之后，下一次`startServer`的`while`循环逻辑中就会添加新的`ac_socketfd`到关心读的文件描述符表中从而被`select`关心

完成上面的逻辑后，服务器就可以考虑处理读取客户端发送的信息。此时在`handler`函数中因为当前`rfds`中不只有监听套接字`_listen_socketfd`，所以需要接着判断：如果当前辅助数组中的元素为不为-1，说明当前获取到一个有效的文件描述符，此时需要判断是否是监听套接字，如果是就执行连接客户端的逻辑，否则就是读写的逻辑。但是只获取到辅助数组中的文件描述符还不够，因为还需要判断当前文件描述符是的确准备好数据的，即判断指定套接字在`rfds`中标记位是否为1。修改代码如下：

=== "`handler`函数"

    ```cpp
    void handler(fd_set &rfds)
    {
        for (auto &fd : *fd_array_)
        {
            if (fd != -1)
            {
                if(fd == bs_->getListenSocketFd())
                {
                    if (FD_ISSET(fd, &rfds))
                    {
                        // 存在即可开始获取
                        SockAddrIn client;
                        int ac_socketfd = bs_->toAccept(std::addressof(client));

                        LOG(LogLevel::DEBUG) << "当前接收到了客户端：" << client.getIp() << ":" << client.getPort() << "文件描述符为：" << ac_socketfd;

                        // 将获取到的新ac_socketfd添加到辅助数组
                        for (auto &fd : *fd_array_)
                            if (fd == -1)
                                fd = ac_socketfd;
                    }
                }
                else 
                {
                    if(FD_ISSET(fd, &rfds))
                    {
                        // 说明是用于读取的套接字
                        std::string buffer;
                        ssize_t n = bs_->recvData(buffer, fd);

                        if(n > 0)
                            LOG(LogLevel::INFO) << "客户端发送了：" << buffer;
                        else if(n == 0)
                        {
                            LOG(LogLevel::INFO) << "客户端退出";
                            fd = -1;
                        }
                        else
                        {
                            LOG(LogLevel::INFO) << "错误";
                            fd = -1;
                        }
                    }
                }
            }
        }
    }
    ```

=== "`recvData`函数"

    ```cpp
    // 接收数据
    ssize_t recvData(std::string &out_data, int ac_socketfd) override
    {
        char buffer[4096] = {0};
        ssize_t ret = recv(ac_socketfd, buffer, sizeof(buffer), 0);
        if (ret > 0)
            out_data = buffer;
        else if(ret == 0)
            close(ac_socketfd);

        return ret;
    }
    ```

此时的`recvData`接口一定不会阻塞，因为只有内核准备好了数据，`select`才会返回大于0的值，此时要么是`_listen_socketfd`，要么就是`ac_socketfd`，同样`toAccept`接口也不会被阻塞

编译运行上面的代码即可发现服务端可以正常收到多个客户端发送的消息

至此就完成了使用`select`的多路转接模式

## `select`的缺陷

## Select多路转接的优缺点
通过上面的实现，可以看出`select`多路转接的优点：

1. 跨平台：`select`接口在各种操作系统上都有实现，包括Windows、Linux、macOS等
2. 简单易用：相比于其他IO模型，`select`的使用相对简单
3. 可以同时监听多个文件描述符，提高了IO效率

但是`select`也存在一些缺点：

1. 文件描述符数量限制：`select`能够监听的文件描述符数量有限，无法处理大量文件描述符的情况
2. 性能问题：每次调用`select`都需要将文件描述符集从用户态拷贝到内核态，当文件描述符数量较多时，这个开销会比较大
3. 遍历开销：`select`返回后，需要遍历所有文件描述符来找出就绪的文件描述符，时间复杂度为$O(N)$