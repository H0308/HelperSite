# 五种IO模型与Select多路转接

## 何为IO

不论是在前面文件部分，还是后面的网络部分，IO都是非常常见的。但是当时只是简单对IO进行提及，并没有对IO的本质进行介绍。那么到底何为IO？IO全称为输入和输出，而任何一个IO过程都需要涉及到两个过程：

1. 等待
2. 拷贝

所以，此处就可以得出一个关于IO的简单结论：IO实际上是由等待+拷贝两个行为构成的

通过前面对`read`、`write`等接口的学习可以知道一个非常直观的现象：如果写方并没有写入内容，那么读方会进入阻塞；反过来，如果当前写方的缓冲区已满，那么写方也会阻塞。这里的两个阻塞本质上就是等待。对于这种存在一种等待条件的称为**阻塞式IO**，而从等待到不等待或者从不等待到等待本质都属于一种条件的变化，在IO部分，称这一现象为**IO事件**，而一旦条件发生改变（例如从等待变为不等待），那么就称为**IO事件就绪**

## 何为高效IO

从前面学习到的IO可以看到，IO实际上大部分的时间都是在等待而并非拷贝。例如在[Linux进程间通信](https://www.help-doc.top/Linux/17.%20Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/1.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93.html#linux)一节可以看到只有写方写入，读方才可以开始读，而读只是一瞬间的事情，又比如在[UDP编程接口基本使用](https://www.help-doc.top/Linux/22.%20UDP%E7%BC%96%E7%A8%8B/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.%20UDP%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html#udp)一节可以看到只有客户端写入，服务端才会读取到信息，而其中的读取也是一瞬间的事情，这两个例子最明显的共同点就是读取都必须等待，而拷贝消耗的时间相比于等待消耗的时间非常少。所以，所谓的高效IO**实际上解决的主要矛盾就是减少IO中等待的时间以提高整机的资源利用率**

既然如此，那么有没有可以让等待的时间尽可能减少从而减少IO整体的时间消耗的方式呢？**答案是有**，具体是什么方式在接下来会介绍

## 五种IO模型与对比

在介绍高效的IO方式之前，先了解常见的五种IO模型：

1. 阻塞式IO：在内核将数据准备好之前，系统调用会一直等待。所有的套接字，默认都是阻塞方式。这是比较常见的IO方式。以`read`接口为例，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\1.png">

2. 非阻塞式IO：如果内核已经将数据准备好，直接返回数据；如果内核还未将数据准备好，系统调用仍然会直接返回，并且返回`EWOULDBLOCK`错误码或者`EAGAIN`错误码。但是非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符，这个过程称为**轮询**，这个过程对于CPU来说是较大的浪费，一般只有特定场景下才使用。示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\2.png">

3. 信号驱动式IO：内核将数据准备好的时候，使用`SIGIO`信号通知应用程序进行IO操作

    <img src="32. 五种IO模型与Select多路转接.assets\3.png">

4. 多路转接（也称为多路复用）：进程同时管理多个文件描述符，只要有一个文件描述符有数据就立即通知给进程进行数据读取。以`select`为例，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\4.png">

5. 异步IO：当前一方向另外一放发起IO处理，当前一方不再参与IO行为，当数据准备完毕时，由通知到的一方处理完成（等待+拷贝），再交给发起IO的一方，示意图如下：

    <img src="32. 五种IO模型与Select多路转接.assets\5.png">

下面依次探讨上面的五种IO模型：

首先考虑阻塞式IO和非阻塞式IO，阻塞式IO在进程读取到数据之前会一直阻塞而不会去做其他的事情，非阻塞式IO不会阻塞在IO的过程之中，这个阶段会在做其他事情与检测是否有数据中轮询执行，二者最本质的区别就是一个在卡主等待，另外一个并不会卡主。从这个角度来看，非阻塞式IO的效率的确会比较高，因为进程可以去完成其他的事情，但是实际上，阻塞式IO和非阻塞式IO从当前IO单一过程来看，并没有实际上的效率区别，本质都是需要等待。换句话说，二者的等待时间占比是基本一致的。所以，从IO层面来看，非阻塞式IO并没有比阻塞式IO有很大的IO效率提升，所以理解所谓的「非阻塞式IO效率高」这句话并不是单纯看IO效率，而是看整机效率

接着看第三种方式：信号驱动式IO。这种方式可以理解为是非阻塞式IO的一种升级，非阻塞式IO需要一直轮询检测数据是否就绪，也就是说是否有数据需要自己判断，而信号驱动式IO数据是否就绪由操作系统判断，一旦操作系统发现数据就绪就通过信号通知进程，所以本质信号驱动式IO是**逆转了判断数据就绪的方式，从而减少IO过程中等待的占比时间**，因为等待的一方是操作系统而不是当前进程，所有从当前进程来看IO过程中等待占比时间减少

接着看第四种方式：多路转接。这种方式最大的特点就是一个进程可以持有多个文件描述符，因为在Linux下，一切皆文件，所以拥有多个文件描述符也就意味着可以读取到多个文件描述符中的内容，如果此时当前进程告知发送方只要有数据就向这些文件描述符中的任意一个写入数据，那么整体来看当前进程的等待时间就会减少，因为只要有一个文件描述符有数据，当前进程就会进入数据拷贝，所以多路转接方式中进程更多的时间在做拷贝而不是等待从而效率变高

最后看第五种方式：异步IO。了解异步IO之前，首先区分**同步IO**与**异步IO**，区分二者的方式很简单：判断是否是发起IO行为的进程本身参与IO的任意一个过程（等待或者拷贝），只要参与了任意一种行为，就属于同步IO，否则属于异步IO。很明显，异步IO的核心特点是IO操作和程序逻辑可以并行执行。异步IO特别适合密集型任务和高并发场景

既然有五种IO模型，那么效率最高的是哪一种呢？**第四种：多路转接**。因为异步IO虽然效率高，但是实现起来非常复杂，这就导致实现出的异步IO代码难度高且可维护性并没有多路转接好，另外现在的服务器大部分都是基于Linux，而Linux下的多路转接技术相对容易实现，所以相对多的情况下还是使用多路转接。而其余三种IO方式，与多路转接最大的不同就是**只有一个文件描述符**，能否及时数据的概率始终是取决于对方，而多路转接因为存在多个文件描述符，增加了收到数据的概率，所以此时能否及时处理数据就取决于自己，但是取决于自己就可以保证最大程度上利用CPU资源，所以还是**更推荐多路转接**

## 非阻塞式IO

为了后面更好得理解多路转接，先了解一下阻塞式IO的特点，以下面的代码为例：

```cpp
#include <iostream>
#include <string>
#include <unistd.h>

using namespace std;

int main()
{
    std::string message = "请输入信息：";
    while (true)
    {
        // 先向标准输出中写入数据
        write(1, message.c_str(), message.size());
        char buffer[1024] = {0};
        // 再从标准输入中读取数据
        ssize_t n = read(0, buffer, sizeof(buffer) - 1);
        
        if(n > 0)
            std::cout << buffer << std::endl;
    }
    
    return 0;
}
```

上面的代码是阻塞式IO，实际的效果就是如果用户没有输入，那么控制台就会一直卡在下面的位置：

```
请输入信息：
```

一旦用户输入一条信息，控制台就会打印出对应的信息，之后继续卡在同样的位置

如果需要将上面的阻塞式IO修改为非阻塞式IO可以使用`fcntl`接口，这个接口可以针对特定文件描述符进行操作，就不用再针对某一个接口设置非阻塞，其原型如下：

```c
int fcntl(int fd, int op, ... /* arg */ );
```

该函数有三个参数，第一个参数表示要指定的文件描述符，第二个参数为操作标记，有下面几种值：

- 复制一个现有的描述符（`F_DUPFD`）
- 获得/设置文件描述符标记（`F_GETFD`或`F_SETFD`）
- 获得/设置文件状态标记（`F_GETFL`或`F_SETFL`）
- 获得/设置异步IO所有权（`F_GETOWN`或`F_SETOWN`）
- 获得/设置记录锁（`F_GETLK`、`F_SETLK`或`F_SETLKW`）

第三个参数表示根据对应操作标记需要设置的值

本次因为需要更改是否为阻塞，就需要使用到`F_GETFL`和`F_SETFL`，如果是`F_GETFL`，那么`fcntl`函数对应的文件描述符的状态，表示获取，并且不需要设置第三个参数；如果是`F_SETFL`，则没有返回值，表示设置，如果要设置为非阻塞IO，那么对应的第三个参数设置为`O_NONBLOCK`

基于上面的理论，可以设计出下面的函数：

```cpp
void setNonBlock(int fd)
{
    // 获取当前文件描述符状态
    int stat = fcntl(fd, F_GETFL);
    if(stat < 0)
    {
        std::cerr << "状态错误" << std::endl;
        return;
    }
    // 设置为非阻塞
    fcntl(fd, F_SETFL, stat | O_NONBLOCK);
}
```

接着，设置标准输入为非阻塞：

```cpp
int main()
{
    // ...
    setNonBlock(0);
    while (true)
    {

    }
    // ...
}
```

此时，如果直接运行就会看到控制台一直在打印`请输入信息：`。为了减慢打印速度，可以在循环内部考虑加一个`sleep(1);`：

```cpp
int main()
{
    std::string message = "请输入信息：";
    setNonBlock(0);
    while (true)
    {
        // ...

        sleep(1);
    }
    
    return 0;
}
```

这就已经完成了阻塞IO到非阻塞IO的转变。但是了解这个内容还不够，下面需要再进一步了解读写接口，以`read`为例，`read`接口的返回值如果为正数，那么此时就代表正常读取到的字符个数，如果返回值为0，那么此时就代表写端关闭，但是如果返回值为负数，那么存在两种情况：

1. 内核数据未准备好
2. 读取失败

基于上面的三种返回值，可以修改上面的代码：

```cpp
int main()
{
    std::string message = "请输入信息：";
    setNonBlock(0);
    while (true)
    {
        // 先向标准输出中写入数据
        write(1, message.c_str(), message.size());
        char buffer[1024] = {0};
        // 再从标准输入中读取数据
        ssize_t n = read(0, buffer, sizeof(buffer) - 1);
        
        // 针对三种返回值考虑三种情况
        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
            std::cout << "写端关闭" << std::endl;
        else
            std::cout << "错误" << std::endl;

        sleep(1);
    }
    
    return 0;
}
```

因为此时是非阻塞IO，运行且不输入任何数据就会看到下面的结果：

```
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
请输入信息：错误
...
```

这一结果也印证了如果底层数据还没有准备好，那么`read`接口会直接返回为-1

但是，上面提到了`read`接口返回-1有两种情况，现在就面临着一个问题：既然-1不但代表失败，还代表底层数据没有准备好，而对于数据还没有准备好一般处理逻辑和失败的处理逻辑是不一样的，那么这种情况下如何做出写出不同的处理逻辑？**答案是通过错误码**，在[Linux进程控制](https://www.help-doc.top/Linux/12.%20Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/12.%20Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html#_2)部分提到过库函数如果出错会设置对应的错误码，实际上，除了库函数以外，系统调用出错也会设置对应的错误码，而这个错误码一般记录着最近一次出错的系统调用或者库函数调用的出错信息编号

对于`read`函数来说，如果底层数据还没有准备好，那么错误码会被设置为11，表示`EAGAIN`或者`EWOULDBLOCK`，而不是这两个错误码就说明当前-1代表读取失败，所以进一步修改上面的代码：

```cpp
int main()
{
    // ...
    while (true)
    {
        // ...

        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
        {
            std::cout << "写端关闭" << std::endl;
            break;
        }
        else
        {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                std::cout << "底层数据还没有准备好" << std::endl;
                sleep(1);
                continue;
            }
            else
            {
                std::cout << "错误" << std::endl;
                break;
            }
        }

        sleep(1);
    }
    
    return 0;
}
```

此时再次编译运行上面的代码就可以看到打印的消息变为：

```
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
请输入信息：底层数据还没有准备好
...
```

对于阻塞IO来说，如果当前陷入内核后被调度，那么调度完成后再次回到上一次的位置依旧会保持阻塞状态，因为对于大部分的IO类系统调用本身就包含了IO事件的判断以及对进程进行挂起的逻辑，但是如果是非阻塞IO，其阻塞状态几乎不存在，但是很有可能处于数据拷贝的状态，如果此时被切换，错误码就会被设置为`EINTR`，一旦收到错误码为`EINTR`，那么就说明此时正常行为被打断，例如拷贝过程，需要上层自行处理这种情况

所以，再次修改上面的代码如下：

```cpp
int main()
{
    // ...
    while (true)
    {
        // ...

        if(n > 0)
            std::cout << buffer << std::endl;
        else if(n == 0)
        {
            std::cout << "写端关闭" << std::endl;
            break;
        }
        else
        {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                std::cout << "底层数据还没有准备好" << std::endl;
                sleep(1);
                continue;
            }
            else if(errno == EINTR)
            {
                std::cout << "进程中断，请重试" << std::endl;
                sleep(1);
                continue;
            }
            else
            {
                std::cout << "错误" << std::endl;
                break;
            }
        }

        sleep(1);
    }
    
    return 0;
}
```

基于对非阻塞IO的介绍，思考：对于`read`等IO接口来说，什么错误是可接受（可以在运行程序时直接处理）的？**即错误码被设置为`EAGAIN`、`EWOULDBLOCK`或者`EINTR`时**（腾讯C++后端一面）