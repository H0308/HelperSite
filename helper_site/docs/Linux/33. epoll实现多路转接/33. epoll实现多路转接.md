# `epoll`实现多路转接

## 本篇介绍

在前面一节已经介绍了`select`和`poll`实现多路转接，但是`select`和`poll`都存在一些缺陷。而二者最大的缺陷就是都需要内核涉及到遍历操作。所以，为了尽可能减少内核的遍历，就需要用到`epoll`实现多路转接

## `epoll`接口介绍

要使用`epoll`实现多路转接，需要经过三个步骤：

1. 创建`epoll`模型
2. 设置需要关心的文件描述符和对应事件
3. 注册关心的文件描述符和事件

根据这三个步骤，分别使用三个不同的接口：

**创建`epoll`模型**

在Linux中，要使用`epoll`实现多路转接，需要使用`epoll_create`函数创建一个`epoll`模型，该函数声明如下：

```c
int epoll_create(int size);
```

尽管该函数存在一个参数，但是在2.6.8内核版本后，该参数已经被忽略，并且内核会使用一个默认值来代替，所以在使用时，该参数可以设置为任意值，一般设置为128或者256

!!! note

    需要注意，尽管`size`可以设置为任意值，但是必须要保证`size`大于0

该函数会返回创建的`epoll`模型对应的文件描述符

**设置需要关心的文件描述符和对应事件**

调用`epoll_create`函数创建好`epoll`模型后，需要使用`epoll_ctl`函数将需要关心的文件描述符和对应的事件添加到`epoll`模型中，该函数声明如下：

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
该函数的第一个参数表示目标`epoll`模型对应的文件描述符，第二个参数表示操作类型，该参数有三种类型：

- `EPOLL_CTL_ADD`：将指定的文件描述符添加到`epoll`模型中
- `EPOLL_CTL_MOD`：修改指定文件描述符对应的事件
- `EPOLL_CTL_DEL`：将指定文件描述符从指定的`epoll`模型中删除

第三个参数表示需要关心的文件描述符，第四个参数表示需要关心的文件描述符对应的事件，该结构定义如下：

```c
union epoll_data 
{
    void     *ptr;
    int       fd;
    uint32_t  u32;
    uint64_t  u64;
};

typedef union epoll_data  epoll_data_t;

struct epoll_event 
{
    uint32_t      events;  /* Epoll events */
    epoll_data_t  data;    /* User data variable */
};
```

在`epoll_event`结构中，第一个字段表示文件描述符对应的事件，有下面的几种类型：

- `EPOLLIN`：表示关心文件描述符的读事件
- `EPOLLOUT`：表示关心文件描述符的写事件
- `EPOLLET`：表示以边沿触发的方式进行事件通知
- `EPOLLONESHOT`：表示文件描述符只能触发一次事件
- `EPOLLRDHUP`：表示文件描述符对应的连接被对方关闭
- `EPOLLPRI`：表示文件描述符对应的连接有紧急数据可读
- `EPOLLERR`：表示文件描述符对应的连接发生错误
- `EPOLLHUP`：表示文件描述符对应的连接被挂断

第二个字段表示文件描述符对应的用户数据，一般使用`fd`字段来表示文件描述符

**注册关心的文件描述符和事件**

在调用`epoll_ctl`函数将需要关心的文件描述符和对应的事件添加到`epoll`模型中后，就可以使用`epoll_wait`函数来等待事件的发生，该函数声明如下：

```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

该函数的第一个参数表示目标`epoll`模型对应的文件描述符，最后一个参数的设置与`poll`一致，此处不再赘述。接着，第二个参数和第三个参数共同表示一个数组，与`poll`类似，`struct epoll_event *events`表示数组的第一个元素的地址，`maxevents`表示数组的元素个数。但是需要注意的是，这里的第二个参数并不是输入型参数，而是一个输出型参数，该数组中存储的是对应事件已经就绪的文件描述符，而因为事件可能不止一个，也有可能有很多个，所以需要`maxevents`来控制一次最多可以获取到的事件个数

该函数的返回值与`poll`一样，因为返回值大于0决定了具体就绪的文件描述符的个数，所以遍历就绪文件描述符数组`events`时需要用到该返回值

## 从接口层面对比`epoll`与`select`和`poll`

根据上面的接口介绍，可以看到`epoll`与`select`和`poll`最大的区别就在于接口的个数上，`epoll`只有三个接口，而`select`和`poll`根据前面的使用只有一个接口，而`epoll`三个接口中的后两个分别表示不同的功能：「用户需要内核关心的文件描述符和对应的事件」以及「内核告诉用户有哪些事件已经就绪」，所以从接口层面来看，`epoll`将这两个操作分离，使得操作变得更加清晰

## `epoll` 原理

虽然上面已经对`epoll`实现多路转接需要用到的接口进行了介绍，但是其中还涉及到一些更加细节的问题无法通过接口的声明来描述，所以除了需要知道`epoll`需要用的到的接口外，还需要了解`epoll`的实现原理

<!-- 下面的内容可能需要迁移，迁移起始 -->

在前面不论是编写UDP服务器和编写TCP服务器第一步都需要创建套接字，而这个套接字本质还是一个文件描述符，那么文件描述符是如何与套接字产生关联的？

为了解决这个问题，首先需要看`struct file`结构，该结构定义如下：

```c
struct file {
	union {
		struct list_head	fu_list;
		struct rcu_head 	fu_rcuhead;
	} f_u;
	struct dentry		*f_dentry;
	struct vfsmount         *f_vfsmnt;
	const struct file_operations	*f_op;
	atomic_t		f_count;
	unsigned int 		f_flags;
	mode_t			f_mode;
	loff_t			f_pos;
	struct fown_struct	f_owner;
	unsigned int		f_uid, f_gid;
	struct file_ra_state	f_ra;

	unsigned long		f_version;
	void			*f_security;

	/* needed for tty driver, and maybe others */
	void			*private_data;

#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct list_head	f_ep_links;
	spinlock_t		f_ep_lock;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
};
```

在该结构中有一个指针`private_data`，这个指针的类型是`void *`，所以可以指向任意类型的数据。在网络部分，一旦创建了套接字，那么就会创建一个`struct socket`结构，该结构定义如下：

```c
struct socket {
	socket_state		state;
	unsigned long		flags;
	const struct proto_ops	*ops;
	struct fasync_struct	*fasync_list;
	struct file		*file;
	struct sock		*sk;
	wait_queue_head_t	wait;
	short			type;
};
```

而要实现文件描述符与套接字的关联，就需要将`struct socket`结构体对象的地址赋值给`struct file`结构的`private_data`指针

另外，在`struct socket`结构中，存在着一个成员`struct sock *sk`，这个成员表示具体的某一个套接字类型，既可以是UDP套接字也可以是TCP套接字，该类型的定义如下：

```c
struct sock 
{
	struct sock_common	__sk_common;
#define sk_family		__sk_common.skc_family
#define sk_state		__sk_common.skc_state
#define sk_reuse		__sk_common.skc_reuse
#define sk_bound_dev_if		__sk_common.skc_bound_dev_if
#define sk_node			__sk_common.skc_node
#define sk_bind_node		__sk_common.skc_bind_node
#define sk_refcnt		__sk_common.skc_refcnt
#define sk_hash			__sk_common.skc_hash
#define sk_prot			__sk_common.skc_prot
	unsigned char		sk_shutdown : 2,
				sk_no_check : 2,
				sk_userlocks : 4;
	unsigned char		sk_protocol;
	unsigned short		sk_type;
	int			sk_rcvbuf;
	socket_lock_t		sk_lock;
	wait_queue_head_t	*sk_sleep;
	struct dst_entry	*sk_dst_cache;
	struct xfrm_policy	*sk_policy[2];
	rwlock_t		sk_dst_lock;
	atomic_t		sk_rmem_alloc;
	atomic_t		sk_wmem_alloc;
	atomic_t		sk_omem_alloc;
	struct sk_buff_head	sk_receive_queue;
	struct sk_buff_head	sk_write_queue;
	struct sk_buff_head	sk_async_wait_queue;
	int			sk_wmem_queued;
	int			sk_forward_alloc;
	gfp_t			sk_allocation;
	int			sk_sndbuf;
	int			sk_route_caps;
	int			sk_gso_type;
	int			sk_rcvlowat;
	unsigned long 		sk_flags;
	unsigned long	        sk_lingertime;

	struct {
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	struct sk_buff_head	sk_error_queue;
	struct proto		*sk_prot_creator;
	rwlock_t		sk_callback_lock;
	int			sk_err,
				sk_err_soft;
	unsigned short		sk_ack_backlog;
	unsigned short		sk_max_ack_backlog;
	__u32			sk_priority;
	struct ucred		sk_peercred;
	long			sk_rcvtimeo;
	long			sk_sndtimeo;
	struct sk_filter      	*sk_filter;
	void			*sk_protinfo;
	struct timer_list	sk_timer;
	struct timeval		sk_stamp;
	struct socket		*sk_socket;
	void			*sk_user_data;
	struct page		*sk_sndmsg_page;
	struct sk_buff		*sk_send_head;
	__u32			sk_sndmsg_off;
	int			sk_write_pending;
	void			*sk_security;
	void			(*sk_state_change)(struct sock *sk);
	void			(*sk_data_ready)(struct sock *sk, int bytes);
	void			(*sk_write_space)(struct sock *sk);
	void			(*sk_error_report)(struct sock *sk);
  	int			(*sk_backlog_rcv)(struct sock *sk,
						  struct sk_buff *skb);  
	void                    (*sk_destruct)(struct sock *sk);
};
```

在这个结构中就存在着UDP和TCP需要用到的缓冲区成员

如果看得到UDP套接字和TCP套接字的相关结构定义：

=== "UDP套接字"

    ```c
    struct udp_sock 
    {
        /* inet_sock has to be the first member */
        struct inet_sock inet;
        // ...
    };
    ```

=== "TCP套接字"

    ```c
    struct inet_connection_sock 
    {
        /* inet_sock has to be the first member! */
        struct inet_sock	  icsk_inet;
        // ...
    };

    struct tcp_sock 
    {
        /* inet_connection_sock has to be the first member of tcp_sock */
        struct inet_connection_sock	inet_conn;
        // ...
    }
    ```

可以发现，在`tcp_sock`结构和`udp_sock`中都存在着一个成员`struct inet_sock inet`，在这个类型中：

```c
struct inet_sock {
	/* sk and pinet6 has to be the first two members of inet_sock */
	struct sock		sk;
    // ...
};
```

第一个成员就是`struct sock`类型，所以可以得出下图：

<img src=/>

这就是在网络套接字部分实现的继承和多态，这一点在前面[操作系统管理System V标准中三种资源的方式](https://www.help-doc.top/Linux/17.%20Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/4.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86System%20V%E6%A0%87%E5%87%86%E4%B8%AD%E4%B8%89%E7%A7%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%96%B9%E5%BC%8F/4.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86System%20V%E6%A0%87%E5%87%86%E4%B8%AD%E4%B8%89%E7%A7%8D%E8%B5%84%E6%BA%90%E7%9A%84%E6%96%B9%E5%BC%8F.html#system-v)也有类似的结构形式

<!-- 迁移结束 -->

