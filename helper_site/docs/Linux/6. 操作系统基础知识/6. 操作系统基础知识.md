# 操作系统基础

## 冯诺依曼体系结构介绍

冯诺依曼体系结构如下：

<img src="6. 操作系统基础知识.assets\image.png">

在上图中「输入设备」和「输出设备」一般被称为计算机的外设，而「存储器」在冯诺依曼体系结构中表示「内存」

输入设备一般包括：网卡、磁盘、键盘、触摸屏等

输出设备一般包括：网卡、磁盘、鼠标、触摸屏、显示器（非触摸屏）等

- 内存的作用

「内存」是中央处理器与计算机其他设备的桥梁，因为CPU的处理速度相当得快，以至于如果没有「内存」，就会导致类似「磁盘」等外设因为其速度远远小于CPU从而拖慢整机性能

「内存」本质不永久存储任何数据，其速度快于「磁盘」，但慢于CPU，当需要进行数据的读取时，首先数据会从「输入设备」上读取数据到内存中，再从「内存」到CPU进行相关处理，如果处理完的数据需要写入到输出设备时，此时CPU会将数据写入「内存」，再从「内存」写入到输出设备

- 内存or磁盘

「内存」虽然速度不快也不慢，但是「内存」并不可以直接替代硬盘的位置，首先CPU也不可以直接从「硬盘」读取数据，其次「内存」中的数据断电后就会消失（属于易失性存储器，volatile storage），而「硬盘」中的数据会在生命周期内永久保存（属于非易失性存储器，nonvolatile storage）

- 计算机中的存储设备

在计算机中，有下面的存储金字塔结构：

<img src="6. 操作系统基础知识.assets\image1.png">

根据上图描述，速度最快但价格最高的存储器属于「易失性存储器」，称为「寄存器（registers）」，其次是「缓存（cache）」，最后一个易失性存储器就是「内存（main memory）」，接着就是非易失性存储器，这种存储器的特点就是断电之后数据仍然还在，排在内存下方最近的一个就是NVM（Nonvolatile Memory）存储器，在现在的计算机中，NVM存储器最常见的一种就是闪存（固态硬盘属于其一），其次还有电可擦可编程只读存储器（EEPROM）和铁电随机存取存储器（FRAM, Ferroelectric Random Access Memory），其次就是「硬盘（hard-disk drives）」，硬盘在与NVM存储器同等存储容量的情况下，一般造价比NVM存储器低，但是其速度也相对较慢，排在第三层存储的存储器分别是「光盘（optical disk）」和「磁带（magnetic tapes）」，但是现在对于这二者的需求已经没有曾经普遍

- 网卡...输出or输入设备

从宏观的角度来看，许多人认为网卡是输入设备，因为我们需要使用网卡来接收网络信号（例如Wi-Fi），但其实网卡即是输出设备也是输入设备

例如：当一个人通过电脑上的聊天平台软件（例如QQ、微信等）向另一个人发送消息，在这一过程中网卡就扮演着输出和输入设备两个角色

- 对于发送者来说，发送者在其电脑打开聊天平台软件，该软件的相关代码和数据就会从「磁盘」加载进入「内存」，CPU从「内存」中读取代码转换成指令执行程序，此时发送者将其想发送的消息输入到聊天软件文本框后点击发送，此时CPU会将数据写入「内存」，再由「内存」中的软件将发送的消息写入到「网卡」，通过「网卡」发送到网络。此过程中「网卡」就是输出设备
- 对于接受者来说，当接受者打开聊天平台软件，该软件的相关代码和数据就会从「磁盘」加载进入「内存」，CPU从「内存」中读取代码转换成指令执行程序，「网卡」设备从网络接收数据，此时「网卡」设备就是输入设备，「网卡」将其读取到的信息加载到「内存」，由对应的聊天软件接收并由CPU进行处理，再发送给「内存」，由「内存」写入显示器显示到接受者的显示器上

通过上面的例子和介绍，可以基本了解到，计算机中的数据流转实际上是数据在各种设备间的来回拷贝，而拷贝的效率基本可以认为就是计算机的效率

## 操作系统基本认知

操作系统本质是通过对计算机硬件的管理从而达到用户可以更高效、便利地使用计算机。用户可以通过操作系统提供的接口方便得操作计算机硬件，例如写文档等。

下面从两个方面浅谈一下可以人机交互的操作系统（不包括嵌入式计算机embedded computers的系统）

1. 系统层面：从计算机的角度来看，操作系统是与硬件联系最紧密的软件，而这其中最重要的就是操作系统内核，计算机在解决一个问题时需要一些资源，例如：CPU时间、内存空间、存储空间、I/O设备等，而操作系统在这一过程中扮演的角色更像是一个管理者，管理计算机硬件之间的交流和资源
2. 用户层面：前面提到对于用户来说，操作系统提供了接口便于用户操作计算机硬件。用户所看到的计算机可以简单理解为一个屏幕、一个键盘和一个鼠标，当需要使用计算机时，对应的操作使用对应的设备即可，此时操作系统对于用户来说更多得是为了用户更好的使用体验，所以这一层面上，一款操作系统的好坏取决于用户的使用感受

操作系统在整个计算机的组成中所处的位置如下图所示：

<img src="6. 操作系统基础知识.assets\image2.png">

下面从这两个层面切入，具体谈操作系统的地位：

- 系统层面：操作系统提供手段管理计算机硬件

**-> 操作系统通过驱动管理硬件**

从系统层面，首先从对于底层硬件来说，计算机中所有的硬件都需要对应的驱动，而操作系统管理这些硬件的方式就是通过对应的驱动。前面提到，操作系统在管理硬件时更像是一个管理者的角色，那么为了能够管理计算机硬件，操作系统就会做出决策（类似于一个管理者发号施令），通知对应的驱动，驱动根据操作系统的决策执行对相关硬件进行管理。

**-> 操作系统采用数据结构管理驱动**

但是这一过程中存在一个问题，那就是如果硬件数量大，需要的驱动数量也就会变大，那么操作系统直接对所有驱动进行管理就会影响整体的效率，为了解决这个问题，操作系统采用了一种抽象的思路，即将同类型的设备进行归类，因为同类型的设备驱动基本上都有某些共同的特点，所以此时可以考虑将共性字段抽取，放在一个结构体中，每一个结构体中根据驱动自己的值填写到对应结构体的字段中，而操作系统只需要使用一种数据结构，将所有驱动对应的结构体进行链接管理即可

例如，假设操作系统使用的数据结构是链表，那么操作系统针对于每一种功能管理（例如驱动管理）只需要一个头结点，具体类型的驱动对应的结构体依次进行链接，在需要某一种驱动时，只需要依次遍历该链表即可拿到对应的驱动进行相关的进行决策与操作执行

**-> 先描述，再组织**

从上面的例子可以看出，操作系统要管理一种硬件，最优的解决方案就是先抽象出该驱动的特点，将其归类到某一种驱动结构体，该结构体再通过相关数据结构的特点进行链接，最后通过对应的数据结构进行管理。这一过程也可以被概括为：先描述，再组织

对于操作系统的其他管理，例如内存管理、进程管理等也是使用类似的方式

**-> 数据结构与面向对象的重要性**

从这一过程也可以看出，之所以要有数据结构，也是为了更好得管理数据，而之所以需要面向对象，也是为了抽取零散数据的共性从而达到更方便的管理

- 用户层面：操作系统提供接口方便用户使用

用户使用操作系统，操作系统必须提供功能，但是操作系统不能完全将自己暴露给用户，否则会导致整机出现问题，所以操作系统需要满足两个特点：封闭且开放

封闭：表示操作系统的内核对于用户来说必须是封闭的

开放：表示操作系统必须提供合适的结构给用户使用

操作系统具有的部分如下图所示：

<img src="6. 操作系统基础知识.assets\image3.png">

前面已经提到了内核中操作系统的地位，接下来考虑系统调用接口

系统调用接口是操作系统开放性的最根本的体现，因为这个接口与操作系统内核最接近，这种接口在使用层面上也会更加繁琐，学习成本也会更高，更加需要使用者深入了解操作系统，而为了降低这种学习和使用上的成本，系统调用接口外还有一种接口称为：用户操作接口，这种接口一般是对底层系统调用接口进行一定的封装，便于使用者调用，例如C语言中的`fopen`函数封装了`open`函数等，图形化界面也属于用户操作接口，因为图形化界面本质是操作对应指令，而指令被操作系统接收就是执行对应的操作，也就间接调用系统接口

## 进程介绍

进程的本质是在计算机内存中运行的程序，但是这一个概念太过于广泛

要了解进程，首先采用前面使用到的思想「先描述，再组织」，每一个进程本质也是一个结构（一般称为PCB，在Linux下称为task_struct），计算机将程序加载到内存，就会在内存中添加一个进程，那么此时就会形成一个结构体，该结构体中存在进程的一些描述，例如进程的在内存中的位置、进程的编号、对应数据和代码的地址等，在程序执行前，进程会被排列到一个数据结构，通过操作系统调度器从数据结构中取出进程就代表对应的进程获取到CPU的使用权，此时就会通过对应进程的结构体中的相关数据加载代码和数据进行运算、逻辑处理，从而到达执行程序的效果

这一过程可以看出，进程=程序代码和数据+进程结构体