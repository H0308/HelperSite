# 消息队列与信号量

## 消息队列

遵循System V标准的进程通信除了共享内存外还有消息队列，消息队列从其字面意思就是传递消息的一个队列。实际上，其作用与队列也是非常像的，但是它并不是语言的中间件

消息队列与共享内存不同的是，消息队列可以同时让两个进程既可以从消息队列中读取数据，也可以向消息队列中写入数据，只不过进程读取数据时读取到的是另外一个进程写入的数据，而不是自己本身的数据，所以为了对消息队列中的数据作区分，除了数据本身外，还需要一个数据标识区分是哪一个进程写入的对应数据，示意图如下：

<img src="3. 消息队列和信号量.assets/image-20250112213333879.png" alt="image-20250112213333879" />

与共享内存类型，如果需要查看用户创建的消息队列，可以使用下面的指令：

```shell
ipcs -q
```

如果需要释放用户创建的消息队列，可以使用下面的指令：

```shell
ipcrm -m 消息队列唯一标识符
```

## 消息队列相关接口

与共享内存一样，消息队列也有自己的接口，但是其接口与共享内存非常相似，使用方式也非常类似，所以下面仅仅是对接口进行描述，具体使用方式参考[共享内存](https://www.help-doc.top/Linux/com-process/com-named-pipe-shm/com-named-pipe-shm.html#_6)

**申请消息队列**

共享内存使用`shmget`，消息队列对应着就是`msgget`：

```c
int msgget(key_t key, int msgflg);
```

该接口第一个参数传递一个`key`，表示消息队列的编号，获取方式与共享内存一致，使用`ftok`根据项目路径和项目ID创建，第二个参数表示标记，同样有两种情况：

1. `IPC_CREAT`：如果单独使用`IPC_CREAT`，那么就代表如果指定的消息队列不存在就创建，否则就使用已有的消息队列
2. `IPC_EXCL`：单独使用无意义，但是一般配合`IPC_CREAT`可以实现当指定的消息队列不存在时就创建，否则就报错

同样，除了使用上面两个宏外，还需要使用文件权限，确保申请的消息队列可以使用

**使用消息队列**

进程想使用一个消息队列无非就是对消息队列进行读写操作，所以对应的接口如下：

使用`msgsnd`表示向一个消息队列中发送一个数据包：

```c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

该接口的第一个参数传递消息队列唯一标识符（同共享内存唯一标识符），第二个参数传入数据包，数据包的结构定义如下：

```c
struct msgbuf {
    long mtype;       /* message type, must be > 0 */
    char mtext[1];    /* message data */
};
```

在该结构中，第一个参数表示消息类型，第二个参数是一个[柔性数组](https://www.help-doc.top/c-lang/dynamic-memory/dynamic-memory#_7)，用于存储具体的数据

接口的第三个参数表示数据包的大小，第四个参数表示传递的标记，一般情况下不会使用到，所以传递0即可

在消息队列中，有写入就有读取，读取的接口为`msgrcv`：

```c
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

第一个参数表示消息队列唯一标识符，第二个为输出型参数，用于存储读取到的数据，第三个参数表示一次读取的数据大小，第四个参数表示读取哪一种数据（即哪一个进程写的数据），第五个参数依旧传递0

**释放消息队列**

在共享内存中使用`shmctl`，对应得在消息队列中使用`msgctl`：

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

接口的第一个参数传递消息队列唯一标识符，第二个参数表示操作标记，与共享内存一样，如果需要销毁消息队列，使用的标记为`IPC_RMID`，第三个参数表示用于存储消息队列相关信息的结构，不使用时传递`NULL`即可

## 信号量

在前面提到，当一个进程需要访问一个资源，并且这个资源在同一时刻只能被一个进程访问，那么就称这个资源为临界资源或者互斥资源，这个资源为了保证只能被一个进程访问就需要做出相应的保护操作，常见的保护操作有：互斥+同步，互斥就是「有你没我，有我没你」，同步就是保证进程访问资源具有顺序性，之所以要同步，是因为操作系统中的进程在运行时都是异步的，这也是操作系统有异步特性的原因之一

一个进程之所以会访问临界资源，是因为其代码中含有访问临界资源的代码，这段代码也被称为临界区，根据这个特点，进程代码也可以分为两部分：非临界区（没有访问临界资源的代码）+临界区（访问临界资源的代码），示意图如下：

<img src="3. 消息队列和信号量.assets\Snipaste_2025-01-12_22-21-12.png" style="zoom:50%">

前面提到的共享内存使用时是一个进程写入，一个进程读取，如果共享内存比较大，但是每次交互的数据比较小就会造成资源浪费，考虑将这个资源划分成多个小份资源，每个进程依次向指定的小块空间中写入，对应的每个进程依次从指定的小块空间中读取就可以做到更高效得利用共享内存（即不同进程在访问共享资源时可以具有一定的并发性），即下图所示：

<img src="3. 消息队列和信号量.assets\Snipaste_2025-01-12_22-26-56.png">

但是这样的操作有个问题，每一整个共享内存划分成小块空间一定会有个数限制，也就是说，共享内存中的小块空间个数是有限的，例如上图中小块共享内存的个数为24个，如果此时有25个进程访问这写小块空间，势必会出现至少两个进程资源竞争问题，所以此时就需要一个计数器来表示当前共享内存中的小块资源个数，根据这个资源个数实现有限个数个进程访问，多余进程等待的思路伪代码如下：

1. `if(count > 0){count--;} else {超出count的进程 wait;}`
2. `使用共享资源的一个进程 quit; count++;`

在上面的伪代码中，用于控制资源的计数器就可以理解为是信号量，当进程需要访问资源时就不是先申请资源，而是先申请信号量，如果信号量大于0，那么进程可以申请到对应的资源，否则就会处于等待状态直到`count`重新大于0

!!! note

    特殊地，如果资源只有一份，此时信号量只会有两种变化，即0或者1，这种信号量就被称为二元信号量

使用信号量就可以对有限的临界资源进行保护，但是信号量本身就会面临着下面的问题：

1. 信号量需要被多个进程看到
2. 信号量需要保证自己本身被保护

所以为了保证信号量的安全，首先第一个问题就是让信号量变为共享资源，从而做到任意进程都可以看到信号量这个资源，其次就是访问信号量的操作必须是安全的，所以对于信号量的操作都是原子性操作，对应地称申请信号量操作为`P`操作，进程退出恢复信号量操作为`V`操作

了解了何为信号量以及信号量的操作后，下面介绍在Linux中的信号量

与共享内存、消息队列一样，信号量不会随进程，而是随操作系统，所以进程退出之前需要释放信号量，或者使用命令手动释放信号量，对应地：

使用下面的指令可以查看用户创建的信号量：

```shell
ipcs -s
```

使用下面的指令可以释放用户创建的信号量：

```shell
ipcrm -s 信号量唯一标识符
```

## 信号量相关接口

与共享内存、消息队列一样，信号量也有自己的接口，但是其接口与二者非常相似，使用方式也非常类似，所以下面仅仅是对接口进行描述，具体使用方式参考[共享内存](https://www.help-doc.top/Linux/com-process/com-named-pipe-shm/com-named-pipe-shm.html#_6)

**申请信号量**

在Linux中，用户申请的信号量并不是按照单个为单位，而是按照多个为单位，即信号量集，而操作系统需要对这一类的信号量进行管理就需要有对应的结构，在使用接口时申请信号量就需要指定信号量集中信号量的个数，对应地使用下面的接口申请信号量：

```c
int semget(key_t key, int nsems, int semflg);
```

接口中的第一个参数表示信号量集在系统中的编号，同样使用`ftok`根据项目路径和项目ID获取，第二个参数表示信号量集中的信号量个数，第三个参数和共享内存以及消息队列一样：

1. `IPC_CREAT`：如果单独使用`IPC_CREAT`，那么就代表如果指定的信号量集不存在就创建，否则就使用已有的消息队列
2. `IPC_EXCL`：单独使用无意义，但是一般配合`IPC_CREAT`可以实现当指定的信号量集不存在时就创建，否则就报错

同样，除了使用上面两个宏外，还需要使用文件权限，确保申请的信号量集可以使用

**操作信号量**

在Linux中操作信号量可以使用`semop`接口：

```c
int semop(int semid, struct sembuf *sops, size_t nsops);
```

接口中的`semid`表示信号量集唯一标识符，第二个参数表示操作集，其为一个数组，每一个元素为`sembuf`结构体指针类型，对于该结构体，其定义如下：

```c
struct sembuf
{
    unsigned short sem_num;  /* semaphore number */
    short          sem_op;   /* semaphore operation */
    short          sem_flg;  /* operation flags */
}
```

在该结构体中，第一个成员表示信号量集中指定信号量的编号，因为信号量集本身是一个数组，所以这个成员就是数组下标，第二个成员为操作标记，其中-1表示信号量`P`操作，1表示信号量`V`操作，第三个成员传递0即可

接口第三个参数即为信号量集中信号量的个数，即信号量数组的元素个数

**释放信号量**

在共享内存中使用`shmctl`，在消息队列中使用`msgctl`，对应地在信号量中使用`semctl`：

```c
int semctl(int semid, int semnum, int op, ...);
```

接口中的第一个参数表示信号量唯一标识符，第二个参数表示信号量集中指定的信号量下标，第三个为操作标记，对应释放的标记依旧为`IPC_RMID`。一般情况下，只需要传递这三个参数

注意，如果函数需要传递四个参数，那么必须创建下面的联合体，并将其作为接口的第四个参数：

```c
union semun {
    int              val;    /* Value for SETVAL */
    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
    unsigned short  *array;  /* Array for GETALL, SETALL */
    struct seminfo  *__buf;  /* Buffer for IPC_INFO
                                (Linux-specific) */
};
```