<script defer src="/javascripts/waline.min.js"></script>
<link rel="stylesheet" href="https://help-site.oss-cn-hangzhou.aliyuncs.com/css/waline.css" />
<link rel="stylesheet" href="/stylesheets/waline.min.css" />

# 回溯理论基础

!!! abstract

    本篇文章中部分内容引用自[代码随想录](https://programmercarl.com/)

## 什么是回溯法

回溯法也可以叫做回溯搜索法，它是一种搜索的方式

在二叉树时也涉及到了一些回溯的题目，例如[力扣257：二叉树的所有路径](https://www.help-doc.top/algorithm/recursion-binary-tree/binary-tree-basic/binary-tree-basic.html#257)

实际上，回溯是递归的副产品，只要有递归就会有回溯

## 回溯法的效率

**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。**因为回溯的本质是穷举，穷举所有可能，然后选出想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。尽管其效率并不算优秀，但是在解决一些问题时却是唯一选择

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

!!! note "排列和组合"

    **组合是不强调元素顺序的，排列是强调元素顺序**
    
    例如：{1, 2}和{2, 1}在组合上，就是同一个集合，因为不强调顺序，所以在求解组合相关的问题时，首先要考虑的就是从当前元素的下一个位置开始搜索从而去掉之前已经出现的类似情况，例如[力扣77.组合](#)，部分题目可能说明可以出现重复元素，此时要结合前面的组合规则修改对应的逻辑，例如[力扣39.组合总和](#)
    
    要是排列的话，{1, 2}和{2, 1}就是两个集合了

## 如何理解回溯法

**回溯法解决的问题都可以抽象为树形结构**。因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**。既然是递归，就要有终止条件，所以必然是一棵高度有限的树（N叉树）。这一点在后面的题目中也会有所体现

## 回溯法模板

在[递归与二叉树篇：递归介绍](https://www.help-doc.top/algorithm/recursion-binary-tree/recursion-intro/recursion-intro.html#_5)提到如何写好一个递归。接下来列出回溯的基本三大步骤：

1. 回溯函数模板返回值以及参数

    在回溯算法中，一般函数起名字为`backtracking`，这个起名可以随意。回溯算法中函数返回值一般为`void`。再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

    回溯函数伪代码如下：

    ```c++
    void backtracking(参数)
    ```

2. 回溯函数终止条件

    既然是树形结构，在学习二叉树时就知道遍历树形结构一定要有终止条件，因此回溯也有要终止条件。至于什么时候达到了终止条件，从树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

    所以回溯函数终止条件伪代码如下：

    ```c++
    if (终止条件) {
        存放结果;
        return;
    }
    ```

3. 回溯搜索的遍历过程

    在上面提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度

    如图：

    <img src="1. 回溯理论基础.assets/image-20250106173734301.png">

    !!! note

        注意图中集合大小和孩子的数量是相等的

    回溯函数遍历过程伪代码如下：

    ```c++
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
    ```

    `for`循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个`for`循环就执行多少次。`backtracking`函数就是自己调用自己，实现递归

    可以从图中看出**`for`循环可以理解是横向遍历，`backtracking`（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完整个过程，总结回溯算法模板框架如下：

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

后面在理解回溯题目的代码时都可以通过这个模板辅助理解

!!! note

    注意，模板只是为了辅助理解，不能因为这个模板而限制了回溯算法题目的思考范围，在[回溯基础练习](https://www.help-doc.top/algorithm/backtracking/backtracking-basic/backtracking-basic.html#_1)中会多次使用这个模板，但是在[回溯进阶练习](https://www.help-doc.top/algorithm/backtracking/backtracking-advanced/backtracking-advanced.html)就要跳脱出这个模板进行思考