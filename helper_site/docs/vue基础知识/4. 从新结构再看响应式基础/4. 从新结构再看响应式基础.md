# 从新结构再看响应式基础

进入工程化模式后，前面的写法就可以进一步的缩减，以下是对前面的内容进行相对简化的写法，知识本身并没有区别，只是写法可能有不同

在前面想使用Vue的内容就需要执行两步：

1. 引入`Vue.js`文件
2. 从`Vue`对象中解构出需要用到的函数或者对象

但是因为是工程化，所以上面的两步就只需要合并为一步：从第三方模块中导入需要的函数或者对象即可，对于createApp函数来说，因为其在应用入口`main.js`中已经导入，所以在vue文件中就不需要再导入了

## `setup`函数

在工程化模式下，使用`setup`函数默认是下面的写法：

```vue
<script>
export default {
    setup() {
        const msg = "hello world";

        return {
            msg
        }
    }
}
</script>

<template>
    {{ msg }}
</template>
```

但是上面的写法有些繁琐，所以更常见的写法是`setup`的简写方式：

```vue
<!-- 在script标签中带上setup属性 -->
<script setup>
const msg = "hello world";

// 不需要在手动返回数据就可以在插值表达式中使用
</script>

<template>
    {{ msg }}
</template>
```

## 插值表达式

根据上面的写法，所以之后的插值表达式可以写为：

```vue
<script setup>
let i = 10; // 变量
const pi = 3.14; // 常量
const obj = { name: "zhang san" }; // 对象
function func() {
    return "函数返回值";
}// 函数
</script>

<template>
    <p>变量：{{ i }}</p>
    <p>常量：{{ pi }}</p>
    <p>对象属性：{{ obj.name }}</p>
    <p>运算结果：{{ i + pi }}</p>
    <p>三元表达式：{{ i > 1 ? "yes" : "no" }}</p>
    <p>函数返回值：{{ func() }}</p>
    <p>方法（统计对象obj的name属性值有多少个单词）：{{ obj.name.split(" ").length }}</p>
</template>
```

实现的效果与前面章节是一样的，此处不再展示

## 响应式

同样，响应式可以修改为：

```vue
<script setup>
import { reactive, ref } from 'vue';
// reactive
const obj = reactive({
    name: "zhangsan",
    age: 19
})

// ref
// ref既可以将原始类型转换为响应式
const mesg = ref("hello world")
// 也可以将对象声明为响应式
const obj1 = ref({
    name: "lisi",
    age: 20
})

// 需要注意，ref声明的数据如果需要再原生JavaScript中访问必须要带.value
// 但是reactive不需要
function func() {
    // 访问原始类型中的内容
    console.log(mesg.value);
    // 访问对象的内容
    console.log(obj1.value.name + obj1.value.age);
}
</script>
<template>
    <p>{{ mesg }}</p>
    <p>我是{{ obj.name }}，我今年{{ obj.age }}岁了</p>
    <p>我是{{ obj1.name }}，我今年{{ obj1.age }}岁了</p>
    {{ func() }}
</template>
```

效果与前面一致，不再展示
