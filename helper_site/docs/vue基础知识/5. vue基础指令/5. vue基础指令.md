# vue基础指令

## 内容渲染指令`v-html`和`v-text`

```vue
<script setup>

// 内容渲染指令，放在双标签的起始标签
// 1. v-html：可以渲染HTML标签和属性，作用等同于JavaScript中的innerHTML
// 2. v-text：纯文本显示，作用等同于JavaScript中的inneText
// 其中，v-text作用与插值表达式相同
// 需要注意，使用v-html或者v-text时，都不能在该标签内部带子标签或者写内容

const msg = "<span style='color:red;'>hello world</span>"

</script>
<template>
  <div>
    <p v-html="msg"></p>
    <p v-text="msg"></p>
    <!-- v-text的作用类似于插值表达式 -->
    <p>{{ msg }}</p>
  </div>
</template>
```

## 属性绑定指令`v-bind`

```vue
<script setup>
import { ref } from "vue";
// v-bind属性绑定指令
// 作用：使得任何标签的属性可以使用动态值
// 基本语法：v-bind:属性名="表达式"
// 也可以简写为：:属性名="表达式"
const msg = "https://www.baidu.com";

// 动态修改值
const url = ref("https://www.bing.com")
</script>

<template>
  <div>
    <a v-bind:href="msg">百度一下</a>
    <!-- 简写为 -->
    <a :href="msg">百度一下</a>

    <!-- 绑定响应式数据 -->
    <a :href="url">必应</a>
  </div>
</template>
```

## 事件绑定指令`v-on`

```vue
<script setup>
import { ref } from 'vue'
// v-on指令，用于对标签进行事件绑定
// 基本语法：v-on:事件名="事件执行函数"，有三种常见的写法
// 1. v-on:事件名="单行函数"
// 2. v-on:事件名="无参数函数"
// 3. v-on:事件名="有参数函数(实参)"
// 也可以简写为@事件名

const count = ref(0);

function fn() {
  // 在JavaScript中使用响应式对象需要使用value
  count.value++;
}

const num = ref(5);

function add(n) {
  console.log(n);

  count.value += n;
}

</script>
<template>
  <div>
    <p>当前值为：{{ count }}</p>
    <!-- 写法1 -->
    <!-- 不在JavaScript中写的变量不需要带value -->
    <button @click="count++">增加1</button>
    <!-- 写法2 -->
    <!-- 不需要参数的函数可以不需要带圆括号 -->
    <button @click="fn">增加1</button>
    <!-- 写法3 -->
    <button @click="add(num)">增加{{ num }}</button>
    <!-- 因为template标签中会自动对响应式对象进行解析，所以传参时不需要num.value，所以下面的写法是错误的 -->
    <!-- <button @click="add(num.value)">增加{{ num }}</button> -->
  </div>
</template>
```

## 条件渲染指令`v-show`和`v-if`

```vue
<script setup>
import { ref } from 'vue';

// v-show和v-if
// v-show和v-if都可以用来做条件渲染
// 但是v-if会直接删除DOM元素
// 而v-show只是控制元素CSS的display属性
// 二者的参数都是传递布尔表达式
const isVisible = ref(true);

// v-if与v-else/v-else-if配合还可以实现条件渲染
// 语法类似于if-else-if/if-else
// 需要注意，v-if或者v-else-if或者v-else必须保证作用于兄弟元素
// 而不能是父子元素
const isLogin = ref(true);
</script>

<template>
  <div>
    <!-- 控制元素显示与隐藏 -->
    <!-- v-show -->
    <div class="red" v-show="isVisible"></div>
    <!-- v-if -->
    <div class="green" v-if="isVisible"></div>

    <!-- v-if -->
    <span v-if="isLogin">请登录</span>
    <!-- 注意，v-if和v-else之间不能有其他兄弟元素 -->
    <span v-else>欢迎</span>
  </div>
</template>

<style scoped>
.red,
.green {
  width: 200px;
  height: 200px;
}

.red {
  background-color: red;
}

.green {
  background-color: green;
}
</style>
```

## 案例1——切换图片

基本需求：

实现图片的翻页功能，一共两个按钮，点击图片左侧的“上一张”按钮翻到当前图片的上一张图片。点击图片右侧的“下一张”按钮翻到当前图片的下一张图片。需要注意，如果当前是第一张就必须禁用“上一张”，如果当前是最后一张就必须禁用“下一张”。不要实现循环播放，即第一张的上一张是最后一张，最后的一张的下一张是第一张

示例：

<img src="5. vue基础指令.assets/图片案例.gif">

参考代码：

```vue
<script setup>
import { ref } from 'vue'

const imgList = [
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-00.gif',
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-01.gif',
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-02.gif',
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-03.gif',
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-04.png',
  'https://cxk-1305128831.cos.ap-beijing.myqcloud.com/11-05.png'
];

// 控制下标，声明为响应式对象
const index = ref(0);

const isFirst = (i) => {
  // 数组的第一个元素时隐藏
  return i <= 0;
}

const isLast = (i) => {
  // 数组的最后一个元素时隐藏
  return i >= imgList.length - 1;
}
</script>

<template>
  <div>
    <!-- 上一张 -->
    <!-- 数组的下标不是第一个元素时显示“上一张”按钮 -->
    <button @click="index--" v-show="!isFirst(index)">上一张</button>
    <img :src="imgList[index]">
    <!-- 下一张 -->
    <!-- 数组的下标不是最后一个元素时显示“下一张”按钮 -->
    <button @click="index++" v-show="!isLast(index)">下一张</button>
  </div>
</template>

<style scoped>
  #app {
    display: flex;
    width: 500px;
    height: 240px;
  }

  img {
    width: 240px;
    height: 240px;
  }

  #app div {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
  }
</style>
```

## 列表渲染指令`v-for`

```vue
<script setup>
// v-for指令，可以用于循环生成某一个标签及其子标签
// 即需要循环生成哪一个标签，就在哪一个标签上写v-for
// 基本语法：(参数1, 参数2) in 数组/对象/数字
// 其中参数1，表示值，参数2表示下标
// 如果只有一个参数1，那么可以省略圆括号
// 需要注意的是，声明在v-for中的参数1和参数2都只在当前标签及其子标签内可用，对于其兄弟标签或者父亲标签都不可见

// 数字数组
const arr = [1, 2, 3, 4];
// 对象数组
const objArr = [
  {
    id: 1, name: "zhangsan"
  },
  {
    id: 2, name: "lisi"
  },
  {
    id: 3, name: "wangwu"
  }
];
// 对象
const obj = {
  name: "zhaoliu",
  age: 16
}
</script>

<template>
  <div>
    <!-- 遍历数字数组 -->
    <ul>
      <!-- 只使用第一个参数，不需要带括号 -->
      <li v-for="num in arr">
        {{ num }}
      </li>
      <!-- 使用两个参数时需要带括号 -->
      <li v-for="(num, index) in arr">
        {{ num }} : {{ index }}
      </li>
    </ul>

    <!-- 遍历对象数组 -->
    <div>
      <!-- 遍历对象数组时，第一个参数拿出来的是一个对象 -->
      <div v-for="(value, index) in objArr">
        {{ value.id }} - {{ value.name }} : {{ index }}
      </div>
    </div>

    <!-- 遍历对象 -->
    <ul>
      <!-- 对象比较特殊，有三个参数，注意第一个参数为值而不是键，需要与原生JS的for-in做区分 -->
      <li v-for="(value, key, index) in obj">
        {{ value }} - {{ key }} - {{ index }}
      </li>
    </ul>

    <!-- 遍历数字 -->
    <ul>
      <!-- 遍历数字时就相当于生成指定个数个标签 -->
      <!-- 第一个参数从1开始计数，一直到指定数字 -->
      <!-- 第二个参数从0开始，表示下标 -->
      <li v-for="(num, index) in 10">
        {{ num }} : {{ index }}
      </li>
    </ul>
  </div>
</template>
```

## 案例2——书架

基本需求：

1. 动态渲染书本列表
2. 删除功能：点击删除按钮可以删除当前列表项

示例：

<img src="5. vue基础指令.assets/书架案例.gif">

参考代码：

```vue
<script setup>
import { ref } from "vue";
// 图书列表
// 修改数据->影响视图，声明为响应式
const bookList = ref([
  { id: 1, name: '《红楼梦》', author: '曹雪芹' },
  { id: 2, name: '《西游记》', author: '吴承恩' },
  { id: 3, name: '《⽔浒传》', author: '施耐庵' },
  { id: 4, name: '《三国演义》', author: '罗贯中' }
]);

function del(index) {
  // 删除当前位置的1个元素
  bookList.value.splice(index, 1);
}
</script>
<template>
  <h3>书架</h3>
  <ul>
    <!-- 使用v-for渲染数组 -->
    <li v-for="(book, index) in bookList">
      <!-- v-for会生成当前标签和及其子标签 -->
      <!-- 并且v-for的参数在子标签中均可用 -->
      <span>{{ book.name }}</span>
      <span>{{ book.author }}</span>

      <!-- 点击删除时从数组中删除对应的书籍 -->
      <!-- 使用v-for的第二个参数识别当前是哪一个列表项 -->
      <button @click="del(index)">删除</button>
    </li>
  </ul>
</template>
<!-- 这个style不要添加scoped属性，因为要修饰id为app的盒子，这个id并不在当前的文件中 -->
<style>
#app {
  width: 400px;
  margin: 100px auto;
}

ul li {
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  border-bottom: 1px solid #ccc;
}
</style>
```

## 结合`key`的`v-for`——结合书架案例

对比：

**没使用`key`：**

<img src="5. vue基础指令.assets/书架案例.gif">

**使用`key`：**

<img src="5. vue基础指令.assets/书架案例1.gif">

原理：为`v-for`所在标签动态绑定`key`，因为Vue会尽可能得复用DOM，从而提高整体的性能，而`v-for`在列表更新时需要涉及到重新渲染，如果节点改变太多，那么可以复用的DOM节点就会很少，从而导致需要额外处理节点的新增

根据这个原理，为了尽可能保证渲染性能，需要为`v-for`所在标签绑定一个唯一值作为`key`的属性值，这样只要这个`key`不变，那么Vue就会认为这个节点没有改变，从而复用这个DOM节点

!!! note

    `key`的类型一般为数字或者字符串，不建议使用其他类型

参考代码：

```vue
<script setup>
import { ref } from "vue";
// 图书列表
// 修改数据->影响视图，声明为响应式
const bookList = ref([
  { id: 1, name: '《红楼梦》', author: '曹雪芹' },
  { id: 2, name: '《西游记》', author: '吴承恩' },
  { id: 3, name: '《⽔浒传》', author: '施耐庵' },
  { id: 4, name: '《三国演义》', author: '罗贯中' }
]);

function del(index) {
  // 删除当前位置的1个元素
  bookList.value.splice(index, 1);
}
</script>

<template>
  <h3>书架</h3>
  <ul>
    <!-- 在v-for所在标签添加:key -->
    <!-- 使用id作为key的值，如果没有比id更合适作为key的值，再考虑用下标 -->
    <li v-for="(book, index) in bookList" :key="book.id">
      <span>{{ book.name }}</span>
      <span>{{ book.author }}</span>

      <button @click="del(index)">删除</button>
    </li>
  </ul>
</template>

<style>
#app {
  width: 400px;
  margin: 100px auto;
}

ul li {
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  border-bottom: 1px solid #ccc;
}
</style>
```

## 双向绑定`v-model`

之前都是数据驱动视图，但是有的时候需要保证数据驱动视图的同时还要做到视图驱动数据，此时就需要双向绑定指令，即数据<->视图。一般会在表单元素中使用

```vue
<script setup>
// 基本语法：在指定元素上使用v-model，其值为需要绑定的响应式数据
import { reactive } from 'vue';

const loginForm = reactive({
  username: "",
  password: ""
})
</script>

<template>
  <div>
    <!-- 在姓名输入框中绑定username -->
    姓名：<input type="text" v-model="loginForm.username"><br /><br />
    <!-- 在密码输入框中绑定password -->
    密码：<input type="text" v-model="loginForm.password"><br /><br />

    <button>提交</button>
  </div>
</template>


<style scoped></style>
```

## 案例3——记事本

基本功能：

1. 动态渲染记事本的任务
2. 添加任务：根据用户输入的任务添加到列表中，注意，空字符串以及字符串首尾空格不能插入到列表中，拓展：添加完成后清空输入框
3. 删除任务：用户点击任务列表右侧的删除按钮删除当前列表项
4. 清空任务：用户点击“清空任务”按钮即可删除所有任务
5. 统计任务：根据用户当前任务的个数计算出总数结果

示例：

<img src="5. vue基础指令.assets/记事本案例.gif">

参考代码：

```vue
<script setup>
// 导入样式
import './assets/style/index.css';
import { ref } from 'vue';
// 待办任务列表
// 数组声明为响应式对象
const todoList = ref([
  { id: 321, name: '吃饭', finished: false },
  { id: 666, name: '睡觉', finished: true },
  { id: 195, name: '打豆豆', finished: false }
]);

// 2. 添加任务
// 使用双向绑定获取到输入框的数据
const task = ref("");
function addTask(t) {
  if (t == "")
    return

  // 去除首尾空格
  t = t.trim();
  todoList.value.unshift({ id: Date.now(), name: t, finished: false });
  // 添加完成后清空输入框
  task.value = "";
}

// 3. 删除任务
// 根据id删除，不建议根据数字元素下标删除，因为一般来讲内容都是来自后端，后端只能给id，无法提供下标
function del(id) {
  // 使用过滤方法，让不等于当前要删除的id的元素留下
  todoList.value = todoList.value.filter((item) => item.id != id)
}

</script>

<template>
  <section clsss="todoapp">

    <header class="header">
      <h1>记事本</h1>
      <!-- 输入任务 -->
      <input v-model="task" placeholder="请输入任务" class="new-todo" />
      <!-- 添加任务 -->
      <button @click="addTask(task)" class="add">添加任务</button>
    </header>

    <section class="main">
      <ul class="todo-list">
        <!-- 1. 先动态生成数据 -->
        <li class="todo" v-for="(list, index) in todoList" :key="list.id">
          <div class="view">
            <!-- 序号 -->
            <span class="index">{{ index + 1 }}</span>
            <!-- 描述文字 -->
            <label>{{ list.name }}</label>
            <!-- 删除 -->
            <button @click="del(list.id)" class="destroy"></button>
          </div>
        </li>
      </ul>
    </section>

    <footer class="footer">
      <!-- 统计总数 -->
      <!-- 4. 统计任务，直接获取数组长度即可 -->
      <span class="todo-count">合 计: <strong>{{ todoList.length }}</strong></span>
      <!-- 清空 -->
      <!-- 3. 清空任务，直接将数组赋值为空数组即可，或者改变数组的长度为0 -->
      <button class="clear-completed" @click="todoList.length = 0">清空任务</button>
      <!-- <button class="clear-completed" @click="todoList = []">清空任务</button> -->
    </footer>
  </section>
</template>
```