# 数组基础篇

## 数组基础回顾

数组是一种在内存中有着连续空间的数据结构，可以使用下标访问，但是缺点是定长，在C++中一般情况下都需要在创建数组的同时给定数组空间

因为数组是定长的，所以数组的空间是不可以一旦创建就不可以被随便更改，也导致数组中一旦存储了数据就不可以删除，只能通过覆盖行为达到间接删除，而挪动数据就需要注意防止覆盖原数据的问题，一般挪动数据分为三种情况：

1. 中间插入数据：空间足够的情况下，从最后一个数据移动，直到插入位置可以被覆盖，时间复杂度O(N)
2. 最后插入数据，空间足够的情况下，直接在最后一个元素的位置插入数据，时间复杂度O(1)
3. 需要移除指定位置的数据：从移除的数据的下一个位置，依次将后面的数据向前移动，时间复杂度O(N)

最后数组的下标是从0开始计算，最后一个元素的下标是数组长度-1

其他内容可以看前面基础部分的[C语言数组内容](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/3.%20C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/3.%20C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F.html#c_5)

## 二分查找算法

二分查找算法，是一种快速在一组有序且严格递增的区域中找一个指定元素的算法，其基本原理类似于猜数字游戏，先猜一个中间数值，再根据中间数值与目标值进行比较，判断目标值在中间值左侧部分还是右侧部分改变下一次猜的数值

有了基本思路，根据前面的基本思路就需要进行代码实现，二分查找算法根据查找区间右侧端点是否包含分为两种情况，假设左侧端点为left，右侧端点为right：

1. 左闭右闭区间：[left, right]，这种情况下最明显的特点就是left==right时是有效区间
2. 左闭右开区间：[left, right)，这种情况下与左闭右闭区间刚好相反，当left==right时是无效区间

!!! info
    所谓有效区间，代表该区间内的所有值都是有效可查找的

因为接下来的查找一个循环进行的动作，而在整个循环中，必须保证left和right构成的区间必须与一开始设定的区间原则一致，例如开始为左闭右开区间，则在整个循环中，必须保证left和right构成的区间始终为左闭右开区间，这个区间在整个过程中也被称为循环不变量

左闭右闭原则下，因为left和right都是有效值，所以下一次更新时，left和right对应的值也必须是未比较过的值（即有效值）

<img src="1. 数组基础篇.assets/image-20241018214429432.png" alt="image-20241018214429432" />

左闭右闭原则下，因为left是有效值，right是无效值，所以下一次更新时，left对应的值是未比较过的值（即有效值），right对应的值是比较过的值（即无效值）

<img src="1. 数组基础篇.assets/image-20241018214545439.png" alt="image-20241018214545439" />

代码实现：

=== "左闭右闭原则"

    ```c++
    // 左闭右闭原则
    // 返回指定元素的下标
    int BinarySearch(std::vector<int>& nums, int target)
    {
        // 左闭右闭原则：[left, right]区间，此时left==right是有效区间
        int left = 0;
        int right = nums.size() - 1;

        // left <= right, 因为当left==right时，nums[left] == nums[right]有效，此时是最后一次判断
        while (left <= right)
        {
            // 计算出中间值
            // int mid = (left + right) / 2;
            int mid = left + ((right - left) / 2); // 防止溢出——结果等效于上面的写法
            // 除以2也可以使用右移>>
            // int mid = left + ((right - left) >> 1);
            /*
            * 上面的步骤先算出固定不变的间隔值，再通过起始位置加上间隔值间接算出中间值位置
            *  具体步骤如下：
            *  1. 计算 right - left，得到区间的长度
            *  2. 将区间长度除以 2，得到中间值相对于 left 的偏移量
            *  3. 将偏移量加到 left 上，得到中间值的位置
            */
            // 判断是否取到指定值
            if (nums[mid] == target) // 相等——返回
            {
                return mid; // 返回指定值下标
            }
            else if (nums[mid] > target) // 中间值较大——target一定在中间值左边
            {
                // 左闭右闭原则，此时nums[mid]一定不是target
                right = mid - 1;
            }
            else if (nums[mid] < target) // 中间值较小——target一定在中间值右边
            {
                // 左闭右闭原则，此时nums[mid]一定不是target
                left = mid + 1;
            }
        }

        // 约定没找到返回-1
        return -1;
    }
    ```

=== "左闭右开原则"

    ```c++
    // 左闭右开原则
    // 返回指定元素的下标
    int BinarySearch(std::vector<int>& nums, int target)
    {
        // 左闭右开原则：[left, right)，此时当left==right时就是无效区间
        int left = 0;
        int right = nums.size();

        // 因为left==right是无效区间，所以left不可以等于right
        while (left < right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) // 相等——返回
            {
                return mid;
            }
            else if(nums[mid] > target) // 中间值较大，则目标值一定在中间值右边
            {
                // 左闭右开原则，此时mid的值是下一次的右边界，不包括mid的值
                right = mid;
            }
            else if(nums[mid] < target) // 中间值较小，则目标值一定在中间值左边
            {
                // 左边右开原则，此时mid的值是下一次的左边界，包括mid的值
                left = mid + 1;
            }
        }

        // 没找到指定值返回-1
        return -1;
    }
    ```

示例题目：

[704.二分查找](https://leetcode.cn/problems/binary-search/)


!!! quote
    给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


    **示例 1:**

    ```c++
    输入: nums = [-1,0,3,5,9,12], target = 9
    输出: 4
    解释: 9 出现在 nums 中并且下标为 4
    ```

    **示例 2:**

    ```c++
    输入: nums = [-1,0,3,5,9,12], target = 2
    输出: -1
    解释: 2 不存在 nums 中因此返回 -1
    ```

    **提示：**

    1. 你可以假设 `nums` 中的所有元素是不重复的。
    2. `n` 将在 `[1, 10000]`之间。
    3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

参考代码见上

相关题目：

[力扣35.搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

参考代码：

```c++
class Solution35 {
public:
    int searchInsert(std::vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid = 0;
        while(left <= right)
        {
            mid = left + ((right - left) >> 1);
            if(nums[mid] == target)
            {
                return mid;
            }
            else if(nums[mid] > target)
            {
                right = mid - 1;
            }
            else if(nums[mid] < target)
            {
                left = mid + 1;
            }
        }

        // 没找到返回中间值的下一个位置，需要修正数组中存在的位置，如果不存在的位置，则新增的一定是在数组长度位置的元素
        // return target < nums[mid] ? mid: mid + 1;
        // 左闭右闭不能返回right
        // return right;
        return left;
    }
};
```

[力扣69.x的平方根](https://leetcode.cn/problems/sqrtx/description/)

本题需要注意数值范围，小心越界问题，[C语言/C++数据类型取值范围见表](https://www.helper-wiki.top/%E7%AE%97%E6%B3%95/0.%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9/0.%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9.html)

参考代码：

```c++
// 力扣69.x的平方根
/*
 * 二分查找：
 * 为什么：在枚举小于x的每一个整数时，最小的算术平方根是0，依次增大，满足二分查找的调节：有序且严格递增
 * 怎么用：最小的算术平方根是0，所以起点为0，而需要判断的是当前枚举的数值是否为k*k<=x，
 * 而因为x的算术平方根肯定在[0, x]区间中，所以需要枚举0到x中的数值。
 * 假设将0到x个数值看做一个数组，则取出当前数组的中间元素，
 * 判断中间元素mid*mid是否<=x，小于说明需要移动left，否则移动right
 * 怎么写：
 */
class Solution69 {
public:
    int mySqrt(int x) {
        // 暴力解法
        // size_t ans = 0;
        // for(;ans * ans <= x; ans++);
        // return (ans - 1);
        size_t left = 0;
        size_t right = x;
        size_t ans = 0;
        // 左闭右闭区间
        while(left <= right)
        {
            size_t mid = left + ((right - left) >> 1);
            // 可能无法刚刚好等于
            // if(ans == x)
            // {
            //     ans = mid;
            //     break;
            // }
            if(mid * mid <= x) // 中间值较小
            {
                ans = mid;
                left = mid + 1;
            }
            else if(mid * mid > x) // 中间值较大
            {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

[类似于力扣69题：力扣367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/description/)

参考代码：

```c++
// 类似69题型：力扣367.有效的完全平方数
class Solution367 {
public:
    bool isPerfectSquare(int num) {
        size_t left = 0;
        size_t right = num;
        size_t ans = 0;
        // 左闭右闭区间
        while(left <= right)
        {
            size_t mid = left + ((right - left) >> 1);
            if (mid * mid <= num)
            {
                ans = mid;
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }

        return ans * ans == num;
    }
};
```

[力扣34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

参考代码：

```c++
// 力扣34.在排序数组中查找元素的第一个和最后一个位置
/*
 * 本题思路：
 * 二分查找
 * 为什么：题目提到数组是升序但非递减，所以直接找target肯定结果不唯一，但是本题需要找的是第一个和最后一个位置对应的下标
 * 所以可以考虑设定两个一定不存在的边界值，使用二分查找设定边界，因为是整型数组，所以一定不存在的值肯定是浮点数
 * 怎么找：首先判断target是否存在于原数组，不存在返回{-1, -1}，此处就可以直接使用二分查找，至少找到一个有效位置即可，
 * 如果存在则继续使用两次二分查找，第一次二分查找找左边界，第二次找右边界即可
 */
class Solution34 {
public:
    // 二分查找
    int BinarySearch(std::vector<int>& nums, double target) {
        int left = 0;
        int right = nums.size();

        // 左闭右开区间
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    // 使用二分查找确定是否存在
    bool isExist(std::vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();

        // 左闭右开区间
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target){
                right = mid;
            } else {
                return true;
            }
        }

        return false;
    }

    std::vector<int> searchRange(std::vector<int>& nums, int target) {
        // 判断是否存在
        if(!isExist(nums, target))
        {
            // 不存在直接返回
            return {-1, -1};
        }

        // 存在则继续
        // 找左边界
        int leftHand = BinarySearch(nums, target - 0.5);
        // 找右边界
        int rightHand = BinarySearch(nums, target + 0.5);
        return {leftHand, rightHand - 1};
    }
};
```

[类似力扣34题：牛客网JZ53 数字在升序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=23274&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

=== "C++"
    ```c++
    // 牛客类似题目：JZ53 数字在升序数组中出现的次数
    #include <vector>
    class SolutionJZ53 {
    public:
        /**
        * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
        *
        *
        * @param nums int整型vector
        * @param k int整型
        * @return int整型
        */
        // 二分查找
        int BinarySearch(std::vector<int>& nums, double target)
        {
            int left = 0;
            int right = nums.size() - 1;
            // 左闭右闭区间
            while (left <= right)
            {
                int mid = left + ((right - left) >> 1);
                if(nums[mid] <= target)
                {
                    left = mid + 1;
                }
                else
                {
                    right = mid - 1;
                }
            }

            return left;
        }
        int GetNumberOfK(std::vector<int>& nums, int k)
        {
            // 左边界
            int leftHand = BinarySearch(nums, k - 0.5);
            // 右边界
            int rightHand = BinarySearch(nums, k + 0.5);

            return rightHand - leftHand;
        }
    };
    ```
=== "C语言"

    ```c++
    /**
        * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
        *
        *
        * @param nums int整型一维数组
        * @param numsLen int nums数组长度
        * @param k int整型
        * @return int整型
        */
    //二分查找
    int BinarySearch(int* nums, int numsLen, double k)
    {
        int left = 0;
        int right = numsLen - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] > k)
            {
                right = mid - 1;
            }
            else if (nums[mid] < k) {
                left = mid + 1;
            }
        }
        //返回 left 而不是 mid
        return left;
    }
    int GetNumberOfK(int* nums, int numsLen, int k )
    {
        return BinarySearch(nums, numsLen, k+0.5)-BinarySearch(nums, numsLen, k-0.5);
    }
    ```

## 移除元素专题
前面提到，数组中需要移除元素不可以直接删除，因为数组是一个连续的结构，删除元素只能通过将被删除的元素进行覆盖，此时就必定涉及到将被删除元素的后面元素向前依次挪动

以下面的题目为例：

[力扣27.移除元素](https://leetcode.cn/problems/remove-element/description/)

!!! quote
    给你一个数组 nums 和一个值`val`，你需要 原地 移除所有数值等于`val`的元素。元素的顺序可能发生改变。然后返回`nums`中与`val`不同的元素的数量。

    假设`nums`中不等于`val`的元素数量为`k`，要通过此题，您需要执行以下操作：

    更改`nums`数组，使`nums`的前`k`个元素包含不等于`val`的元素。`nums`的其余元素和`nums`的大小并不重要。

    返回 k。

    **示例 1：**
    
    ```c++
    输入：nums = [3,2,2,3], val = 3
    输出：2, nums = [2,2,_,_]
    解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
    你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
    ```

    示例 2：

    ```c++
    输入：nums = [0,1,2,2,3,0,4,2], val = 2
    输出：5, nums = [0,1,4,0,3,_,_,_]
    解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
    注意这五个元素可以任意顺序返回。
    你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
    ```

根据数组删除元素的基本思路，可以写出本题的暴力解法如下：

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int size = nums.size();
        for (int i = 0; i < size; i++) 
        {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) 
                {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

但是，上面的写法时间复杂度是$O(N^2)$，所以需要考虑是否还有简化的方法：

本题可以使用快慢指针的方法，本质就是双指针算法，其中`slow`指针指向待被覆盖的元素，`fast`找不等于被删除的元素，所以根据这个思路可以写出下面的代码：

```c++
class Solution27
{
public:
    int removeElement(std::vector<int> &nums, int val)
    {
        // 双指针解法
        // int count = 0;
        int fast = 0, slow = 0;
        while (fast < nums.size())
        {
            if (nums[fast] != val)
            {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        // return count;
        // 也可以不用计数器，直接返回slow
        return slow;
    }
};
```

相关题目：

[力扣26.删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

参考代码：

```c++
class Solution26
{
public:
    int removeDuplicates(std::vector<int> &nums)
    {
        // 双指针解法
        int size = nums.size();
        int slow = 0;
        int fast = 0;
        while (fast < nums.size())
        {
            if (nums[fast] != nums[slow])
            {
                // slow+1防止越界
                if (slow + 1 < nums.size())
                {
                    nums[slow + 1] = nums[fast];
                }
                slow++;
            }
            fast++;
        }

        return slow + 1;
    }
};
```

[力扣283.移动零](https://leetcode.cn/problems/move-zeroes/description/)

参考代码：

```c++
// 双指针解法，具体思路与上题类似
class Solution283
{
public:
    void moveZeroes(std::vector<int> &nums)
    {
        int prev = 0, cur = 0;
        while (cur < nums.size())
        {
            if (nums[cur])
                std::swap(nums[cur++], nums[prev++]);
            else
                cur++;
        }
    }
};
```

[力扣844.比较含退格的字符](https://leetcode.cn/problems/backspace-string-compare/description/)

参考代码：

=== "暴力解法"

    ```c++
    // 暴力解法——注意string类也有尾删操作
    class Solution844_1
    {
    public:
        std::string remove(std::string s)
        {
            // 暴力解法
            std::string ret;
            for (auto str: s)
            {
                if (str != '#')
                {
                    ret.push_back(str);
                }
                else if (!ret.empty())
                {
                    // string的尾删方法pop_back
                    ret.pop_back();
                }
            }

            return ret;
        }

        bool backspaceCompare(std::string s, std::string t)
        {
            return remove(s) == remove(t);
        }
    };
    ```

=== "双指针解法"

    ```c++
    // 双指针算法
    /*
    * 为什么：判断两个数组内容是否相等，可以定义指向两个数组的指针依次比较每一个字符
    * 如何用：本题涉及到退格符#，所以需要额外遇到#时候的情况，因为#只会影响左侧的字符而不会影响右侧的字符
    * 所以考虑从后往前遍历，但是考虑到#可能与下一个要删除的字符不是紧挨着，所以需要考虑使用一个计数器记录#的个数
    * 在遍历过程中，分为三种情况：
    * 1. 当#计数器为0，直接判断两个数组中的当前字符是否相等，不等则直接返回false，这里需要考虑其中一个可能是空数组
    * 2. 当有一方#计数器不为0，则让该方的下标指针向前移动，直到移动到计数器为0为止
    * 3. 如果当前字符是#，则#计数器加1，并且下标指针向前移动
    */
    class Solution844_2
    {
    public:
        bool backspaceCompare(std::string s, std::string t)
        {
            int si = s.size() - 1, ti = t.size() - 1;
            int skips = 0, skipt = 0;

            // 确保至少有一方有内容
            while (si >= 0 || ti >= 0)
            {
                // 遍历第一个字符数组
                while (si >= 0)
                {
                    if (s[si] == '#')
                    {
                        // 第三种情况
                        skips++;
                        si--;
                    }
                    else if (skips > 0)
                    {
                        // 第二种情况
                        si--;
                        skips--;
                    }
                    else
                    {
                        // 第一种情况
                        break;
                    }
                }
                // 遍历第二个字符数组
                while (ti >= 0)
                {
                    if (t[ti] == '#')
                    {
                        // 第三种情况
                        skipt++;
                        ti--;
                    }
                    else if (skipt > 0)
                    {
                        // 第二种情况
                        ti--;
                        skipt--;
                    }
                    else
                    {
                        // 第一种情况
                        break;
                    }
                }

                // 判断两个字符串当前字符是否相等
                // 必须确保两个字符串都有字符才进行当前字符是否相等的比较
                if (si >= 0 && ti >= 0)
                {
                    if (s[si] != t[ti])
                    {
                        return false;
                    }
                }
                else
                {
                    // 如果有一个字符数组为空，则直接返回false
                    if (si >= 0 || ti >= 0)
                    {
                        return false;
                    }
                }
                si--;
                ti--;
            }

            // 循环全部走完说明相同
            return true;
        }
    };
    ```

[力扣977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

参考代码：

=== "尾插+排序"

    ```c++
    // 尾插+排序
    class Solution977_1
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            std::vector<int> ret;
            for (auto num: nums)
            {
                ret.push_back(num * num);
            }
            std::sort(ret.begin(), ret.end());
            return ret;
        }
    };
    ```

=== "双指针算法（非原地处理；左闭右闭）"

    ```c++
    // 双指针算法（但非原地处理）
    /*
    * 为什么：本题中存在负数，并且数组是非递减顺序，
    * 所以最大值只有可能出现在最左侧（负数数值越小，平方后越大）和最右侧（正数数值越大，平方后越大）
    * 并且平方值向数组中间依次减小
    * 怎么做：考虑双指针异地处理，比较左指针和右指针对应的值的平方，大的就尾插到异地的数组中
    * 为了避免使用insert函数产生额外的时间复杂度，可以考虑提前开辟空间，并使用一个指针，起始位置指向异地数组的最后一个元素的位置
    */
    // 左闭右闭区间
    class Solution977_2
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            int left = 0, right = nums.size() - 1;
            std::vector<int> ret(nums.size());
            int reti = ret.size() - 1;
            while (left <= right)
            {
                int num1 = nums[left] * nums[left];
                int num2 = nums[right] * nums[right];
                if (num1 < num2)
                {
                    ret[reti--] = num2;
                    right--;
                }
                else
                {
                    ret[reti--] = num1;
                    left++;
                }
            }

            return ret;
        }
    };
    ```

=== "双指针算法（但非原地；左闭右开）"

    ```c++
    // 左闭右开区间
    class Solution977_3
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            int left = 0, right = nums.size();
            std::vector<int> ret(nums.size());
            int reti = ret.size() - 1;
            while (left < right)
            {
                int num1 = nums[left] * nums[left];
                int num2 = nums[right - 1] * nums[right - 1];
                if (num1 < num2)
                {
                    ret[reti--] = num2;
                    right--;
                }
                else
                {
                    ret[reti--] = num1;
                    left++;
                }
            }

            return ret;
        }
    };
    ```

## 滑动窗口专题
