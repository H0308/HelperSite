# 数组基础篇

## 数组基础回顾

数组是一种在内存中有着连续空间的数据结构，可以使用下标访问，但是缺点是定长，在C++中一般情况下都需要在创建数组的同时给定数组空间

因为数组是定长的，所以数组的空间是不可以一旦创建就不可以被随便更改，也导致数组中一旦存储了数据就不可以删除，只能通过覆盖行为达到间接删除，而挪动数据就需要注意防止覆盖原数据的问题，一般挪动数据分为三种情况：

1. 中间插入数据：空间足够的情况下，从最后一个数据移动，直到插入位置可以被覆盖，时间复杂度O(N)
2. 最后插入数据，空间足够的情况下，直接在最后一个元素的位置插入数据，时间复杂度O(1)
3. 需要移除指定位置的数据：从移除的数据的下一个位置，依次将后面的数据向前移动，时间复杂度O(N)

最后数组的下标是从0开始计算，最后一个元素的下标是数组长度-1

其他内容可以看前面基础部分的[C语言数组内容](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/3.%20C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/3.%20C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F.html#c_5)

## 二分查找算法

二分查找算法，是一种快速在一组有序且严格递增的区域中找一个指定元素的算法，其基本原理类似于猜数字游戏，先猜一个中间数值，再根据中间数值与目标值进行比较，判断目标值在中间值左侧部分还是右侧部分改变下一次猜的数值

有了基本思路，根据前面的基本思路就需要进行代码实现，二分查找算法根据查找区间右侧端点是否包含分为两种情况，假设左侧端点为left，右侧端点为right：

1. 左闭右闭区间：[left, right]，这种情况下最明显的特点就是left==right时是有效区间
2. 左闭右开区间：[left, right)，这种情况下与左闭右闭区间刚好相反，当left==right时是无效区间

!!! info
    所谓有效区间，代表该区间内的所有值都是有效可查找的

因为接下来的查找一个循环进行的动作，而在整个循环中，必须保证left和right构成的区间必须与一开始设定的区间原则一致，例如开始为左闭右开区间，则在整个循环中，必须保证left和right构成的区间始终为左闭右开区间，这个区间在整个过程中也被称为循环不变量

左闭右闭原则下，因为left和right都是有效值，所以下一次更新时，left和right对应的值也必须是未比较过的值（即有效值）

<img src="1. 数组基础篇.assets/image-20241018214429432.png" alt="image-20241018214429432" />

左闭右闭原则下，因为left是有效值，right是无效值，所以下一次更新时，left对应的值是未比较过的值（即有效值），right对应的值是比较过的值（即无效值）

<img src="1. 数组基础篇.assets/image-20241018214545439.png" alt="image-20241018214545439" />

代码实现：

=== "左闭右闭原则"

    ```c++
    // 左闭右闭原则
    // 返回指定元素的下标
    int BinarySearch(std::vector<int>& nums, int target)
    {
        // 左闭右闭原则：[left, right]区间，此时left==right是有效区间
        int left = 0;
        int right = nums.size() - 1;

        // left <= right, 因为当left==right时，nums[left] == nums[right]有效，此时是最后一次判断
        while (left <= right)
        {
            // 计算出中间值
            // int mid = (left + right) / 2;
            int mid = left + ((right - left) / 2); // 防止溢出——结果等效于上面的写法
            // 除以2也可以使用右移>>
            // int mid = left + ((right - left) >> 1);
            /*
            * 上面的步骤先算出固定不变的间隔值，再通过起始位置加上间隔值间接算出中间值位置
            *  具体步骤如下：
            *  1. 计算 right - left，得到区间的长度
            *  2. 将区间长度除以 2，得到中间值相对于 left 的偏移量
            *  3. 将偏移量加到 left 上，得到中间值的位置
            */
            // 判断是否取到指定值
            if (nums[mid] == target) // 相等——返回
            {
                return mid; // 返回指定值下标
            }
            else if (nums[mid] > target) // 中间值较大——target一定在中间值左边
            {
                // 左闭右闭原则，此时nums[mid]一定不是target
                right = mid - 1;
            }
            else if (nums[mid] < target) // 中间值较小——target一定在中间值右边
            {
                // 左闭右闭原则，此时nums[mid]一定不是target
                left = mid + 1;
            }
        }

        // 约定没找到返回-1
        return -1;
    }
    ```

=== "左闭右开原则"

    ```c++
    // 左闭右开原则
    // 返回指定元素的下标
    int BinarySearch(std::vector<int>& nums, int target)
    {
        // 左闭右开原则：[left, right)，此时当left==right时就是无效区间
        int left = 0;
        int right = nums.size();

        // 因为left==right是无效区间，所以left不可以等于right
        while (left < right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) // 相等——返回
            {
                return mid;
            }
            else if(nums[mid] > target) // 中间值较大，则目标值一定在中间值右边
            {
                // 左闭右开原则，此时mid的值是下一次的右边界，不包括mid的值
                right = mid;
            }
            else if(nums[mid] < target) // 中间值较小，则目标值一定在中间值左边
            {
                // 左边右开原则，此时mid的值是下一次的左边界，包括mid的值
                left = mid + 1;
            }
        }

        // 没找到指定值返回-1
        return -1;
    }
    ```

示例题目：

[704.二分查找](https://leetcode.cn/problems/binary-search/)


!!! quote
    给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


    **示例 1:**

    ```c++
    输入: nums = [-1,0,3,5,9,12], target = 9
    输出: 4
    解释: 9 出现在 nums 中并且下标为 4
    ```

    **示例 2:**

    ```c++
    输入: nums = [-1,0,3,5,9,12], target = 2
    输出: -1
    解释: 2 不存在 nums 中因此返回 -1
    ```

    **提示：**

    1. 你可以假设 `nums` 中的所有元素是不重复的。
    2. `n` 将在 `[1, 10000]`之间。
    3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

参考代码见上

相关题目：

[力扣35.搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

参考代码：

```c++
class Solution35 {
public:
    int searchInsert(std::vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid = 0;
        while(left <= right)
        {
            mid = left + ((right - left) >> 1);
            if(nums[mid] == target)
            {
                return mid;
            }
            else if(nums[mid] > target)
            {
                right = mid - 1;
            }
            else if(nums[mid] < target)
            {
                left = mid + 1;
            }
        }

        // 没找到返回中间值的下一个位置，需要修正数组中存在的位置，如果不存在的位置，则新增的一定是在数组长度位置的元素
        // return target < nums[mid] ? mid: mid + 1;
        // 左闭右闭不能返回right
        // return right;
        return left;
    }
};
```

[力扣69.x的平方根](https://leetcode.cn/problems/sqrtx/description/)

本题需要注意数值范围，小心越界问题，[C语言/C++数据类型取值范围见表](https://www.helper-wiki.top/%E7%AE%97%E6%B3%95/0.%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9/0.%20%E5%B8%B8%E7%94%A8%E5%86%85%E5%AE%B9.html)

参考代码：

```c++
// 力扣69.x的平方根
/*
 * 二分查找：
 * 为什么：在枚举小于x的每一个整数时，最小的算术平方根是0，依次增大，满足二分查找的调节：有序且严格递增
 * 怎么用：最小的算术平方根是0，所以起点为0，而需要判断的是当前枚举的数值是否为k*k<=x，
 * 而因为x的算术平方根肯定在[0, x]区间中，所以需要枚举0到x中的数值。
 * 假设将0到x个数值看做一个数组，则取出当前数组的中间元素，
 * 判断中间元素mid*mid是否<=x，小于说明需要移动left，否则移动right
 * 怎么写：
 */
class Solution69 {
public:
    int mySqrt(int x) {
        // 暴力解法
        // size_t ans = 0;
        // for(;ans * ans <= x; ans++);
        // return (ans - 1);
        size_t left = 0;
        size_t right = x;
        size_t ans = 0;
        // 左闭右闭区间
        while(left <= right)
        {
            size_t mid = left + ((right - left) >> 1);
            // 可能无法刚刚好等于
            // if(ans == x)
            // {
            //     ans = mid;
            //     break;
            // }
            if(mid * mid <= x) // 中间值较小
            {
                ans = mid;
                left = mid + 1;
            }
            else if(mid * mid > x) // 中间值较大
            {
                right = mid - 1;
            }
        }
        return ans;
    }
};
```

[类似于力扣69题：力扣367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/description/)

参考代码：

```c++
// 类似69题型：力扣367.有效的完全平方数
class Solution367 {
public:
    bool isPerfectSquare(int num) {
        size_t left = 0;
        size_t right = num;
        size_t ans = 0;
        // 左闭右闭区间
        while(left <= right)
        {
            size_t mid = left + ((right - left) >> 1);
            if (mid * mid <= num)
            {
                ans = mid;
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }

        return ans * ans == num;
    }
};
```

[力扣34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

参考代码：

```c++
// 力扣34.在排序数组中查找元素的第一个和最后一个位置
/*
 * 本题思路：
 * 二分查找
 * 为什么：题目提到数组是升序但非递减，所以直接找target肯定结果不唯一，但是本题需要找的是第一个和最后一个位置对应的下标
 * 所以可以考虑设定两个一定不存在的边界值，使用二分查找设定边界，因为是整型数组，所以一定不存在的值肯定是浮点数
 * 怎么找：首先判断target是否存在于原数组，不存在返回{-1, -1}，此处就可以直接使用二分查找，至少找到一个有效位置即可，
 * 如果存在则继续使用两次二分查找，第一次二分查找找左边界，第二次找右边界即可
 */
class Solution34 {
public:
    // 二分查找
    int BinarySearch(std::vector<int>& nums, double target) {
        int left = 0;
        int right = nums.size();

        // 左闭右开区间
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }

    // 使用二分查找确定是否存在
    bool isExist(std::vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();

        // 左闭右开区间
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target){
                right = mid;
            } else {
                return true;
            }
        }

        return false;
    }

    std::vector<int> searchRange(std::vector<int>& nums, int target) {
        // 判断是否存在
        if(!isExist(nums, target))
        {
            // 不存在直接返回
            return {-1, -1};
        }

        // 存在则继续
        // 找左边界
        int leftHand = BinarySearch(nums, target - 0.5);
        // 找右边界
        int rightHand = BinarySearch(nums, target + 0.5);
        return {leftHand, rightHand - 1};
    }
};
```

[类似力扣34题：牛客网JZ53 数字在升序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=23274&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

=== "C++"
    ```c++
    // 牛客类似题目：JZ53 数字在升序数组中出现的次数
    #include <vector>
    class SolutionJZ53 {
    public:
        /**
        * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
        *
        *
        * @param nums int整型vector
        * @param k int整型
        * @return int整型
        */
        // 二分查找
        int BinarySearch(std::vector<int>& nums, double target)
        {
            int left = 0;
            int right = nums.size() - 1;
            // 左闭右闭区间
            while (left <= right)
            {
                int mid = left + ((right - left) >> 1);
                if(nums[mid] <= target)
                {
                    left = mid + 1;
                }
                else
                {
                    right = mid - 1;
                }
            }

            return left;
        }
        int GetNumberOfK(std::vector<int>& nums, int k)
        {
            // 左边界
            int leftHand = BinarySearch(nums, k - 0.5);
            // 右边界
            int rightHand = BinarySearch(nums, k + 0.5);

            return rightHand - leftHand;
        }
    };
    ```
=== "C语言"

    ```c++
    /**
        * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
        *
        *
        * @param nums int整型一维数组
        * @param numsLen int nums数组长度
        * @param k int整型
        * @return int整型
        */
    //二分查找
    int BinarySearch(int* nums, int numsLen, double k)
    {
        int left = 0;
        int right = numsLen - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] > k)
            {
                right = mid - 1;
            }
            else if (nums[mid] < k) {
                left = mid + 1;
            }
        }
        //返回 left 而不是 mid
        return left;
    }
    int GetNumberOfK(int* nums, int numsLen, int k )
    {
        return BinarySearch(nums, numsLen, k+0.5)-BinarySearch(nums, numsLen, k-0.5);
    }
    ```

## 移除元素专题
前面提到，数组中需要移除元素不可以直接删除，因为数组是一个连续的结构，删除元素只能通过将被删除的元素进行覆盖，此时就必定涉及到将被删除元素的后面元素向前依次挪动

以下面的题目为例：

[力扣27.移除元素](https://leetcode.cn/problems/remove-element/description/)

!!! quote
    给你一个数组 nums 和一个值`val`，你需要 原地 移除所有数值等于`val`的元素。元素的顺序可能发生改变。然后返回`nums`中与`val`不同的元素的数量。

    假设`nums`中不等于`val`的元素数量为`k`，要通过此题，您需要执行以下操作：

    更改`nums`数组，使`nums`的前`k`个元素包含不等于`val`的元素。`nums`的其余元素和`nums`的大小并不重要。

    返回 k。

    **示例 1：**
    
    ```c++
    输入：nums = [3,2,2,3], val = 3
    输出：2, nums = [2,2,_,_]
    解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
    你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
    ```

    示例 2：

    ```c++
    输入：nums = [0,1,2,2,3,0,4,2], val = 2
    输出：5, nums = [0,1,4,0,3,_,_,_]
    解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
    注意这五个元素可以任意顺序返回。
    你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
    ```

根据数组删除元素的基本思路，可以写出本题的暴力解法如下：

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int size = nums.size();
        for (int i = 0; i < size; i++) 
        {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) 
                {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

但是，上面的写法时间复杂度是$O(N^2)$，所以需要考虑是否还有简化的方法：

本题可以使用快慢指针的方法，本质就是双指针算法，其中`slow`指针指向待被覆盖的元素，`fast`找不等于被删除的元素，所以根据这个思路可以写出下面的代码：

```c++
class Solution27
{
public:
    int removeElement(std::vector<int> &nums, int val)
    {
        // 双指针解法
        // int count = 0;
        int fast = 0, slow = 0;
        while (fast < nums.size())
        {
            if (nums[fast] != val)
            {
                nums[slow++] = nums[fast];
            }
            fast++;
        }
        // return count;
        // 也可以不用计数器，直接返回slow
        return slow;
    }
};
```

相关题目：

[力扣26.删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

参考代码：

```c++
class Solution26
{
public:
    int removeDuplicates(std::vector<int> &nums)
    {
        // 双指针解法
        int size = nums.size();
        int slow = 0;
        int fast = 0;
        while (fast < nums.size())
        {
            if (nums[fast] != nums[slow])
            {
                // slow+1防止越界
                if (slow + 1 < nums.size())
                {
                    nums[slow + 1] = nums[fast];
                }
                slow++;
            }
            fast++;
        }

        return slow + 1;
    }
};
```

[力扣283.移动零](https://leetcode.cn/problems/move-zeroes/description/)

参考代码：

```c++
// 双指针解法，具体思路与上题类似
class Solution283
{
public:
    void moveZeroes(std::vector<int> &nums)
    {
        int prev = 0, cur = 0;
        while (cur < nums.size())
        {
            if (nums[cur])
                std::swap(nums[cur++], nums[prev++]);
            else
                cur++;
        }
    }
};
```

[力扣844.比较含退格的字符](https://leetcode.cn/problems/backspace-string-compare/description/)

参考代码：

=== "暴力解法"

    ```c++
    // 暴力解法——注意string类也有尾删操作
    class Solution844_1
    {
    public:
        std::string remove(std::string s)
        {
            // 暴力解法
            std::string ret;
            for (auto str: s)
            {
                if (str != '#')
                {
                    ret.push_back(str);
                }
                else if (!ret.empty())
                {
                    // string的尾删方法pop_back
                    ret.pop_back();
                }
            }

            return ret;
        }

        bool backspaceCompare(std::string s, std::string t)
        {
            return remove(s) == remove(t);
        }
    };
    ```

=== "双指针解法"

    ```c++
    // 双指针算法
    /*
    * 为什么：判断两个数组内容是否相等，可以定义指向两个数组的指针依次比较每一个字符
    * 如何用：本题涉及到退格符#，所以需要额外遇到#时候的情况，因为#只会影响左侧的字符而不会影响右侧的字符
    * 所以考虑从后往前遍历，但是考虑到#可能与下一个要删除的字符不是紧挨着，所以需要考虑使用一个计数器记录#的个数
    * 在遍历过程中，分为三种情况：
    * 1. 当#计数器为0，直接判断两个数组中的当前字符是否相等，不等则直接返回false，这里需要考虑其中一个可能是空数组
    * 2. 当有一方#计数器不为0，则让该方的下标指针向前移动，直到移动到计数器为0为止
    * 3. 如果当前字符是#，则#计数器加1，并且下标指针向前移动
    */
    class Solution844_2
    {
    public:
        bool backspaceCompare(std::string s, std::string t)
        {
            int si = s.size() - 1, ti = t.size() - 1;
            int skips = 0, skipt = 0;

            // 确保至少有一方有内容
            while (si >= 0 || ti >= 0)
            {
                // 遍历第一个字符数组
                while (si >= 0)
                {
                    if (s[si] == '#')
                    {
                        // 第三种情况
                        skips++;
                        si--;
                    }
                    else if (skips > 0)
                    {
                        // 第二种情况
                        si--;
                        skips--;
                    }
                    else
                    {
                        // 第一种情况
                        break;
                    }
                }
                // 遍历第二个字符数组
                while (ti >= 0)
                {
                    if (t[ti] == '#')
                    {
                        // 第三种情况
                        skipt++;
                        ti--;
                    }
                    else if (skipt > 0)
                    {
                        // 第二种情况
                        ti--;
                        skipt--;
                    }
                    else
                    {
                        // 第一种情况
                        break;
                    }
                }

                // 判断两个字符串当前字符是否相等
                // 必须确保两个字符串都有字符才进行当前字符是否相等的比较
                if (si >= 0 && ti >= 0)
                {
                    if (s[si] != t[ti])
                    {
                        return false;
                    }
                }
                else
                {
                    // 如果有一个字符数组为空，则直接返回false
                    if (si >= 0 || ti >= 0)
                    {
                        return false;
                    }
                }
                si--;
                ti--;
            }

            // 循环全部走完说明相同
            return true;
        }
    };
    ```

[力扣977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

参考代码：

=== "尾插+排序"

    ```c++
    // 尾插+排序
    class Solution977_1
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            std::vector<int> ret;
            for (auto num: nums)
            {
                ret.push_back(num * num);
            }
            std::sort(ret.begin(), ret.end());
            return ret;
        }
    };
    ```

=== "双指针算法（非原地处理；左闭右闭）"

    ```c++
    // 双指针算法（但非原地处理）
    /*
    * 为什么：本题中存在负数，并且数组是非递减顺序，
    * 所以最大值只有可能出现在最左侧（负数数值越小，平方后越大）和最右侧（正数数值越大，平方后越大）
    * 并且平方值向数组中间依次减小
    * 怎么做：考虑双指针异地处理，比较左指针和右指针对应的值的平方，大的就尾插到异地的数组中
    * 为了避免使用insert函数产生额外的时间复杂度，可以考虑提前开辟空间，并使用一个指针，起始位置指向异地数组的最后一个元素的位置
    */
    // 左闭右闭区间
    class Solution977_2
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            int left = 0, right = nums.size() - 1;
            std::vector<int> ret(nums.size());
            int reti = ret.size() - 1;
            while (left <= right)
            {
                int num1 = nums[left] * nums[left];
                int num2 = nums[right] * nums[right];
                if (num1 < num2)
                {
                    ret[reti--] = num2;
                    right--;
                }
                else
                {
                    ret[reti--] = num1;
                    left++;
                }
            }

            return ret;
        }
    };
    ```

=== "双指针算法（但非原地；左闭右开）"

    ```c++
    // 左闭右开区间
    class Solution977_3
    {
    public:
        std::vector<int> sortedSquares(std::vector<int> &nums)
        {
            int left = 0, right = nums.size();
            std::vector<int> ret(nums.size());
            int reti = ret.size() - 1;
            while (left < right)
            {
                int num1 = nums[left] * nums[left];
                int num2 = nums[right - 1] * nums[right - 1];
                if (num1 < num2)
                {
                    ret[reti--] = num2;
                    right--;
                }
                else
                {
                    ret[reti--] = num1;
                    left++;
                }
            }

            return ret;
        }
    };
    ```

## 滑动窗口专题

所谓滑动窗口，即为**同向双指针**移动过程中形成的间隔区域，并且这两个指针在移动的过程中不会回退

对于滑动窗口的题目可以抽象为下面的步骤：

1. 定义窗口两端指针`left`和`right`
2. 进入窗口
3. 判断
4. 离开窗口
5. 循环2、3和4步


以下面的题目为例：

[力扣209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

!!! quote
    给定一个含有 `n` 个正整数的数组和一个正整数 `target`。

    找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组**`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
    
    **示例 1：**

    ```c++
    输入：target = 7, nums = [2,3,1,2,4,3]
    输出：2
    解释：子数组 [4,3] 是该条件下的长度最小的子数组。
    ```

    **示例 2：**

    ```c++
    输入：target = 4, nums = [1,4,4]
    输出：1
    ```

    **示例 3：**
    
    ```c++
    输入：target = 11, nums = [1,1,1,1,1,1,1,1]
    输出：0
    ```

思路解析：

以下面的数组为例

```c++
[ 2,3,1,2,4,3 ]
```

本题首先想到的就是暴力解法，暴力解法的思路很简单，第一层`for`循环遍历，选出区间左端点，第二层`for`循环遍历，选出区间右端点，最后一次遍历，将左右区间中的值全部相加求和，标记此时子数组的长度，如此往复直到找到子数组长度最小且子数组中元素之和`>=target`。根据这个暴力思路得出其时间复杂度为O($N^3$)

```c++
// 暴力解法
class Solution 
{
public:
    int minSubArrayLen(int target, vector<int>& nums) 
    {
        int len = INT_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = 0; j < nums.size(); j++)
            {
                int sum = 0;
                for(int k = i; k <= j; k++)
                {
                    sum += nums[k];
                    if(sum >= target)
                    {
                        len = min(len, j - i + 1);
                    }
                }
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
```

在暴力思路的基础上思考如何降低时间复杂度

单调性：因为题目给出了一个条件**正整数的数组**，在正整数范围内求和可以得到一个单调性的规律：**加的数字越多和越大**，所以如果第一次找到了一个和满足`>=target`，则该下标后的数值即可不需要遍历，例如下图中的4和3即可不需要遍历

<img src="1. 数组基础篇.assets/image-20240708195838540.png" alt="image-20240708195838540" style="zoom:50%;" />

正向性：因为在上一次的遍历过程中，已经找到了一组子数组和满足`>=target`，并且根据单调性可以得出`right`不需要再向后移动，接下来需要更新`left`寻找下一组此时`left++`，那么此时`right`是否需要回退到`left`的位置重新再来一次遍历呢？**答案是不需要**，因为`left`在移动的过程中，区间`[left, right]`是开始时`(left=0)[left, right]`区间的子区间，所以此时的区间`(left=1)[left, right]`中的元素和即为`(left=0)[left,right]区间和-left(left=1)=0时的值`

由以上两个性质，可以将暴力解法优化到O(N)，即只需要一次遍历，而结合上面两种优化方式，可以得出滑动窗口算法

在本题中，滑动窗口的两端即为`left`和`right`，而滑动窗口中所维护的信息即为子数组之和`sum`，根据滑动窗口的基本解题步骤可以得出现在需要找到何时进窗口、判断以及何时出窗口

1. 何时进窗口：本题中，因为窗口中维护的信息是`sum`，所以当开始求和时即为进窗口
2. 判断：本题中，因为需要判断`sum>=target`，所以此为判断条件
3. 何时出窗口：本题中，根据判断条件`sum>=target`可以得出，此条件成立时，证明已经得出了一个合理的结果，需要更新`sum`和子数组长度`len`，并让`left`向后移动（移动窗口，即出窗口），这一过程被称为**更新结果**（更新结果一般是贯穿在滑动窗口的解题步骤中，具体在哪一步由题目决定）

!!! note
    需要注意，本题需要求出子数组长度的最小值，所以`len`不可以初始化为0，否则最后结果只会为0

具体步骤如下：

<img src="1. 数组基础篇.assets\长度最小的子串.gif">

参考代码如下：

```c++
class Solution209
{
public:
    int minSubArrayLen(int target, std::vector<int> &nums)
    {
        int start = 0;
        int len = INT_MAX; // 定义为最大值可以确保比较时一定可以取到最小值
        int sum = 0;
        for (int end = 0; end < nums.size(); end++)
        {
            // 通过end移动计算起始位置和终止位置区间的和sum
            sum += nums[end];
            // 如果sum大于等于target，说明已经找到符合条件的子数组，可以更新sum和start，准备下一次寻找子数组
            // 此处需要循环判断sum是否在start更新时依旧满足sum>=target，不满足时再更新end继续计算和
            // 否则就相当于移出窗口
            while (sum >= target)
            {
                // 先计算当前满足条件时的下标
                len = std::min(len, end - start + 1);
                // 更新start和sum
                sum -= nums[start];
                start++;
            }
        }

        // 如果不存在指定的子数组，则返回0
        if (len == INT_MAX)
        {
            return 0;
        }

        return len;
    }
};
```

相关题目：

[力扣3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

参考代码：

```c++
// 滑动窗口解法
/*
 * 本题整体思路与例题类似，唯一需要注意的就是因为要找出无重复字符，所以需要涉及到去重操作
 */
class Solution3
{
public:
    int lengthOfLongestSubstring(std::string s)
    {
        std::unordered_map<char, int> m;
        int len = 0;
        for (int start = 0, end = 0; end < s.size(); end++)
        {
            // 进入窗口
            // 向哈希表中添加字符，如果字符存在就改变计数器
            m[s[end]]++;

            // 更新窗口——目的是为了移除重复的元素
            while (m[s[end]] > 1)
            {
                m.find(s[start++])->second--;
            }
            len = std::max(len, end - start + 1);
        }

        return len;
    }
};
```

[力扣1004.最大连续1的个数Ⅲ](https://leetcode.cn/problems/max-consecutive-ones-iii/)

参考代码：

```c++
// 滑动窗口算法
/* 本题的主要思路就是通过记录0的个数（变向达到翻转0的目的）来构建一个滑动窗口
 * 本题需要注意使用一个计数器统计0的个数而非通过一个变量依次减少直到小于k
 * 因为小于k不止一个情况，例如k=2时，tmpk可以有0,1两种情况都小于k，甚至逻辑上还有可能存在负数
 * 但是考虑到大于k只需要考虑一次，尽管大于k有3,4...多种情况，但是第一次大于k只有一种情况
 * 所以通过计数器改变统计当前0的个数
 */
class Solution1004
{
public:
    int longestOnes(std::vector<int> &nums, int k)
    {
        int len = 0;
        // int tmpk = k;
        int zeroNum = 0;

        for (int left = 0, right = 0; right < nums.size(); right++)
        {
            // 变量依次减少的方式——复杂且不易控制
            // if(nums[end] == 0)
            // {
            //     tmpk--;
            // }

            // while(tmpk < k)
            // {

            // }

            // 进窗口
            if (nums[right] == 0)
            {
                zeroNum++;
            }

            // 更新窗口
            while (zeroNum > k)
            {
                // 不要在循环内部更新结果
                // len = max(len, right - left + 1);
                if (nums[left++] == 0)
                {
                    zeroNum--;
                }
            }
            // 注意，题目提到最多翻转k个0，所以可能出现翻转0,1,2,3...k
            // 言外之意就是翻转0的个数小于等于k
            // 故存在k特别大而zero一直不可能大于k的情况
            // 综上，考虑在循环外部更新结果
            len = std::max(len, right - left + 1);
        }

        return len;
    }
};
```

[力扣1658.将x减到0的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

参考代码：

=== "作者写法"
    ```c++
    /*
    * 本题使用到正难则反的策略
    * 因为本题既要考虑左侧又要考虑右侧，但是连续的部分是中间区域
    * 所以本题就可以转换为“求出最长的一段区间（此时剩余区间就是最小的）其中的和大于等于数组和sumNums-x”
    * 需要注意本题有两个特殊情况:
    * 1. 当sumNums-x == 0时，此时最小的操作数的个数就是整个数组
    * 2. 当sumNums-x < 0时，说明无法使x减到0，自然也就无法算出sumNums-x == target的情况
    */
    class Solution1658 {
    public:
        int minOperations(std::vector<int>& nums, int x) {
            int target = std::accumulate(nums.begin(), nums.end(), 0) - x;
            // 特判，当target刚好为0，说明此时最小的操作数的个数就是整个数组
            if(target == 0)
            {
                return nums.size();
            }
            // 定义变量记录区间和
            int sum = 0;
            // 定义变量记录区间长度
            int len = -1;
            for(int start = 0, end = 0; end < nums.size(); end++)
            {
                // 进入窗口
                sum += nums[end];

                // 更新窗口
                while(sum > target && start < end)
                {
                    sum -= nums[start++];
                }

                // 可能存在数组中的数据无法使x减到0，自然也就无法算出sumNums-x == target的情况
                if(sum == target)
                {
                    len = std::max(len, end - start + 1);
                }
            }

            // 返回最长区间的其他区间总长度即为所求
            return len == -1 ? -1 : nums.size() - len;
        }
    };
    ```

=== "其他写法"
    ```c++
    //其他写法
    class Solution1658 {
    public:
        int minOperations(std::vector<int>& nums, int x) {
            int sum = 0;
            for (int a : nums)
                sum += a;
            int target = sum - x;
            // 细节问题
            if (target < 0)
                return -1;
            int ret = -1;
            for (int left = 0, right = 0, tmp = 0; right < nums.size(); right++) {
                tmp += nums[right];      // 进窗?
                while (tmp > target)     // 判断
                    tmp -= nums[left++]; // 出窗?
                if (tmp == target)       // 更新结果
                    ret = std::max(ret, right - left + 1);
            }
            // 此处包括了一种情况：当x与sumNums完全相等的时候，此时区间和永远大于target，因为target为0
            if (ret == -1)
                return ret;
            else
                return nums.size() - ret;
        }
    };
    ```

[力扣904.水果成篮](https://leetcode.cn/problems/fruit-into-baskets/description/)

参考代码：

```c++
/*
 * 根据题目的描述，可以联想出本题涉及到一个窗口的进入和更新
 * 窗口进入：当前元素不存在时，插入到当前容器
 * 窗口更新：当元素个数超过两个时，考虑更新窗口直到重新满足条件
 * 本题并没有提到每一个元素只出现一次，但是需要确保容器中只有两个元素，所以需要用到可以去重的容器
 * 可以选择的结构：红黑树，容器对应的就是set和map，也可以考虑使用unordered_map或者unordered_set
 * 但是在更新窗口时，如果直接删除容器中的元素可能会因为每一个元素不止出现一次导致提前更新窗口
 * 例如[3,3,3,1,2,1,1,2,3,3,4]，如果直接使用一个红黑树容器，在插入时3,1,2，此时size为3需要更新窗口
 * 进入循环更新逻辑时，因为没有对元素进行计数，导致set直接删除start指向的第一个3，现在size重新回到2，循环提前结束
 * 所以可以考虑使用map或者unordered_map，如果元素不存在直接插入，否则只更新计数器
 * 最后，更新计数器不可以在更新窗口中更新，因为不能确定一定会出现3种水果
 */
class Solution904
{
public:
    int totalFruit(std::vector<int> &fruits)
    {
        int start = 0;
        int len = 0;
        std::unordered_map<int, int> m; // 使用unordered_map，查找的时间复杂度为O(1)
        for (int end = 0; end < fruits.size(); end++)
        {
            // 确定元素是否存在，不存在就添加
            m[fruits[end]]++;
            // 当不满足条件：两个篮子中的水果种类大于2种时调整窗口
            while (m.size() > 2)
            {
                // 直到指定元素的计数器为0时才删除，否则一直减少计数器
                if ((--(m.find(fruits[start])->second)) == 0)
                {
                    m.erase(fruits[start]);
                }
                // 更新窗口
                start++;
            }

            // 更新长度
            len = std::max(len, end - start + 1);
        }

        return len;
    }
};
```

[力扣438.找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

参考代码：

=== "标准库容器版本"
    ```c++
    // 滑动窗口算法——定长窗口
    // 使用库版本
    class Solution438_1 {
    public:
        std::unordered_map<char, int> ori, sub;
        bool check() {
            for (auto kv : sub) {
                if (ori[kv.first] != kv.second) {
                    return false;
                }
            }

            return true;
        }
        std::vector<int> findAnagrams(std::string s, std::string p) {
            std::vector<int> v;
            for(auto ch : p)
            {
                sub[ch - 'a']++;
            }
            for(int left = 0, right = 0; right < s.size(); right++)
            {
                // 进入窗口
                ori[s[right] - 'a']++;

                // 更新窗口
                if(right - left + 1 > p.size())
                {
                    ori[s[left] - 'a']--;
                    left++;
                }

                // 更新结果
                if(check())
                {
                    v.push_back(left);
                }
            }

            return v;
        }
    };
    ```

=== "容器优化版本"

    ```c++
    // 直接定址法
    // 元素有限时，可以考虑使用直接定址法，减少时间和空间的消耗
    class Solution438_2 {
    public:
        // 元素个数有限时，可以考虑使用直接定址法，减少时间和空间的消耗
        int ori[26] = {0}, sub[26] = {0};
        bool check() {
            for(size_t i = 0; i < 26; i++)
            {
                if(ori[i] != sub[i])
                {
                    return false;
                }
            }

            return true;
        }

        std::vector<int> findAnagrams(std::string s, std::string p) {
            std::vector<int> v;
            for(auto ch : p)
            {
                sub[ch - 'a']++;
            }
            for(int left = 0, right = 0; right < s.size(); right++)
            {
                // 进入窗口
                ori[s[right] - 'a']++;

                // 更新窗口
                if(right - left + 1 > p.size())
                {
                    ori[s[left] - 'a']--;
                    left++;
                }

                // 更新结果
                if(check())
                {
                    v.push_back(left);
                }
            }

            return v;
        }
    };
    ```

=== "比较逻辑优化版本"

    ```c++
    // 优化比较逻辑版本
    class Solution438_3 {
    public:
        // 元素个数有限时，可以考虑使用直接定址法，减少时间和空间的消耗
        int ori[26] = {0}, sub[26] = {0};
        std::vector<int> findAnagrams(std::string s, std::string p) {
            std::vector<int> v;
            // 存储有效字符个数
            int count = 0;
            for(auto ch : p)
            {
                sub[ch - 'a']++;
            }
            for(int left = 0, right = 0; right < s.size(); right++)
            {
                // 进入窗口
                ori[s[right] - 'a']++;
                // 维护有效字符个数
                // 当字符进入窗口后，如果当前比较的字符存在与ori中，但不存在于sub中，那么说明不是有效字符，count不变
                // 如果既存在于ori，也存在于sub中，说明是有效字符
                // 注意需要小于等于而不是仅等于，因为可能存在重复字符
                if(ori[s[right] - 'a'] <= sub[s[right] - 'a'])
                {
                    count++;
                }

                // 更新窗口
                if(right - left + 1 > p.size())
                {
                    // 出窗口前维护有效字符个数
                    // 维护有效字符个数有三种情况：
                    // 1. 当出去的字符在哈希表ori中的个数比哈希表sub中的多，此时说明移出去的是多余的字符，不需要更新count
                    // 2. 当出去的字符在哈希表ori中的个数与哈希表sub中的相等，此时说明有效字符被移除，需要更新count
                    // 3. 当出去的字符在哈希表ori中不存在，但是在哈希表sub中存在，此时个数关系就是小于
                    //    当前这个情况就是说明sub中有重复的字符，此时ori中只出现了一次这个重复字符但是要被移除，
                    //    所以依旧是有效字符被移除，需要更新count，例如s="abacc" p="abbc"
                    if(ori[s[left] - 'a'] <= sub[s[left] - 'a'])
                    {
                        count--;
                    }

                    ori[s[left] - 'a']--;
                    left++;
                }

                // 更新结果优化版
                // 如果有效字符个数与p的长度相同，则一定是异位词
                if(count == p.size())
                {
                    v.push_back(left);
                }
            }

            return v;
        }
    };
    ```

[力扣30.串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)

参考代码：

```c++
/*
 * 本题主体思路与上题相同，但是需要注意的是，本题比较的不是字符，而是字符串
 * 可以考虑使用整体法，因为题目提到了words中的每一个字符的长度相同，并且words数组的长度并不是很长
 * 比较时取出s中长度与words中每一个字符串长度相同的子字符串比较，剩余的思路就和上题一样
 */
// 滑动窗口算法——定长
class Solution30 {
public:
    std::unordered_map<std::string, int> ori, sub;
    std::vector<int> findSubstring(std::string s, std::vector<std::string>& words) {
        std::vector<int> v;
        for(auto& str : words)
        {
            sub[str]++;
        }
        // 每个单词的长度
        int sz = words[0].size();
        // 控制滑动窗口执行的次数
        for(int count = 0; count < sz; count++)
        {
            // 滑动窗口
            // right+sz总共就是words的总长度，所以需要注意可以相等
            for(int left = count, right = count, cnt = 0; right + sz <= s.size(); right += sz)
            {
                // 进入窗口
                std::string str = s.substr(right, sz);
                ori[str]++;
                // 判断是否更新有效字符个数
                // 先判断sub中有对应的字符串，再进行比较，否则当sub中没有指定的元素会进行插入，从而产生时间和空间消耗
                if(sub.count(str) && ori[str] <= sub[str])
                {
                    cnt++;
                }

                // 更新窗口
                if(right - left + 1 > sz * words.size())
                {
                    std::string tmp = s.substr(left, sz);
                    // 更新计数器
                    if(sub.count(tmp) &&ori[tmp] <= sub[tmp])
                    {
                        cnt--;
                    }

                    ori[tmp]--;
                    left += sz;
                }

                // 更新结果
                if(cnt == words.size())
                {
                    v.push_back(left);
                }
            }
            ori.clear();
        }
        return v;
    }
};
```

[力扣76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

参考代码：

=== "库函数版本"
    ```c++
    /*
    * 本题暴力思路：枚举出所有包含查找子串的所有字符的字符串，比较长度取出最小的子串
    * 本题可以考虑使用滑动窗口的方法
    * 为什么：根据暴力解法，每一次枚举所有包含的子串这个过程中涉及到一些重复的步骤，例如已经完全包含内容的子串被多次枚举
    * 而如果需要将这个过程中的枚举次数减少，策略就是找到最接近最优解的一个子串，整个遍历过程中，当一个指针在遍历s字符串时
    * 这个指针离起始位置的距离越来越远，此时与起始位置的指针就构成一个区间，而当刚好满足找到子串的条件时，就需要减小区间
    * 确保能找到更小一点的区间，而这个过程就正好满足不定长滑动窗口的过程
    * 怎么用：
    * 1. 题目提到了t字符串中的重复字符也需要完全匹配，所以需要使用哈希表来统计出现的次数
    * 2. 构建窗口：在t字符串的哈希表m中找s字符串中的字符，如果出现添加到另一个哈希表c中进行计数，方便更新窗口时比较
    * 3. 更新窗口：当哈希表sub中字符的个数与ori中对应的字符个数相同或者ori中的对应字符个数大于sub中字符的个数，说明一定存在子串包含t中的所有字符，此时就需要更新窗口
    *             否则一定不需要更新窗口。更新窗口的过程中需要记录当前子串的长度已经起始位置方便最后截取字符串，注意一定要比较新的len和已经记录的len，
    *             当新的len较小时再更新起始位置，否则会出现起始位置一直被更新，包括新len和旧len相同的情况
    *             更新逻辑：让ori中的字符个数与sub中的字符个数不匹配，即类似于从ori中依次移除出现于t中的字符
    * 4. 本题只需要考虑短的字符串中的字符即可，对于s字符串来说，其他字符是否存在不需要考虑（因为插入会有一定时间和空间消耗）
    *
    */
    // 滑动窗口
    class Solution76_1 {
    public:
        std::unordered_map<char, int> ori, sub;
        // 判断字符个数
        bool check()
        {
            for(auto& kv : sub)
            {
                // 当ori中对应的字符个数少于sub中对应字符的个数时说明此时并不满足覆盖条件
                if(ori[kv.first] < kv.second)
                {
                    return false;
                }
            }

            return true;
        }
        std::string minWindow(std::string s, std::string t) {
            int len = INT_MAX;
            int start = 0;
            // 统计t中字符出现的次数
            for(auto& ch : t)
            {
                sub[ch]++;
            }

            for(int left = 0, right = 0; right < s.size(); right++)
            {
                // 进窗口
                // ori[s[right]]++;
                // 只有含有t中字符的时候才插入
                if(sub.find(s[right]) != sub.end())
                {
                    ori[s[right]]++;
                }
                // 更新窗口
                while(check())
                {
                    // 更新结果
                    // start = left;
                    // len = min(len, right - left + 1);
                    if(right - left + 1 < len)
                    {
                        len = right - left + 1;
                        start = left;
                    }
                    // ori[s[left]]--;
                    // 只有是t中的字符才删除
                    if(sub.find(s[left]) != sub.end())
                    {
                        ori[s[left]]--;
                    }
                    left++;
                }
            }

            return len == INT_MAX ? std::string() : s.substr(start, len);
        }
    };
    ```

=== "优化比较逻辑版本"

    ```c++
    /*
    * 与前面类似，本次优化版本主要优化比较方式，利用一个变量来统计字符种类，此处不是字符个数
    * 统计字符种类的逻辑与字符个数不同，统计种类时只需要保证出现的字符是t中的字符且对应字符出现的个数等于t中对应字符的个数就算一次种类更新，否则就不算
    * 之所以要确保个数相等是因为t中可能存在重复字符，出现重复字符必须保证s中也有相同数量的重复字符，如果只统计第一次出现，则不能保证s中的重复字符数量与t中相同
    * 而如果是统计字符个数只需要满足是t中的字符就更新
    */
    class Solution76_2 {
    public:
        std::unordered_map<char, int> ori, sub;
        std::string minWindow(std::string s, std::string t) {
            int len = INT_MAX;
            int start = 0;
            // 统计t中字符出现的次数
            for(auto& ch : t)
            {
                sub[ch]++;
            }

            // 使用count统计字符种类
            for(int left = 0, right = 0, count = 0; right < s.size(); right++)
            {
                // 进窗口
                // ori[s[right]]++;
                // 只有含有t中字符的时候才插入
                if(sub.find(s[right]) != sub.end())
                {
                    ori[s[right]]++;
                    // 统计字符种类
                    if(ori[s[right]] == sub[s[right]])
                    {
                        count++;
                    }
                }
                // 更新窗口
                while(count == sub.size())
                {
                    // 更新结果
                    // start = left;
                    // len = min(len, right - left + 1);
                    if(right - left + 1 < len)
                    {
                        len = right - left + 1;
                        start = left;
                    }
                    // ori[s[left]]--;
                    // 只有是t中的字符才删除
                    if(sub.find(s[left]) != sub.end())
                    {
                        // 更新计数器
                        if(ori[s[left]] == sub[s[left]])
                        {
                            count--;
                        }
                        ori[s[left]]--;
                    }
                    left++;
                }
            }

            return len == INT_MAX ? std::string() : s.substr(start, len);
        }
    };
    ```

=== "容器优化版本"

    ```c++
    /*
    * 本题因为只含有字母，所以可以考虑使用一个数组形式的哈希表
    */
    class Solution76_3 {
    public:
        // unordered_map<char, int> ori, sub;
        int ori[128] = {0}, sub[128] = {0};
        // 判断字符个数
        std::string minWindow(std::string s, std::string t) {
            int len = INT_MAX;
            int start = 0;
            // 统计t中字符出现的次数
            // 注意因为在函数中要比较种类，所以在映射开始之前需要先判断某个字符是不是第一次出现
            // 如果是第一次出现种类计数器就更新，否则就不更新
            // 种类计数器
            int kinds = 0;
            for(auto& ch : t)
            {
                // 第一次出现的字符，更新种类计数器
                if(sub[ch] == 0)
                {
                    kinds++;
                }
                sub[ch]++;
            }

            // 使用count统计字符种类
            for(int left = 0, right = 0, count = 0; right < s.size(); right++)
            {
                ori[s[right]]++;
                // 统计字符种类
                if(ori[s[right]] == sub[s[right]])
                {
                    count++;
                }
                // 更新窗口
                while(count == kinds)
                {
                    // 更新结果
                    if(right - left + 1 < len)
                    {
                        len = right - left + 1;
                        start = left;
                    }
                    // 更新计数器
                    if(ori[s[left]] == sub[s[left]])
                    {
                        count--;
                    }
                    ori[s[left]]--;
                    left++;
                }
            }

            return len == INT_MAX ? std::string() : s.substr(start, len);
        }
    };
    ```