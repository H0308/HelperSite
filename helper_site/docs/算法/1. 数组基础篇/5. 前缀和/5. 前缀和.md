# 前缀和

## 介绍

在计算数组元素之和时，最直观的思路就是依次遍历数组取出元素并相加，但是这个思路的时间复杂度为$O(N)$，如果数组元素非常多，就会面临执行时间长的问题

为了尽可能降低操作时间，考虑一种思路：每一次计算当前元素以及之前的元素之和存储到一个新的数组中，当需要获取原数组指定位置之前的元素之和时，只需要在新数组中的对应位置找到结果即可

例如下面的一个示例：

假设要计算一个数组`[1,2,3,3,2,1,2]`，则其和的数组为`[1,3,6,9,11,12,14]`，计算过程如下图所示：

<img src="5. 前缀和.assets\Snipaste_2024-10-31_09-29-28.png">

但是观察数组的形式，和数组当前位置的前一个位置就是原数组当前位置之前的元素之和，而需要计算原数组当前位置及之前元素的总和就只需要将当前位置之前的和加上当前元素即可，所以，上面的加法过程还可以简化为如下步骤：

<img src="5. 前缀和.assets\Snipaste_2024-10-31_19-42-30.png">

在上图中可以看出，需要求从0号位置开始，到1号位置结束的元素之和就只需要在和数组中直接取出1号位置的元素即可获得两个元素的和。同理，需要求1号位置开始，到5号位置结束，中间的元素之和，只需要让和数组中5号位置的元素减去1号位置之前的元素即可获得原数组从1号位置开始，到5号位置结束的元素之和

假设待求和的数组为`arr`，和数组为`sum`，则上面的描述用下面的表达式表示为：

1. 从0号位置开始，到1号位置结束的元素之和
    `arr[0] + arr[1] = sum[1]`
2. 从1号位置开始，到5号位置结束，中间的元素之和
    `arr[1] + arr[2] + arr[3] + arr[4] + arr[5] = sum[5] - sum[0]`

在上面的例子中，和数组`sum`存储的值是当前位置的元素及其前面所有元素的和，所以这个和也被称为「前缀和」，而对应的和数组`sum`被称为「前缀和数组」。在前面也看到，前缀和最常用的题型就是计算一个连续区间的和

## 示例题目

[卡码网KamaCoder.区间和](https://kamacoder.com/problempage.php?pid=1070)

**问题描述：**

!!! quote
    **题目描述**

    给定一个整数数组Array，请计算该数组在每个指定区间内元素的总和。

    **输入描述**

    第一行输入为整数数组 Array 的长度`n`，接下来`n`行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：`a`，`b` （`b` > = `a`），直至停止输入（遇到文件末尾）

    **输出描述**

    输出每个指定区间内元素的总和。

    **输入示例**

    ```c++
    5
    1
    2
    3
    4
    5
    0 1
    1 3
    ```

    **输出示例**

    ```c++
    3
    9
    ```

**思路分析：**

1. 解法1：暴力解法

    本题的暴力解法就是前面提到的根据区间划分起始位置和终止位置，从起始位置开始依次向后遍历直到终止位置，在遍历过程中累加获取到的元素即可求出区间和，但是这个解法在数据量巨大时会超时

2. 解法2：前缀和

    思路见前面的介绍

**关键步骤：**

本题最关键的问题就是求前缀和以及获取指定区间的和

首先对于求前缀和，考虑下面两种方式：

1. 假设`sum`为前缀和数组，`arr`为原数组，`i`为下标（从0开始），代码如下：

    ```c++
    sum[i] += arr[i] + sum[i - 1];
    ```

2. 假设`sumArr`存储元素之和，`sum`为前缀和数组，`arr`为原数组，`i`为下标（从0开始），代码如下：

    ```c++
    sumArr += arr[i];
    sum[i] = sumArr;
    ```

这两种方式中，第一种方式是一种当前情况下是不合适的求和方式，因为如果`i`为第一个元素，则对于第一个元素来说就需要单独进行处理，即`sum[i] = arr[i]`，而第二种方式适用性更加广泛，所以推荐第二种

接下来考虑获取指定区间的和，从前面的介绍可以看出，如果指定区间的起始位置为0下标，则直接获取终止位置在前缀和数组中对应的值即可，但是对于起始位置不是0下标，则需要通过终止位置在前缀和数组中对应的值减去起始位置的前一个位置的下标在前缀和数组中对应的值，根据题目，`a`为起始位置，`b`为终止位置，结果为`result`，代码表示如下：

```c++
if(!a)
    result = sum[b];
else
    result = sum[b] - sum[a - 1];
```

**优化思路：**

前面提到两种求前缀和的方式，如果前缀和数组下标从0开始，就必须采用第二种方式，并且在使用前缀和数组时还有单独考虑起始位置为0的情况，整个过程中的步骤有点繁琐。现在考虑如何使用第一种方式从而去除繁杂的分支语句，因为当前缀和数组下标为0时，`sum[a-1]`就会变为`sum[-1]`，那么就考虑让和数组的有效元素从下标1位置开始存储，同时也让原数组的有效元素从1位置开始存储，否则`a`依旧可以为0。使用这种做法就可以确保`sum[a-1]`变为`sum[0]`而不是`sum[-1]`

现在就需要考虑第二个问题，`sum[0]`的值是多少合适，很明显，一个数加0还是原数，一个数减去0也是原数，所以`sum[0]=0`

根据前面的优化思路，就可以对代码进行优化

首先是开辟原数组和前缀和数组，假设`n`代表数组中的元素个数，代码如下：

```c++
// 原数组
vector<int> arr(n + 1);
// 前缀和数组
vector<int> sum(n + 1);
```

接着是求前缀和存储到前缀和数组中，代码如下：

```c++
// 当前元素+之前元素的和
sum[i] = arr[i] + sum[i - 1];
```

最后就是使用前缀和数组，根据题目要求可知左边界为`a`，右边界为`b`，假设结果为`result`，代码如下：

```c++
// 当前元素及之前元素的总和减去左边界前一个元素及其之前所有元素的和
result = sum[b] - sum[a - 1];
```

**思考问题：**

原数组是否一定需要从下标为1位置开始存储？

其实可以不需要，但是在计算前缀和时需要正确映射，否则可能越界，示意图如下：

<img src="5. 前缀和.assets\Snipaste_2024-10-31_20-07-04.png">

观察上图，可以看到当计算原数组中第一个元素（下标为0）的和时，其和映射在前缀和数组第二个元素的位置（下标为1），计算原数组中第二个元素（下标为1）及之前元素的和时，利用原数组的当前元素（下标为1）与前缀和数组中前一个元素（下标为1）进行求和，其和映射在前缀和数组第三个元素的位置（下标为2）。假设`sum`代表前缀和数组，`arr`代表原数组，`i`代表下标（原数组有效元素从0开始，前缀和数组有效元素从1开始），可以推出求和代码如下：

```c++
sum[i + 1] = sum[i] + arr[i];
```

!!! note

    注意，`sum[0]`还是等于0

**参考代码：**

=== "暴力解法"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main()
    {
        // 解除同步
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        vector<int> arr(len);

        for(int i = 0; i < len; i++)
            cin >> arr[i];

        int a = 0, b = 0;
        int sum = 0;
        while(cin >> a >> b)
        {
            for(int i = a; i <= b; i++)
                sum += arr[i];
            cout << sum << endl;

            sum = 0;
        }

        return 0;
    }
    ```

=== "前缀和（两个数组第一个元素下标为0）"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main()
    {
        // 解除同步
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        // 元素数组
        // 前缀和数组有效元素从0开始
        vector<int> arr(len);
        // 前缀和数组
        // 前缀和数组有效元素从0开始
        vector<int> sum(len);

        int sumArr = 0;
        for(int i = 0; i < len; i++)
        {
            cin >> arr[i];

            // 计算前缀和
            sumArr += arr[i];
            sum[i] = sumArr;
        }

        int a = 0, b = 0;
        while(cin >> a >> b)
        {
            // 求和
            if(a == 0)
                cout << sum[b] << endl;
            else
                cout << sum[b] - sum[a - 1] << endl;
        }

        return 0;
    }
    ```

=== "前缀和（两个数组第一个元素下标为1）"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main()
    {
        // 解除同步
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        // 元素数组
        // 原数组有效元素从1开始
        vector<int> arr(len + 1);
        // 前缀和数组
        // 前缀和数组有效元素从1开始
        vector<int> sum(len + 1);

        int sumArr = 0;
        for(int i = 1; i <= len; i++)
        {
            cin >> arr[i];

            // 计算前缀和
            sum[i] = sum[i - 1] + arr[i];
        }

        int a = 0, b = 0;
        while(cin >> a >> b)
        {
            // 求和
            // 注意本题的a和b都是从0开始
            // 对于长度为len+1的前缀和数组来说，a位置实际上对应的有效元素是sum[a+1]
            // cout << sum[b + 1] - sum[a - 1 + 1] << endl;
            // 简化为
            cout << sum[b + 1] - sum[a] << endl;
        }

        return 0;
    }
    ```

=== "前缀和（前缀和数组第一个元素下标为1）"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main()
    {
        // 解除同步
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        // 元素数组
        // 原数组有效元素从0开始
        vector<int> arr(len);
        // 前缀和数组
        vector<int> sum(len + 1);

        int sumArr = 0;
        for(int i = 0; i < len; i++)
        {
            cin >> arr[i];

            // 计算前缀和
            sum[i + 1] = sum[i] + arr[i];
        }

        int a = 0, b = 0;
        while(cin >> a >> b)
        {
            // 求和
            cout << sum[b + 1] - sum[a] << endl;
        }

        return 0;
    }
    ```