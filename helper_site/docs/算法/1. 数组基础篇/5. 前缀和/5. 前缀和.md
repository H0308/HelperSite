# 前缀和

## 介绍

在计算数组元素之和时，最直观的思路就是依次遍历数组取出元素并相加，但是这个思路的时间复杂度为$O(N)$，如果数组元素非常多，就会面临执行时间长的问题

为了尽可能降低操作时间，考虑一种思路：每一次计算当前元素以及之前的元素之和存储到一个新的数组中，当需要获取原数组指定位置之前的元素之和时，只需要在新数组中的对应位置找到结果即可

例如下面的一个示例：

假设要计算一个数组`[1,2,3,3,2,1,2]`，则其和的数组为`[1,3,6,9,11,12,14]`，计算过程如下图所示：

<img src="5. 前缀和.assets\Snipaste_2024-10-31_09-29-28.png">

在上图中可以看出，需要求从0号位置开始，到1号位置结束的元素之和就只需要在和数组中直接取出1号位置的元素即可获得两个元素的和。同理，需要求1号位置开始，到5号位置结束，中间的元素之和，只需要让和数组中5号位置的元素减去1号位置之前的元素即可获得原数组从1号位置开始，到5号位置结束的元素之和

假设待求和的数组为`arr`，和数组为`sum`，则上面的描述用下面的表达式表示为：

1. 从0号位置开始，到1号位置结束的元素之和
    `arr[0] + arr[1] = sum[1]`
2. 从1号位置开始，到5号位置结束，中间的元素之和
    `arr[1] + arr[2] + arr[3] + arr[4] + arr[5] = sum[5] - sum[0]`

在上面的例子中，和数组`sum`存储的值是当前位置的元素及其前面所有元素的和，所以这个和也被称为「前缀和」，而对应的和数组`sum`被称为「前缀和数组」。在前面也看到，前缀和最常用的位置就是计算一个区间的和

## 示例题目

[卡码网KamaCoder.区间和](https://kamacoder.com/problempage.php?pid=1070)

**问题描述：**

!!! quote
    **题目描述**
    给定一个整数数组Array，请计算该数组在每个指定区间内元素的总和。

    **输入描述**

    第一行输入为整数数组 Array 的长度`n`，接下来`n`行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：`a`，`b` （`b` > = `a`），直至停止输入（遇到文件末尾）

    **输出描述**

    输出每个指定区间内元素的总和。

    **输入示例**

    ```c++
    5
    1
    2
    3
    4
    5
    0 1
    1 3
    ```

    **输出示例**

    ```c++
    3
    9
    ```

**思路分析：**

1. 解法1：暴力解法
    本题的暴力解法就是前面提到的根据区间划分起始位置和终止位置，从起始位置开始依次向后遍历直到终止位置，在遍历过程中累加获取到的元素即可求出区间和，但是这个解法在数据量巨大时会超时

2. 解法2：前缀和
    思路见前面的介绍

**关键步骤：**

本题最关键的问题就是求前缀和以及获取指定区间的和

首先对于求前缀和，考虑下面两种方式：

1. 假设`sum`为前缀和数组，`arr`为原数组，`i`为下标，代码如下：

    ```c++
    sum[i] += arr[i] + sum[i - 1];
    ```

2. 假设`sumArr`存储元素之和，`sum`为前缀和数组，`arr`为原数组，`i`为下标，代码如下：

    ```c++
    sumArr += arr[i];
    sum[i] = sumArr;
    ```

这两种方式中，第一种方式是一种不推荐的求和方式，因为如果i为第一个元素，则对于第一个元素来说就需要单独进行处理，即`sum[i] = arr[i]`，而第二种方式适用性更加广泛，所以推荐第二种

接下来考虑获取指定区间的和，从前面的介绍可以看出，如果指定区间的起始位置为0下标，则直接获取终止位置在前缀和数组中对应的值即可，但是对于起始位置不是0下标，则需要通过终止位置在前缀和数组中对应的值减去起始位置的前一个位置的下标在前缀和数组中对应的值，根据题目，`a`为起始位置，`b`为终止位置，结果为`result`，代码表示如下：

```c++
if(!a)
{
    result = sum[b];
}
else
{
    result = sum[b] - sum[a - 1];
}
```

**参考代码：**

=== "暴力解法"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    // 卡码网KamaCoder.区间和：暴力解法
    int main()
    {
        // 解除同步
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        vector<int> arr(len);

        for(int i = 0; i < len; i++)
        {
            cin >> arr[i];
        }

        int a = 0, b = 0;
        int sum = 0;
        while(cin >> a >> b)
        {
            for(int i = a; i <= b; i++)
            {
                sum += arr[i];
            }
            cout << sum << endl;

            sum = 0;
        }

        return 0;
    }
    ```

=== "前缀和"

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main()
    {
        // 解除同步
        std::ios::sync_with_stdio(false);
        std::cin.tie(nullptr);

        // 输入数组长度
        int len = 0;
        cin >> len;

        // 元素数组
        vector<int> arr(len);
        // 前缀和数组
        vector<int> sum(len);

        int preSum = 0;
        for(int i = 0; i < len; i++)
        {
            cin >> arr[i];

            // 计算前缀和
            sumArr += arr[i];
            sum[i] = sumArr;
        }

        int a = 0, b = 0;
        while(cin >> a >> b)
        {
            // 求和
            if(a == 0)
            {
                cout << sum[b] << endl;
            }
            else
            {
                cout << sum[b] - sum[a - 1] << endl;
            }
        }

        return 0;
    }
    ```