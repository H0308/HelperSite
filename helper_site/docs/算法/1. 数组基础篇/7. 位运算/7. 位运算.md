# 位运算

## 介绍

在部分算法题中，使用位运算可能可以更好得达到题目的要求，在C/C++中，常见的位运算符有下面几种：

1. [左移运算`<<`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_8)
2. [右移运算`>>`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_9)
3. [按位与`&`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_19)
3. [按位或`|`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_20)
4. [按位异或`^`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_21)
5. [按位取反`~`](https://www.helper-wiki.top/C%E8%AF%AD%E8%A8%80/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6/4.%20C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6.html#_22)

其中，对于按位与来说，其规律就是「有0则0」；对于按位或来说，其规律就是「有1则1」；对于按位异或来说，其基本规律就是「相同则0，相异则1」，实际上按位异或还可以理解为「无进位相加」

下面重点解释一下按位异或的「无进位相加」

<img src="7. 位运算.assets\Snipaste_2024-11-08_10-47-08.png">

在二进制加法计算中，`1 + 1 = 10`，此时结果`10`的高位`1`属于进位的结果，在上图中`1 ^ 1 = 0`，而其他的计算都不改变，例如`1 ^ 0 = 1`，`0 ^ 0 = 0`且都等于`1 + 0`和`0 + 0`

所以按位异或可以理解为没有进位版本的加法，即「无进位相加」

## 常见的位运算操作

介绍完常见的位运算符后，下面介绍常见的位运算操作：

1. 给定一个数`n`，确定其二进制表示中的第`i`位是0还是1

    思路：`(n >> i)  & 1`

    原理：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_10-58-31.png">

    !!! note

        注意，二进制最低位下标为0，依次向左增大，所以当i为0时，则上面的计算式`(n >> i)  & 1`就变为`n & 1`，即原数值，所以当i为1时，就是移动低第二位

2. 给定一个数`n`，将其二进制表示中的第`i`位的修改为1

    思路：`n |= (1 << i)`

    原理：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-09-09.png">

3. 给定一个数`n`，将其二进制表示中的第`i`位的修改为0

    思路：`n &= (~(1 << i))`

    原理：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-13-19.png">

4. 位图思想：前面的三种方式如果看过[位图部分](https://www.helper-wiki.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.%20%E4%BD%8D%E5%9B%BE/14.%20%E4%BD%8D%E5%9B%BE.html#_3)就会感觉很熟悉，其实就是位图的基本操作

5. 提取一个数`n`的二进制表示中最右侧的1（也被称为`lowbit`）

    思路：`n & (-n)`

    原理：

    理解本思路的原理，就需要理解`-n`的原理，计算一个正数的负数的方式为按位取反加1，过程如下：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-22-07.png">

    可以看到，`-n`的结果中，从某一位开始，该位左侧的二进制与原数值刚好是按位取反的结果，该位右侧的二进制与原数值相同

    接着将`-n`与原数值按位与就可以得到下面的结果：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-27-07.png">

    可以看到，原数值`n`二进制表示中最低位的1因为其`-n`左侧的二进制是原数值的按位取反结果，所以按位与之后结果只会为0，而右侧不变，既然是最低位的1，所以该1的右侧绝对都是0，最后获取到的数值只会在原数值的二进制表示中最低位为1的位置为1

6. 将一个数`n`的二进制表示中最右侧的1变为0

    思路：`n & (n - 1)`

    原理：

    理解本思路的原理，就需要理解`n - 1`的原理，一个数值减1，就代表其二进制最低位需要减1，但是如果最右侧的1不在原数值二进制表示中的最低位，此时就需要向前借位，一直会借到最右侧的1为止，过程如下：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-39-25.png">

    所以`n - 1`的本质就是让最右侧的1因为借位变为0，达到从被借位的位置开始，其左侧的二进制与原数的二进制相同，其右侧的二进制位与原数的二进制刚好为按位取反的结果

    接着再与原数值按位与，就可以保证最右侧的1变为0，而其右侧的0因为是按位与，使得最后的结果依旧为0，左侧因为保持不变，所以按位与也不会改变原数值的二进制，过程如下：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-43-32.png">

7. 异或相关操作，假设一个数值为`a`

    1. `a ^ a = 0`
    2. `a ^ 0 = a`
    3. `a ^ b ^ c = a ^ (b ^ c)`（异或运算的结合律）

    其中，前面两个操作是异或运算的基本操作，而第三种，正是因为有结合律，就可以确保多个数值异或运算过程中不需要考虑计算顺序，其原理就是利用了异或运算的「无进位加法」的特点，例如下面的过程：

    <img src="7. 位运算.assets\Snipaste_2024-11-08_11-52-59.png">

