# 滑动窗口算法介绍

所谓滑动窗口，即为**同向双指针**移动过程中形成的间隔区域，并且这两个指针在移动的过程中不会回退

<img src="2. 滑动窗口算法.assets/image-20240708142420606-1720419867003-1.png" alt="image-20240708142420606" style="zoom: 50%;" />

对于滑动窗口的题目可以抽象为三个步骤：

1. 定义窗口两端指针`left`和`right`
2. 进入窗口
3. 判断
4. 离开窗口
5. 循环2、3和4步

## 滑动窗口练习

### 长度最小的子数组

题目链接：[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

!!! quote
    给定一个含有 `n` 个正整数的数组和一个正整数 `target`。

    找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组**`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

思路解析：

以下面的数组为例

```c++
[ 2,3,1,2,4,3 ]
```

本题首先想到的就是暴力解法，暴力解法的思路很简单，第一层`for`循环遍历，选出区间左端点，第二层`for`循环遍历，选出区间右端点，最后一次遍历，将左右区间中的值全部相加求和，标记此时子数组的长度，如此往复直到找到子数组长度最小且子数组中元素之和`>=target`。根据这个暴力思路得出其时间复杂度为O($N^3$)

```c++
// 暴力解法
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = INT_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = 0; j < nums.size(); j++)
            {
                int sum = 0;
                for(int k = i; k <= j; k++)
                {
                    sum += nums[k];
                    if(sum >= target)
                    {
                        len = min(len, j - i + 1);
                    }
                }
            }
        }
        return len == INT_MAX ? 0 : len;
    }
};
```

在暴力思路的基础上思考如何降低时间复杂度

单调性：因为题目给出了一个条件**正整数的数组**，在正整数范围内求和可以得到一个单调性的规律：**加的数字越多和越大**，所以如果第一次找到了一个和满足`>=target`，则该下标后的数值即可不需要遍历，例如下图中的4和3即可不需要遍历

<img src="2. 滑动窗口算法.assets/image-20240708195838540.png" alt="image-20240708195838540" style="zoom:50%;" />

正向性：因为在上一次的遍历过程中，已经找到了一组子数组和满足`>=target`，并且根据单调性可以得出`right`不需要再向后移动，接下来需要更新`left`寻找下一组此时`left++`，那么此时right是否需要回退到left的位置重新再来一次遍历呢？**答案是不需要**，因为`left++`，此时区间`[left, right]`是开始时`(left=0)[left, right]`区间的子区间，所以此时的区间`(left=1)[left, right]`中的元素和即为`开始元素和-left=0时的值`，所以可以得出，`right`在整个遍历过程中是不需要回退的，即保持正向移动，而`left`本身移动的方向为从左向右，所以`left`方向也是正向的

由以上两个性质，可以将暴力解法优化到O(N)，即只需要一次遍历，而结合上面两种优化方式，可以得出滑动窗口算法

在本题中，滑动窗口的两端即为`left`和`right`，而滑动窗口中所维护的信息即为子数组之和`sum`，根据滑动窗口的基本解题步骤可以得出现在需要找到何时进窗口、判断以及何时出窗口

1. 何时进窗口：本题中，因为窗口中维护的信息是`sum`，所以当开始求和时即为进窗口
2. 判断：本题中，因为需要判断`sum>=target`，所以此为判断条件
3. 何时出窗口：本题中，根据判断条件`sum>=target`可以得出，此条件成立时，证明已经得出了一个合理的结果，需要更新`sum`和子数组长度`len`，并让`left`向后移动（移动窗口，即出窗口），这一过程被称为**更新结果**（更新结果一般是贯穿在滑动窗口的解题步骤中，具体在哪一步由题目决定）

!!! note
    需要注意，本题需要求出子数组长度的最小值，所以`len`不可以初始化为0，否则最后结果只会为0

具体步骤如下：

<img src="2. 滑动窗口算法.assets/image-20240708212431866.png" alt="image-20240708212431866" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212444674.png" alt="image-20240708212444674" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212459546.png" alt="image-20240708212459546" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212509146.png" alt="image-20240708212509146" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212521054.png" alt="image-20240708212521054" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212531259.png" alt="image-20240708212531259" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212541078.png" alt="image-20240708212541078" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212550147.png" alt="image-20240708212550147" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212608267.png" alt="image-20240708212608267" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212619877.png" alt="image-20240708212619877" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212630504.png" alt="image-20240708212630504" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212640958.png" alt="image-20240708212640958" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212650912.png" alt="image-20240708212650912" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212701390.png" alt="image-20240708212701390" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212710039.png" alt="image-20240708212710039" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212718730.png" alt="image-20240708212718730" style="zoom:50%;" />

<img src="2. 滑动窗口算法.assets/image-20240708212727983.png" alt="image-20240708212727983" style="zoom:50%;" />

参考代码如下：

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = INT_MAX, size = nums.size();
        int sum = 0;
        for(int left = 0, right = 0; right < size; right++)
        {
            // 进窗口
            sum += nums[right];
            // 判断
            while(sum >= target)
            {
                // 更新结果，出窗口
                len = min(len, right - left + 1);
                sum -= nums[left++];
            }
        }

        return len == INT_MAX ? 0 : len;
    }
};
```

### 无重复字符的最长子串

题目链接：[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

!!! quote
给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。

输入: `s = "abcabcbb"`

输出: 3 

解释: 因为无重复字符的最长子串是`"abc"`，所以其长度为 3。

思路解析：

本题的暴力解法为两层`for`循环遍历+hash判断是否重复，时间复杂度为O($N^2$)，根据暴力解法可以进一步优化将时间复杂度降低到O(N)

以示例数组为例

正向性：定义一个`left`和一个`right`指针，二者指向第一个字符。在遍历的过程中，`right`指针向右移动，直到遇到一个已经出现的字符停止，此时`right`指针是否需要回退呢？**答案是不需要**，因为当`right`指针遇到已经出现过的字符后，`left`指针就会开始移动，如果`left++`，则下一个字符为`b`，此时在区间`(left=1)[left, right]`中不存在已经重复的字符，因为已经跳过了重复的字符`a`。所以，`left`指针和`right`指针在移动的过程中均满足从左向右移动不回退

在上面的示例中，重复字符为第一个字符，考虑示例：`s="deabcabcbb"`。在该示例中，`right`向右移动一直到第二个字符`a`，此时`[left, right]`中存在重复字符`a`，停止移动`right`，接下来移动`left`，那么`left`是否需要一次只移动1个长度呢？**不需要**，原因很简单，`left++`后下一个区间`(left=1)[left, right]`起始字符为`e`，而对应区间中的子串为`eabca`，仍然存在重复字符`a`，所以`left`在移动时并不是每一次都只移动1个长度（即只循环一次），只需要让`left`移动到当前区间第一个重复字符的下一个字符`b`的位置即可，所以需要使用循环来让`left`一直移动直到跳过重复字符

对于哈希表的处理，不需要使用库中的结构，因为题目中给出了结果`s`的取值只会出现英文字母、数字、符号和空格，所以只需要定义一个长度为128的数组即可，对应的下标即为对应字符的ASCII码值

根据上面的分析，因为`left`和`right`在遍历的过程中不需要回退，所以可以考虑使用滑动窗口算法解决，步骤如下：

1. 进窗口：本题进窗口意味着只要元素没有在哈希表数组中就进入哈希表数组
2. 判断：因为遇到重复的字符`right`就停止移动，所以当哈希表数组字符ASCII值下标对应的元素不为0即代表重复，作为判断条件
3. 出窗口：出窗口则意味着已经在哈希表中的元素需要离开哈希表，并让`left`向后移动，需要注意的是，**因为需要进入一个新的窗口，所以出窗口时需要使left位置的字符对应哈希数组下标值的元素出现的次数改变**
4. 更新结果：本题更新结果只需要在`[left, right]`区间没有重复字符后即可，用变量`len`存储子串长度，再移动`right`

具体步骤如下：

<img src="2. 滑动窗口算法.assets/image-20240709223540207-1720535744163-3.png" alt="image-20240709223540207" />

参考代码：

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int hash[128] = {0}; // 创建hash表
        int len = 0;
        for(int left = 0, right = 0; right < s.size(); right++)
        {
            hash[s[right]]++; // 标记已经出现
            // 判断
            while(hash[s[right]] > 1)
            {
                hash[s[left++]]--;// 出窗口
            }
            len = max(len, right - left + 1);// 更新结果
        }

        return len;
    }
};
```

### 最长连续1的个数Ⅲ

题目链接：[1004. 最大连续1的个数 III - 力扣（LeetCode）](https://leetcode.cn/problems/max-consecutive-ones-iii/)

!!! quote
    给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回 *数组中连续 `1` 的最大个数* 。

    **示例 1：**

    输入：`nums = [1,1,1,0,0,0,1,1,1,1,0]`,` K = 2`

    输出：6

    解释：[1,1,1,0,0,**1**,1,1,1,1,**1**] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。

思路解析：

题目说明**最多翻转k个0**，代表翻转0的个数可以有[0, k]个，所以有两种情况：

1. 翻转个数在区间[0, k]中
2. 翻转个数大于`k`个时只能翻转`k`个

所以，本题可以将原有问题转化为**数组中0的个数不超过`k`个时，数组中连续1的最大个数**

本题的暴力解法为：枚举子数组+记录0的个数，在暴力解法的基础上，对暴力解法进行优化，在枚举的过程中，定义两个指针`left`和`right`，均从起始位置开始向右移动，当`right`位置对应值为0时，计数器`zero`加1，代表0出现1次，便于后面与`k`进行比较判断，当`zero>k`时，说明此时`[left, right]`区间为满足要求的区间，接着移动`left`

以示例数组为例

正向性：当`zero>k`时，此时表示0的个数已经到达`k`个，接下来需要枚举下一个区间，那么`left`就需要向后移动，此时的`right`不需要向后移动，因为在区间`(left=0)[left, right]`中，0的个数已经到达`k`个，如果`right`再回到`left=1`的位置时，此时的区间`(left=1)[left, right]`中依旧包括刚才已经出现的`k`个0，导致计数器依旧会在同样的位置达到`zero>k`，所以只需要让`right`开始位置不需要回退，满足正向性

对于`left`指针的移动，为了确保区间`[left, right]`中不包括已经判断过的区间，可以让`left`移动到上一次满足条件的区间的最后一个元素的位置，`[left, right]`区间就避开了包含上一次满足条件的区间，而对于`zero`计数器来说，因为`left`回到了上一个合法区间的最后一个元素的位置，如果该位置的数值为0，则`zero`计数器需要减1，代表这个位置已经翻转过一次，还有`k-1`可以翻转，否则不处理

因为满足正向性，所以可以使用滑动窗口算法

1. 进窗口：因为是统计0的个数，所以当`right`位置的值为0时，`zero`计数器加1，否则不处理
2. 判断：当`zero>k`时，此时代表合法区间已经出现，因为k到达上限，所以不可以继续向后移动
3. 出窗口：`left`移动到上一个合法区间的最后一个元素的位置，如果为0，则计数器减1
4. 更新结果：用`len`存储最长的子数组

参考代码：

```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int len = 0;
        int zero = 0;
        for (int right = 0, left = 0; right < nums.size(); right++) {
            if (nums[right] == 0) {
                zero++;
            }
            while (zero > k) {
                if (nums[left++] == 0) {
                    zero--;
                }
            }
            len = max(len, right - left + 1);
        }

        return len;
    }
};
```

### 将x减到0的最小操作数

题目链接：[1658. 将 x 减到 0 的最小操作数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

!!! quote
    给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。

    如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

    

    **示例 1：**

    输入：`nums = [1,1,4,2,3]`, `x = 5`

    输出：2

    解释：最佳解决方案是移除后两个元素，将 x 减到 0 。

思路解析：

