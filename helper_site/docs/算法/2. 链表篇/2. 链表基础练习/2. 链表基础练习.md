# 链表基础练习

前面了解了链表的基础结构，下面通过基础的练习巩固前面学习到的基础知识。链表处的题目没有特别显著的统一解法，大部分都是对链表结构的增删改，所以通过题目具体分析链表的题目类型

## 力扣203.移除链表元素

[力扣203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

**问题描述：**

!!! quote
    给你一个链表的头节点`head`和一个整数`val`，请你删除链表中所有满足`Node.val == val`的节点，并返回 新的头节点 。

    示例 1：

    ```c++
    输入：head = [1,2,6,3,4,5,6], val = 6
    输出：[1,2,3,4,5]
    ```

    示例 2：

    ```c++
    输入：head = [], val = 1
    输出：[]
    ```

    示例 3：

    ```c++
    输入：head = [7,7,7,7], val = 7
    输出：[]
    ```

**思路分析：**

1. 解法1：原地处理
    从题目就可以看出，本题涉及链表结构的数据删除，需要注意，力扣中`head`不是头节点，而是第一个有效数据节点，所以此处需要考虑两种情况：

    1. 删除的是第一个有效数据节点
    2. 删除的是非第一个有效数据节点

    但是为了可以实现统一处理，这里引入一个虚拟头结点`dummy`，使其指向第一个有效数据节点，这个做法在后面涉及到与链表的数据删除或者更改时非常常见。这样做可以保证第一个有效数据节点的删除逻辑和非第一个有效数据节点一致。剩余的逻辑就是链表的元素删除了，力扣中的链表大部分默认都是单链表，具体可以参考[单链表数据结构头删部分](https://www.helper-wiki.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%20%E9%93%BE%E8%A1%A8/3.%20%E9%93%BE%E8%A1%A8.html#_12)和[单链表数据结构尾删部分](https://www.helper-wiki.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%20%E9%93%BE%E8%A1%A8/3.%20%E9%93%BE%E8%A1%A8.html#_13)

2. 解法2：异地处理

    异地处理就不是删除的逻辑，而是尾插的逻辑，具体可见[单链表数据结构尾插](https://www.helper-wiki.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%20%E9%93%BE%E8%A1%A8/3.%20%E9%93%BE%E8%A1%A8.html#_11)，为了方便插入，这里同样需要引入一个虚拟头结点`dummy`

**参考代码：**

=== "原地处理（不使用虚拟头节点）"

    ```c++
    class Solution203_1_1
    {
    public:
        ListNode *removeElements(ListNode *head, int val)
        {
            if (head == nullptr)
            {
                return head;
            }

            // 引入新节点指向头节点
            ListNode *dummy = new ListNode;
            dummy->next = head;


            // 定义前驱节点
            ListNode *prev = dummy;
            // 定义起始节点
            ListNode *cur = dummy->next;

            while (cur)
            {
                if (cur->val == val)
                {
                    // 删除节点
                    ListNode *toDelete = cur;
                    prev->next = cur->next;
                    delete toDelete;
                }
                else
                {
                    prev = cur;
                }
                cur = prev->next;
            }


            return dummy->next;
        }
    };
    ```

=== "原地处理（使用头节点）"

    ```c++
    class Solution203_1_2
    {
    public:
        ListNode *removeElements(ListNode *head, int val)
        {
            // 删除头结点
            while (head != NULL && head->val == val)
            {
                // 注意这里不是if
                ListNode *tmp = head;
                head = head->next;
                delete tmp;
            }

            // 删除非头结点
            ListNode *cur = head;
            while (cur != NULL && cur->next != NULL)
            {
                if (cur->next->val == val)
                {
                    ListNode *tmp = cur->next;
                    cur->next = cur->next->next;
                    delete tmp;
                }
                else
                {
                    cur = cur->next;
                }
            }
            return head;
        }
    };
    ```

=== "异地处理"

    ```c++
    class Solution203_2
    {
    public:
        ListNode *removeElements(ListNode *head, int val)
        {
            ListNode *copyHead = new ListNode;
            ListNode *curA = head;
            ListNode *curB = copyHead;
            while (curA)
            {
                if (curA->val != val)
                {
                    ListNode *newNode = new ListNode(curA->val);
                    curB->next = newNode;
                    curB = curB->next;
                }
                curA = curA->next;
            }

            return copyHead->next;
        }
    };
    ```

## 力扣707.设计链表

[力扣707.设计链表](https://leetcode.cn/problems/design-linked-list/description/)

**问题描述：**

!!! quote
    
    你可以选择使用单链表或者双链表，设计并实现自己的链表。

    单链表中的节点应该具备两个属性：`val`和`next`。`val`是当前节点的值，`next`是指向下一个节点的指针/引用。

    如果是双向链表，则还需要属性`prev`以指示链表中的上一个节点。假设链表中的所有节点下标从0开始。

    实现`MyLinkedList`类：

    `MyLinkedList()`初始化`MyLinkedList`对象。
    `int get(int index)`获取链表中下标为`index`的节点的值。如果下标无效，则返回-1。
    `void addAtHead(int val)`将一个值为`val`的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
    `void addAtTail(int val)`将一个值为`val`的节点追加到链表中作为链表的最后一个元素。
    `void addAtIndex(int index, int val)`将一个值为 val 的节点插入到链表中下标为index的节点之前。如果index等于链表的长度，那么该节点会被追加到链表的末尾。如果index比长度更大，该节点将 不会插入 到链表中。
    `void deleteAtIndex(int index)`如果下标有效，则删除链表中下标为`index`的节点。
    

    示例：

    **输入**

    ```c++
    ["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
    [[], [1], [3], [1, 2], [1], [1], [1]]
    ```

    **输出**

    ```c++
    [null, null, null, null, 2, null, 3]
    ```

    **解释**

    ```c++
    MyLinkedList myLinkedList = new MyLinkedList();
    myLinkedList.addAtHead(1);
    myLinkedList.addAtTail(3);
    myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
    myLinkedList.get(1);              // 返回 2
    myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
    myLinkedList.get(1);              // 返回 3
    ```

**思路分析：**

本题就是根据对链表结构的理解设计一个自己的链表结构，既可以是单链表也可以双链表，但是需要注意，本题get()、addAtIndex()和deleteAtIndex()三个函数需要用到下标，但是链表本身没有下标，所以需要考虑用循环依次枚举下标直到其值等于所给下标为止，其余思路与链表数据结构相关操作基本一致

需要注意，力扣本身有一个单链表节点结构ListNode结构，结构如下：

```c++
// 单向链表节点
struct ListNode
{
    // 数据域
    int val;
    ListNode *next;

    // 构造函数
    ListNode(int _val = 0, ListNode *_next = nullptr)
        : val(_val)
        , next(_next)
    {}
};
```

但是对于双向链表节点结构则需要自行设计，根据题目要求设计出数据域和指针域即可

**参考代码：**

=== "单链表"

    ```c++
    class MyLinkedList
    {
    public:
        MyLinkedList()
            : _size(0)
        {
            // 使用头结点
            _head = new ListNode;
        }

        int get(int index)
        {
            // 无效下标返回-1
            if (index < 0 || index >= _size)
            {
                return -1;
            }

            // 当前位置
            ListNode *cur = _head->next;
            while (cur && index >= 0)
            {
                if (index == 0)
                {
                    return cur->val;
                }
                cur = cur->next;
                index--;
            }

            return -1;
        }

        void addAtHead(int val)
        {
            // 插入到头结点后
            ListNode *newNode = new ListNode(val);

            if (_head->next == nullptr)
            {
                _head->next = newNode;
            }
            else
            {
                ListNode *cur = _head->next;
                newNode->next = cur;
                _head->next = newNode;
            }

            ++_size;
        }

        void addAtTail(int val)
        {
            ListNode *newNode = new ListNode(val);

            ListNode *cur = _head;
            if (cur->next == nullptr)
            {
                cur->next = newNode;
                ++_size;
                return;
            }

            // 找到尾节点
            while (cur->next)
            {
                cur = cur->next;
            }

            cur->next = newNode;
            ++_size;
        }

        void addAtIndex(int index, int val)
        {
            // 非法下标阻止插入
            if (index < 0 || index > _size)
            {
                return;
            }

            // 刚好等于链表长度时相当于尾插
            if (index == _size)
            {
                addAtTail(val);
                // 注意此处不要再处理_size
                return;
            }

            // 等于0代表头插
            if (index == 0)
            {
                addAtHead(val);
                // 注意此处不要再处理_size
                return;
            }

            // 否则加入到指定节点之前
            // 获取指定元素
            int target = get(index);
            // 没有指定元素，不允许插入
            if (target == -1)
            {
                return;
            }

            ListNode *cur = _head->next;
            ListNode *prev = _head;
            while (cur)
            {
                if (cur->val == target && index == 0)
                {
                    break;
                }
                prev = cur;
                cur = cur->next;
                --index;
            }

            ListNode *newNode = new ListNode(val);

            newNode->next = cur;
            prev->next = newNode;

            ++_size;
        }

        void deleteAtIndex(int index)
        {
            // 非法下标阻止插入
            if (index < 0 || index >= _size)
            {
                return;
            }

            // 获取index对应的元素
            int target = get(index);

            // 找到指定元素删除
            ListNode *prev = _head;
            ListNode *cur = _head->next;

            while (cur)
            {
                if (cur->val == target && index == 0)
                {
                    ListNode *toDelete = cur;
                    prev->next = cur->next;
                    delete toDelete;
                    --_size;
                    break;
                }

                prev = cur;
                cur = cur->next;
                --index;
            }
        }

    private:
        // 创建头结点
        ListNode *_head;
        // 链表有效数据个数
        int _size;
    };
    ```

=== "双向链表"

    ```c++
    struct DoubleListNode
    {
        // 数据域
        int val;
        // 指针域
        DoubleListNode *next;
        DoubleListNode *prev;

        DoubleListNode(int _val = 0)
            : val(_val)
            , next(nullptr)
            , prev(nullptr)
        {}
    };

    class MyLinkedList
    {
    public:
        MyLinkedList()
            : _size(0)
        {
            _head = new DoubleListNode;
            _head->next = _head;
            _head->prev = _head;
        }

        int get(int index)
        {
            if (index < 0 || index >= _size)
                return -1;

            DoubleListNode *cur = _head->next;

            for (int i = 1; i <= index; i++)
            {
                cur = cur->next;
            }

            if (cur == _head)
            {
                return -1;
            }

            return cur->val;
        }

        void addAtHead(int val)
        {
            // 创建新节点
            DoubleListNode *newNode = new DoubleListNode(val);
            // 将节点插入到头结点的后方
            if (_head->next == _head)
            {
                // 处理头结点
                _head->next = newNode;
                _head->prev = newNode;

                // 处理新节点
                newNode->prev = _head;
                newNode->next = _head;
            }
            else
            {
                DoubleListNode *cur = _head->next;
                // 处理新节点连接
                newNode->next = cur;
                newNode->prev = _head;
                // 处理旧节点的连接
                cur->prev = newNode;
                _head->next = newNode;
            }

            ++_size;
        }

        void addAtTail(int val)
        {
            // 创建新节点
            DoubleListNode *newNode = new DoubleListNode(val);
            // 找到尾节点
            if (_head->prev == _head)
            {
                // 处理头结点
                _head->prev = newNode;
                _head->next = newNode;

                // 处理新结点
                newNode->prev = _head;
                newNode->next = _head;
            }
            else
            {
                DoubleListNode *cur = _head->prev;
                // 处理新节点
                newNode->prev = cur;
                newNode->next = _head;
                // 处理旧节点
                cur->next = newNode;
                _head->prev = newNode;
            }

            ++_size;
        }

        void addAtIndex(int index, int val)
        {
            // 非法下标阻止插入
            if (index < 0 || index > _size)
            {
                return;
            }

            // 刚好等于链表长度时相当于尾插
            if (index == _size)
            {
                addAtTail(val);
                // 注意此处不要再处理_size
                return;
            }

            // 等于0代表头插
            if (index == 0)
            {
                addAtHead(val);
                // 注意此处不要再处理_size
                return;
            }

            // 创建新节点
            DoubleListNode *newNode = new DoubleListNode(val);

            DoubleListNode *cur = _head->next;

            for (int i = 0; i < index; i++)
            {
                cur = cur->next;
            }

            DoubleListNode *curPrev = cur->prev;
            // 处理新节点
            newNode->next = cur;
            newNode->prev = curPrev;

            // 处理旧节点
            cur->prev = newNode;
            curPrev->next = newNode;

            ++_size;
        }

        void deleteAtIndex(int index)
        {
            // 非法下标阻止删除
            if (index < 0 || index >= _size)
            {
                return;
            }

            DoubleListNode *cur = _head->next;
            for (int i = 0; i < index; i++)
            {
                cur = cur->next;
            }

            // 删除当前cur
            DoubleListNode *toDelete = cur;
            DoubleListNode *curPrev = cur->prev;
            DoubleListNode *curNext = cur->next;

            curPrev->next = curNext;
            curNext->prev = curPrev;

            --_size;
        }

    private:
        // 头结点
        DoubleListNode *_head;
        // 链表大小
        int _size;
    };
    ```

## 力扣206.反转链表

[力扣206.反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)

**问题描述：**

!!! quote
    给你单链表的头节点`head`，请你反转链表，并返回反转后的链表。
    

    示例 1：

    ```c++
    输入：head = [1,2,3,4,5]
    输出：[5,4,3,2,1]
    ```

    示例 2：

    ```c++
    输入：head = [1,2]
    输出：[2,1]
    ```

    示例 3：

    ```c++
    输入：head = []
    输出：[]
    ```

**思路分析：**

1. 解法1：异地处理

    对于异地处理来说，反转链表本质就是第一个元素作为最后一个元素，第二个元素作为倒数第二个元素，第三个元素作为倒数第三个元素……，所以可以考虑使用头插的方式解决本题。遍历原链表，此处可以考虑为对每一个节点进行深拷贝，将对应的值通过新节点头插到新链表，保证每个节点的链接不会出现问题

2. 解法2：原地处理

    对于原地处理来说，必须处理好每一个节点的链接和断开。原地处理的具体操作是：因为是单链表，所以处理记录当前节点`cur`，还需要记录前一个节点`prev`，使用一个临时变量`temp`记录当前节点的下一个节点地址，防止接着断开链接时找不到下一个节点，再将当前节点的指针指向前一个节点，此时就完成一次一个节点的指针反向，让`prev`走到`cur`的位置，接着再让`cur`走到`temp`的位置重复上面的步骤即可

    需要注意的是，`prev`指针的起始位置不同，处理方式也不相同

**写法进阶：**

上面的两个方式最常见的写法就是迭代，但是对于第二个方法来说，还可以使用递归来解决，建议先用迭代实现，再根据迭代写出递归的代码

**参考代码：**

=== "异地处理"

    ```c++
    class Solution206_1
    {
    public:
        ListNode *reverseList(ListNode *head)
        {
            ListNode *copyHead = new ListNode;

            ListNode *curA = head;

            // 头插思路
            while (curA)
            {
                // 创建新节点
                ListNode *newNode = new ListNode(curA->val);
                if (copyHead->next == nullptr)
                {
                    copyHead->next = newNode;
                }
                else
                {
                    ListNode *cur = copyHead->next;
                    newNode->next = cur;
                    copyHead->next = newNode;
                }
                curA = curA->next;
            }

            return copyHead->next;
        }
    };
    ```

=== "原地处理（写法1：`prev`起始指向第一个有效数据节点）"

    ```c++
    class Solution206_2_1
    {
    public:
        ListNode *reverseList(ListNode *head)
        {
            if (head == nullptr)
                return nullptr;
            ListNode *prev = head;
            ListNode *cur = head;

            while (cur)
            {
                if (cur == head)
                {
                    cur = cur->next;
                    prev->next = nullptr;
                }
                else
                {
                    ListNode *temp = cur->next;
                    cur->next = prev;
                    prev = cur;
                    cur = temp;
                }
            }

            head = prev;

            return head;
        }
    };
    ```

=== "原地处理（写法2：`prev`起始指向`nullptr`）"

    ```c++
    class Solution206_2_2
    {
    public:
        ListNode *reverseList(ListNode *head)
        {
            if (head == nullptr)
                return nullptr;
            // 直接将prev初始化为nullptr
            // 使cur每一次更改next时指向prev即可
            ListNode *prev = nullptr;
            ListNode *cur = head;

            while (cur)
            {
                ListNode *temp = cur->next;
                cur->next = prev;
                prev = cur;
                cur = temp;
            }

            head = prev;

            return head;
        }
    };
    ```

=== "递归写法"

    ```c++
    class Solution206_3
    {
    public:
        ListNode *_reverseList(ListNode *cur, ListNode *prev)
        {
            // 递归终止条件——循环终止条件
            if (cur == nullptr)
                // 循环结束后的步骤
                return prev;

            // 反转——循环中的过程
            ListNode *temp = cur->next;
            cur->next = prev;
            // 再次的赋值操作相当于为下一次的循环做准备
            // 在递归中相当于再次调用翻转函数
            return _reverseList(temp, cur);
        }

        ListNode *reverseList(ListNode *head)
        {
            // 相当于双指针中创建cur和prev并初始化
            return _reverseList(head, nullptr);
        }
    };
    ```

## 力扣876.链表的中间结点

**问题分析：**

!!! quote
    给你单链表的头结点`head`，请你找出并返回链表的中间结点。

    如果有两个中间结点，则返回第二个中间结点。

    示例 1：

    ```c++
    输入：head = [1,2,3,4,5]
    输出：[3,4,5]
    解释：链表只有一个中间结点，值为 3 。
    ```

    示例 2：

    ```c++
    输入：head = [1,2,3,4,5,6]
    输出：[4,5,6]
    解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。
    ```

**思路分析：**

本题考虑使用快慢指针法，快指针一次走两步，慢指针一次走一步，最后返回慢指针即可，注意循环条件是`fast && fast->next`，而不是`fast->next && fast`，因为对于偶数个节点的链表来说，在走到了`fast`需要走到空才停止，而奇数个节点的链表走到`next`节点为空停止即可，如果是第二种，那么当链表为偶数个节点的链表，当`slow`走到第二个中间节点时，`fast`已经在空的位置，此时对于循环条件`fast->next && fast`来说，会先判断`fast->next`，由于此时`fast == NULL`，故此时会出现空指针解引用错误

**参考代码：**

=== "C语言"

    ```c
    typedef struct ListNode SLN;
    struct ListNode* middleNode(struct ListNode* head) {
        //快慢指针法
        SLN* fast = head, *slow = head;
        while(fast && fast->next)
        {
            //慢指针走一步，快指针走两步
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ```

=== "C++"

    ```c++
    class Solution 
    {
    public:
        ListNode* middleNode(ListNode* head) {
            ListNode* fast = head;
            ListNode* slow = head;

            while(fast && fast->next)
            {
                fast = fast->next->next;
                slow = slow->next;
            }

            return slow;
        }
    };
    ```

## 力扣19.删除链表的倒数第N个结点

**问题描述：**

!!! quote
    给你一个链表，删除链表的倒数第`n`个结点，并且返回链表的头结点。

    示例 1：

    ```c++
    输入：head = [1,2,3,4,5], n = 2
    输出：[1,2,3,5]
    ```

    示例 2：

    ```c++
    输入：head = [1], n = 1
    输出：[]
    ```

    示例 3：

    ```c++
    输入：head = [1,2], n = 1
    输出：[1]
    ```

**思路分析：**

1. 计算链表长度反向找到倒数第`n`个节点

    假设链表长度为`size`，倒数第`n`个节点代表前面有`size-n`个节点，假设现在第一个节点的下标为0，则`size-n`刚好就是倒数第`n`个节点的下标，利用这个结合前面设计链表题目中的下标思路即可解决本题

2. 快慢指针

    定义`fast`指针和`slow`指针分别表示快指针和慢指针，倒数第`n`个节点，说明该节点距离最后一个节点相差`n-1`节点，所以先让`fast`指针走n步，保证在`slow`和`fast`同时走时，`fast`到链表结尾，`slow`和`fast`相差`n-1`个节点。为了便于删除，依旧是引入虚拟头节点指向链表的第一个节点，并且因为在单链表中删除节点时，获取到待删除节点的前一个节点会更加方便，所以让`slow`和`fast`在一开始就相差1

**参考代码：**

=== "计算链表长度反向找到倒数第n个节点"

    ```c++
    class Solution19_1
    {
    public:
        ListNode *removeNthFromEnd(ListNode *head, int n)
        {
            // 获取链表的长度
            int sz = 0;
            ListNode *cur = head;
            while (cur)
            {
                cur = cur->next;
                sz++;
            }

            // 获取下标
            int index = sz - n;

            // 根据下标删除对应的节点
            ListNode *dummy = new ListNode;

            dummy->next = head;
            ListNode *prev = dummy;
            cur = dummy->next;

            for (int i = 0; i < index; i++)
            {
                prev = cur;
                cur = cur->next;
            }

            // 删除节点
            if (index == 0)
            {
                // 如果index为0，说明删除的是第一个节点
                dummy->next = head->next;
                delete head;
            }
            else
            {
                prev->next = cur->next;
                delete cur;
            }

            return dummy->next;
        }
    };
    ```

=== "快慢指针"

    ```c++
    class Solution19_2
    {
    public:
        ListNode *removeNthFromEnd(ListNode *head, int n)
        {
            ListNode *dummy = new ListNode;
            dummy->next = head;

            ListNode *fast = dummy->next;
            ListNode *slow = dummy;
            // 先让fast走n步
            while (n)
            {
                fast = fast->next;
                --n;
            }

            // slow和fast同时走
            while (fast)
            {
                slow = slow->next;
                fast = fast->next;
            }

            // slow指向待删除节点的前一个节点
            ListNode *toDelete = slow->next;
            slow->next = slow->next->next;
            delete toDelete;

            return dummy->next;
        }
    };
    ```