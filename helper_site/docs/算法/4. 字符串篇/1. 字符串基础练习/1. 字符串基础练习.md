# 字符串基础练习

## 本篇介绍

因为字符串在C++中是字符数组，所以基本操作与数组是大致相似的，其相关操作的时间复杂度也是基本一致的，所以本篇主要介绍字符串相关的题目和部分字符串的算法，并不会涉及到字符串的统一解法

## 力扣344.反转字符串

[力扣344.反转字符串](https://leetcode.cn/problems/reverse-string/description/)

**问题描述：**

!!! quote

    编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组`s`的形式给出。

    不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用O(1)的额外空间解决这一问题。

    示例 1：

    ```c++
    输入：s = ["h","e","l","l","o"]
    输出：["o","l","l","e","h"]
    ```

    示例 2：

    ```c++
    输入：s = ["H","a","n","n","a","h"]
    输出：["h","a","n","n","a","H"]
    ```

**思路分析：**

反转字符串的本质就是依次交换对应位置的字符，例如"H"和"h"交换、"a"和"a"交换，以此类推。根据思路就可以利用到双指针`left`和`right`分别指向首尾，二者向中间遍历，如果同时指向一个字符，则可以考虑不进行交换，所以交换结束条件就是`left<right`

**参考代码：**

=== "库函数"

    ```c++
    class Solution344_1
    {
    public:
        void reverseString(vector<char> &s)
        {
            reverse(s.begin(), s.end());
        }
    };
    ```

=== "双指针"

    ```c++
    class Solution344_2
    {
    public:
        void reverseString(vector<char> &s)
        {
            for (int start = 0, end = s.size() - 1; start < end; start++, end--)
            {
                swap(s[start], s[end]);
            }
        }
    };
    ```

## 力扣541.反转字符串II

[力扣541.反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)

**问题描述：**

!!! quote
    给定一个字符串`s`和一个整数`k`，从字符串开头算起，每计数至`2k`个字符，就反转这`2k`字符中的前`k`个字符。

    - 如果剩余字符少于`k`个，则将剩余字符全部反转。
    - 如果剩余字符小于`2k`但大于或等于`k`个，则反转前`k`个字符，其余字符保持原样。

    示例 1：

    ```c++
    输入：s = "abcdefg", k = 2
    输出："bacdfeg"
    ```

    示例 2：

    ```c++
    输入：s = "abcd", k = 2
    输出："bacd"
    ```

**思路分析：**

本题首先需要理解题目的要求，题目看似给出了三个要求，实际上就只有两个要求：

1. 字符数量小于`k`，则反转所有字符
2. 字符数量大于等于`k`但小于`2k`，则反转前`k`个

根据这两个要求就可以模拟出本题需要的结果

**关键步骤：**

在遍历字符串时，其实每一次只需要考虑`2k`部分即可，当`2k`部分全部处理完成后，下标可以直接跳到`2k+1`的位置，而没必要一个字符一个字符向后移动

**参考代码：**

```c++
class Solution541
{
public:
    void reverseString(string &s, int start, int end)
    {
        while (start < end)
        {
            swap(s[start], s[end]);
            start++;
            end--;
        }
    }

    string reverseStr(string s, int k)
    {
        // 注意当i进行一次跳转时，i的位置是下一区间的起始位置
        for (int i = 0; i < s.size(); i += 2 * k)
        {
            if (i + k < s.size())
            {
                reverseString(s, i, i + k - 1);
                continue;
            }
            reverseString(s, i, s.size() - 1);
        }

        return s;
    }
};
```

## 卡码网KamaCoder.替换数字

[卡码网KamaCoder.替换数字](https://kamacoder.com/problempage.php?pid=1064)

**问题描述：**

!!! quote

    **题目描述**

    给定一个字符串`s`，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为`number`。例如，对于输入字符串`a1b2c3`，函数应该将其转换为`anumberbnumbercnumber`。

    **输入描述**

    输入一个字符串`s`，`s`仅包含小写字母和数字字符。

    **输出描述**

    打印一个新的字符串，其中每个数字字符都被替换为了`number`

    **输入示例**

    ```c++
    a1b2c3
    ```

    **输出示例**

    ```c++
    anumberbnumbercnumber
    ```

    **提示信息**

    数据范围：

    ```c++
    1 <= s.length < 10000
    ```

**思路分析：**

1. 解法1：异地处理

    异地处理的方式很简单，遍历到数字字符就插入一个`number`，否则插入原字符，最后返回新字符数组

2. 解法2：原地处理

    原地处理的方式就是预先开辟比原字符串大的空间，具体开多大可以根据题目要求计算，因为题目需要遇到一个数字字符就进行替换，并且替换为`number`，所以需要额外开辟`数字字符数量*number字符个数-1`的空间。在遍历原字符串的过程中，如果遇到了数字字符，就需要移动其后面所有的字符为插入`number`腾出位子

**参考代码：**

=== "异地处理"

    ```c++
    #include <iostream>
    #include <string>
    using namespace std;

    int main()
    {
        string s;
        cin >> s;
        string ret;
        for(auto ch : s)
        {
            if(ch >='0' && ch <= '9')
                ret += "number";
            else
                ret += ch;
        }

        cout << ret << endl;

        return 0;
    }
    ```

=== "原地处理"

    ```c++
    #include <iostream>
    using namespace std;
    int main() 
    {
        string s;
        while (cin >> s) 
        {
            int sOldIndex = s.size() - 1;
            int count = 0; // 统计数字的个数
            for (int i = 0; i < s.size(); i++) 
            {
                if (s[i] >= '0' && s[i] <= '9') 
                {
                    count++;
                }
            }
            // 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小
            s.resize(s.size() + count * 5);
            int sNewIndex = s.size() - 1;
            // 从后往前将数字替换为"number"
            while (sOldIndex >= 0) 
            {
                if (s[sOldIndex] >= '0' && s[sOldIndex] <= '9') 
                {
                    s[sNewIndex--] = 'r';
                    s[sNewIndex--] = 'e';
                    s[sNewIndex--] = 'b';
                    s[sNewIndex--] = 'm';
                    s[sNewIndex--] = 'u';
                    s[sNewIndex--] = 'n';
                } 
                else 
                {
                    s[sNewIndex--] = s[sOldIndex];
                }
                sOldIndex--;
            }
            cout << s << endl;       
        }
    }
    ```

## 力扣151. 反转字符串中的单词

[力扣151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

**问题描述：**

给你一个字符串`s`，请你反转字符串中单词的顺序。

单词是由非空格字符组成的字符串。`s`中使用至少一个空格将字符串中的单词分隔开。

返回单词顺序颠倒且单词之间用单个空格连接的结果字符串。

注意：输入字符串`s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

示例 1：

```c++
输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：

输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。