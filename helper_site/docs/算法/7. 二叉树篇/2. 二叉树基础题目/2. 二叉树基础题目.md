# 二叉树基础题目

## 本篇介绍

二叉树的题目大部分考察的都是如何正确使用二叉树的遍历，二叉树的遍历主要分为深度优先搜索和广度优先搜索，深度优先一般就是前中后序三个遍历方式，深度优先就是层序遍历，在下面的题目中，也主要考察这两种遍历方式

## 二叉树的深度优先搜索

### 力扣144.二叉树的前序遍历

[力扣144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，返回它节点值的前序遍历。

    示例 1：

    ```c++
    输入：root = [1,null,2,3]
    输出：[1,2,3]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\screenshot-2024-08-29-202743.png">

    示例 2：

    ```c++
    输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]
    输出：[1,2,4,5,6,7,3,8,9]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\tree_2.png">

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

    示例 4：

    ```c++
    输入：root = [1]
    输出：[1]
    ```

**思路分析：**

1. 解法1：递归
   
    二叉树的前序遍历在[数据结构：二叉树（基础）](https://www.help-doc.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html#_12)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树前序遍历的迭代写法的主要思路就是用栈模拟递归的过程，因为前序遍历的顺序是：中左右，所以根节点是第一个被处理的节点，此时栈内的数据就是当前子树的根节点。如果栈不为空说明还没有走完整棵二叉树，否则每一次遍历时，先取出当前栈顶的元素，该元素就是当前子树的根节点，取出后弹出当前元素，接着走向右子树，注意不是左子树，因为栈是先进后出，而下一次是左子树先被去除，所以右子树先进才能保证左子树在栈顶

**参考代码：**

=== "递归"

    ```c++
    class Solution144_1
    {
    public:
        void _preorderTraversal(TreeNode *root, vector<int> &ret)
        {
            if (root == nullptr)
                return;

            // 处理节点
            ret.push_back(root->val);
            _preorderTraversal(root->left, ret);
            _preorderTraversal(root->right, ret);
        }

        vector<int> preorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _preorderTraversal(root, ret);
            return ret;
        }
    };
    ```

=== "迭代"

    ```c++
    class Solution144_2
    {
    public:
        vector<int> preorderTraversal(TreeNode *root)
        {
            // 用栈模拟
            stack<TreeNode *> st;
            // 先插入根节点
            st.push(root);
            vector<int> ret;

            while (!st.empty())
            {
                // 获取栈顶节点
                TreeNode *cur = st.top();
                st.pop();
                // 处理逻辑
                if (cur != nullptr)
                    ret.push_back(cur->val);
                else
                    continue;

                // 先插入右节点
                st.push(cur->right);
                // 再插入左节点
                st.push(cur->left);
            }

            return ret;
        }
    };
    ```

### 力扣94.二叉树的中序遍历

[力扣94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

**问题描述：**

!!! quote

    给定一个二叉树的根节点`root`，返回它的中序遍历。

    示例 1：

    <img src="2. 二叉树基础题目.assets\inorder_1.jpg">
    
    ```c++
    输入：root = [1,null,2,3]
    输出：[1,3,2]
    ```
    
    示例 2：

    ```c++
    输入：root = []
    输出：[]
    ```

    示例 3：

    ```c++
    输入：root = [1]
    输出：[1]
    ```

**思路分析：**

1. 解法1：递归

    二叉树的中序遍历在[数据结构：二叉树（基础）](https://www.help-doc.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html#_12)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树中序遍历的迭代写法相对比较简单，先找到左子树，再取出当前节点，当取出左节点后，下一个节点一定是根节点，所以只需要将`root`更新为`nullptr`就可以防止重复走到原来的节点。考虑到如果左节点是叶子，那么此时`root->right`一定为`nullptr`，所以可以更新为`root = root->right`，如果存在右节点，则下一次又会走右侧子树重复前面的步骤。如果不存在右节点，则下一次取出的就是根节点

**参考代码：**

=== "递归"

    ```c++
    class Solution94_1
    {
    public:
        void _inorderTraversal(TreeNode *cur, vector<int> &ret)
        {
            if (cur == nullptr)
                return;

            _inorderTraversal(cur->left, ret);
            ret.push_back(cur->val);
            _inorderTraversal(cur->right, ret);
        }

        vector<int> inorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _inorderTraversal(root, ret);

            return ret;
        }
    };
    ```

=== "迭代"

    ```c++
    class Solution94_2
    {
    public:
        vector<int> inorderTraversal(TreeNode *root)
        {
            stack<TreeNode *> st;
            vector<int> ret;

            TreeNode *prev = nullptr;

            while (!st.empty() || root != nullptr)
            {
                // 先找到最左节点
                while (root)
                {
                    st.push(root);
                    root = root->left;
                }

                // 获取当前节点
                root = st.top();
                st.pop();
                ret.push_back(root->val);

                // 不论是否为空都要走右子树，一旦右为空，下一次就会取到当前子树的根节点
                root = root->right;
            }

            return ret;
        }
    };
    ```

### 力扣145.二叉树的后序遍历

[力扣145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

**问题描述：**

!!! quote

    给你一棵二叉树的根节点`root`，返回其节点值的后序遍历。

    示例 1：

    ```c++
    输入：root = [1,null,2,3]

    输出：[3,2,1]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\screenshot-2024-08-29-202743.png">

    示例 2：

    ```c++
    输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]

    输出：[4,6,7,5,2,9,8,3,1]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\tree_2.png">

    示例 3：

    ```c++
    输入：root = []

    输出：[]
    ```

    示例 4：

    ```c++
    输入：root = [1]

    输出：[1]
    ```
    
**思路分析：**

1. 解法1：递归

    二叉树的后序遍历在[数据结构：二叉树（基础）](https://www.help-doc.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html#_12)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树后序遍历的迭代写法有两种，一种是变向的前序遍历，另外一种就是常规意义上的后序遍历

    对于变向的前序遍历，其实就是根据后序遍历的顺序「中右左」的前序遍历的反向「左右中」，所以只需要将前序遍历的「中左右」改为「中右左」，再反向结果集即可。但是注意，这个方法只是完成了遍历的结果，遍历的方法基本上是不太严谨的，或者说是异构的前序遍历（即利用了两次反转：先反转为中右左，再反转结果集）

    常规意义上的后序遍历就是按照「左右中」的顺序进行，基本思路和中序遍历很类似，先一直走左子树，直到找到最左节点，这个过程中也要记录遍历过的节点。接着获取到当前节点，与中序不同的是，此时需要判断是否存在右孩子，因为后序遍历处理中间节点的逻辑是在遍历完右子树之后，如果右子树存在，那么还需要继续遍历，即将右子树节点压栈，否则当前节点就是当前子树的最后一个节点

**关键步骤：**

后序遍历的常规迭代法需要注意，要使用到一个变量`prev`表示前一个节点，如果当前节点的右孩子等于`prev`，说明当前子树的右子树遍历完毕，当前及诶点就是当前子树的根节点，并且还需要在插入节点到结果集之后将`root`置为空，防止多次走向同一棵左子树

例如下面的例子中，`prev`当前指向的是7节点：

<img src="2. 二叉树基础题目.assets\Snipaste_2024-12-30_16-29-54.png">

下一次循环中，首先会从栈内取出元素，当前栈顶元素为5，所以当前节点就是5，如果没有判断5的右子树是否等于`prev`，那么就会出现再一次走到右子树将5再次插入到栈内并再次走向同一棵右子树的情况

**参考代码：**

=== "递归"

    ```c++
    class Solution145_1
    {
    public:
        void _postOrderTraversal(TreeNode *cur, vector<int> &ret)
        {
            if (cur == nullptr)
                return;

            // 访问左节点
            _postOrderTraversal(cur->left, ret);
            // 访问右节点
            _postOrderTraversal(cur->right, ret);
            // 处理当前节点
            ret.push_back(cur->val);
        }

        vector<int> postorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _postOrderTraversal(root, ret);

            return ret;
        }
    };
    ```

=== "迭代（常规）"

    ```c++
    class Solution145_2_1
    {
    public:
        vector<int> postorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            // 使用栈模拟
            stack<TreeNode *> st;
            // 根节点为空直接返回空
            if (root == nullptr)
                return ret;

            // 防止满二叉子树死循环
            TreeNode *prev = nullptr;
            while (!st.empty() || root != nullptr)
            {
                // 一直找到最左节点
                while (root)
                {
                    // 在循环中已经插入一次根节点
                    // 此时循环上的判断root!=nullptr可以防止两个相同的根节点同时插入栈中
                    st.push(root);
                    root = root->left;
                }

                // 获取到当前节点
                root = st.top();
                st.pop();

                // 如果当前节点不存在右子树
                // 或者已经获取过同一个右子树
                // 说明已经遍历完成，当前节点就是子树根节点
                if (root->right == nullptr || root->right == prev)
                {
                    ret.push_back(root->val);
                    prev = root;
                    // 将root置为空防止再一次获取最左节点
                    root = nullptr;
                }
                else
                {
                    // 存在右子树就还需要继续找
                    st.push(root); // 将弹出的根节点再插入到栈中
                    // 此时肯定不存在或者已经判断完左子树，所以直接走向右子树
                    root = root->right;
                }
            }

            return ret;
        }
    };
    ```

=== "迭代（非常规）"

    ```c++
    class Solution145_2_2
    {
    public:
        vector<int> postorderTraversal(TreeNode *root)
        {
            // 用栈模拟
            stack<TreeNode *> st;
            // 先插入根节点
            st.push(root);
            vector<int> ret;

            while (!st.empty())
            {
                // 获取栈顶节点
                TreeNode *cur = st.top();
                st.pop();
                // 处理逻辑
                if (cur != nullptr)
                    ret.push_back(cur->val);
                else
                    continue;

                // 中右左
                // 先插入左节点
                st.push(cur->left);
                // 再插入右节点
                st.push(cur->right);
            }

            reverse(ret.begin(), ret.end());

            return ret;
        }
    };
    ```

## 二叉树的广度优先搜索

### 力扣102.二叉树的层序遍历

[力扣102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。

    示例 1：

    <img src="2. 二叉树基础题目.assets\tree1.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：[[3],[9,20],[15,7]]
    ```

    示例 2：

    ```c++
    输入：root = [1]
    输出：[[1]]
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

二叉树的层序遍历就是利用队列，基本思路已经在[数据结构：二叉树（基础）](https://www.help-doc.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/7.%20%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89.html#_13)中提及，此处不再赘述，但是本题除了实现层序遍历二叉树外，还需要确定每一个节点所在的层，此时就需要使用到计数器，计数器由队列的大小进行初始化，起始是计数器为1，代表第一层只有一个节点，以此类推

**参考代码：**

```c++
class Solution102
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        // 记录当前层节点的个数
        int count = 0;
        vector<vector<int>> ret;

        queue<TreeNode *> que;

        que.push(root);
        while (!que.empty() && root != nullptr)
        {
            // 确定当前层节点的个数
            count = que.size();
            // 存储当前层的节点
            vector<int> temp;

            while (count--)
            {
                TreeNode *cur = que.front();
                que.pop();
                temp.push_back(cur->val);

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }

            ret.push_back(temp);
        }

        return ret;
    }
};
```

根据上面的层序遍历，可以完成下面类似的题目：

!!! info

    下面的题目是部分与层序遍历相关的题目，后面也会有其他题目会使用到层序遍历的思路，代码也可能基本类似

#### 力扣107.二叉树的层序遍历Ⅱ

[力扣107.二叉树的层序遍历Ⅱ](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，返回其节点值自底向上的层序遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

    示例 1：

    <img src="2. 二叉树基础题目.assets\tree1.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：[[15,7],[9,20],[3]]
    ```

    示例 2：

    ```c++
    输入：root = [1]
    输出：[[1]]
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

本题就是将正常层序遍历的结果集反转即可

**参考代码：**

```c++
class Solution107
{
public:
    vector<vector<int>> levelOrderBottom(TreeNode *root)
    {
        // 记录当前层节点的个数
        int count = 0;
        vector<vector<int>> ret;

        queue<TreeNode *> que;

        que.push(root);
        while (!que.empty() && root != nullptr)
        {
            count = que.size();
            // 存储当前层的节点
            vector<int> temp;

            while (count--)
            {
                TreeNode *cur = que.front();
                que.pop();
                temp.push_back(cur->val);

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }

            ret.push_back(temp);
        }

        reverse(ret.begin(), ret.end());

        return ret;
    }
};
```

#### 力扣199.二叉树的右视图

[力扣199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

**问题描述：**

!!! quote
    给定一个二叉树的根节点`root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

    示例 1：

    ```c++
    输入：root = [1,2,3,null,5,null,4]
    输出：[1,3,4]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\tmpd5jn43fs-1.png">

    示例 2：

    输入：root = [1,2,3,4,null,null,null,5]

    输出：[1,3,4,5]

    解释：

    <img src="2. 二叉树基础题目.assets\tmpkpe40xeh-1.png">

    示例 3：

    ```c++
    输入：root = [1,null,3]
    输出：[1,3]
    ```

    示例 4：

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

所谓右视图，就是只看得到最右侧的节点，所以从层序遍历的角度来看，只需要取出每一层的最后一个节点即可

**参考代码：**

```c++
class Solution199
{
public:
    vector<int> rightSideView(TreeNode *root)
    {
        int count = 0;
        vector<int> ret;

        queue<TreeNode *> que;
        que.push(root);

        while (!que.empty() && root != nullptr)
        {
            count = que.size();
            while (count)
            {
                TreeNode *cur = que.front();
                que.pop();
                count--;
                // 当前层最后一个节点就是右视图可以看到的唯一节点
                if (count == 0)
                    ret.push_back(cur->val);

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
        }

        return ret;
    }
};
```

#### 力扣637.二叉树的层平均值

[力扣637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

**问题描述：**

!!! quote

    给定一个非空二叉树的根节点`root`, 以数组的形式返回每一层节点的平均值。与实际答案相差$10^{-5}$以内的答案可以被接受。

    示例 1：

    <img src="2. 二叉树基础题目.assets\avg1-tree.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：[3.00000,14.50000,11.00000]
    解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
    因此返回 [3, 14.5, 11] 。
    ```

    示例 2:

    <img src="2. 二叉树基础题目.assets\avg2-tree.jpg">

    ```c++
    输入：root = [3,9,20,15,7]
    输出：[3.00000,14.50000,11.00000]
    ```

**思路分析：**

只需要在层序遍历中计算总和，最后在进入下一层之前计算当前层的平均值即可

**参考代码：**

```c++
class Solution637
{
public:
    vector<double> averageOfLevels(TreeNode *root)
    {
        // 记录每一层的总和
        double sum = 0;
        // 记录每一层节点的个数
        int count = 0;

        vector<double> ret;
        queue<TreeNode *> que;

        que.push(root);

        while (!que.empty())
        {
            count = que.size();
            int temp = count;
            while (temp--)
            {
                TreeNode *cur = que.front();
                que.pop();

                sum += cur->val;

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }

            // 计算平均值
            ret.push_back(sum / count);

            sum = 0;
        }

        return ret;
    }
};
```

#### 力扣429.N叉树的层序遍历

[力扣429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

**问题描述：**

!!! quote

    给定一个N叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

    树的序列化输入是用层序遍历，每组子节点都由`null`值分隔（参见示例）。

    示例 1：

    <img src="2. 二叉树基础题目.assets\narytreeexample.png">

    ```c++
    输入：root = [1,null,3,2,4,null,5,6]
    输出：[[1],[3,2,4],[5,6]]
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\sample_4_964.png">

    ```c++
    输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
    ```

**思路分析：**

基本思路还是层序遍历，但是注意，每一个孩子都存储在vector中，所以需要遍历vector将节点插入到队列

**参考代码：**

```c++
class Solution429
{
public:
    vector<vector<int>> levelOrder(Node* root)
    {
        int count = 0;

        vector<vector<int>> ret;
        queue<Node*> que;
        que.push(root);

        while(!que.empty() && root != nullptr)
        {
            count = que.size();
            vector<int> temp;
            while(count--)
            {
                Node* cur = que.front();
                que.pop();

                temp.push_back(cur->val);
                for(auto node : cur->children)
                    que.push(node);
            }

            ret.push_back(temp);
        }

        return ret;
    }
};
```

#### 力扣515.在每个树行中找最大值

[力扣515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)

**问题描述：**

!!! quote

    给定一棵二叉树的根节点`root`，请找出该二叉树中每一层的最大值。

    示例1：

    <img src="2. 二叉树基础题目.assets\largest_e1.jpg">

    ```c++
    输入: root = [1,3,2,5,3,null,9]
    输出: [1,3,9]
    ```

    示例2：

    ```c++
    输入: root = [1,2,3]
    输出: [1,3]
    ```

**思路分析：**

使用层序遍历，在每一层中找出最大值即可

**参考代码：**

```c++
class Solution515
{
public:
    vector<int> largestValues(TreeNode* root)
    {
        int count = 0;

        vector<int> ret;

        queue<TreeNode*> que;
        que.push(root);

        while(!que.empty() && root != nullptr)
        {
            count = que.size();

            // 本题存在负数，初始值不可以为0
            // 否则当前层全是负数情况下无法找到最大值
            int maxVal = INT_MIN;
            while(count--)
            {
                TreeNode* cur = que.front();
                que.pop();

                maxVal = max(maxVal, cur->val);

                if(cur->left)
                    que.push(cur->left);

                if(cur->right)
                    que.push(cur->right);
            }
            ret.push_back(maxVal);
        }

        return ret;
    }
};
```

#### 力扣116.填充每个节点的下一个右侧节点指针

[力扣116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)

**问题描述：**

!!! quote

    给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

    ```c++
    struct Node {
        int val;
        Node *left;
        Node *right;
        Node *next;
    }
    ```

    填充它的每个`next`指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将`next`指针设置为`NULL`。

    初始状态下，所有`next`指针都被设置为`NULL`。

    示例 1：

    <img src="2. 二叉树基础题目.assets\116_sample.png">

    ```c++
    输入：root = [1,2,3,4,5,6,7]
    输出：[1,#,2,3,#,4,5,6,7,#]
    解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
    ```

    示例 2:

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

使用层序遍历，将每一层的节点直接相连，除了每一层的最后一个节点需要指向空

```c++
class Solution116
{
public:
    Node *connect(Node *root)
    {
        int count = 0;

        queue<Node *> que;

        que.push(root);

        while (!que.empty() && root != nullptr)
        {
            count = que.size();

            while (count)
            {
                count--;
                Node *cur = que.front();
                que.pop();
                if (count == 0)
                    cur->next = nullptr;
                else
                    cur->next = que.front();

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
        }

        return root;
    }
};
```

#### 力扣117.填充每个节点的下一个右侧节点指针Ⅱ

[类似力扣116.力扣117填充每个节点的下一个右侧节点指针Ⅱ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

本题和116题不一样的是，本题是普通的二叉树，但是使用层序遍历不需要考虑这个问题，所以可以直接使用116题的代码：

**参考代码：**

```c++
class Solution117
{
public:
    Node *connect(Node *root)
    {
        int count = 0;

        queue<Node *> que;

        que.push(root);

        while (!que.empty() && root != nullptr)
        {
            count = que.size();

            while (count)
            {
                count--;
                Node *cur = que.front();
                que.pop();
                if (count == 0)
                    cur->next = nullptr;
                else
                    cur->next = que.front();

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }
        }

        return root;
    }
};
```

## 力扣226.翻转二叉树

[力扣226.翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/)

**问题描述：**

!!! quote

    给你一棵二叉树的根节点`root`，翻转这棵二叉树，并返回其根节点。

    示例 1：

    <img src="2. 二叉树基础题目.assets\invert1-tree.jpg">

    ```c++
    输入：root = [4,2,7,1,3,6,9]
    输出：[4,7,2,9,6,3,1]
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\invert2-tree.jpg">

    ```c++
    输入：root = [2,1,3]
    输出：[2,3,1]
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

1. 解法1：后序遍历+交换节点
    
    本题的基本思路的是遍历二叉树并翻转当前节点的左右孩子节点，关键的问题就是使用哪一种递归方式。首先考虑最直观的思路：先获取到左节点和右节点再进行交换，根据上面的思路可以看出，获取到左节点和右节点就是递归遍历二叉树的过程，而交换节点就是单层递归函数需要处理的逻辑，所以整体就是一个后序遍历

    基本的思路如下：

    ```
    以下面的二叉树为例
        4                              4
    2        7         -->        7          2
    1     3  6      8          8         6  3        1
    后序遍历交换过程如下：
    4->左->2->左->1->左->nullptr，返回nullptr到1的函数栈帧中
                1->右->nullptr，返回nullptr到1的函数栈帧中
                交换左和右，返回当前的1节点到2的函数栈帧中
        2->右->3->左->nullptr，返回nullptr到3的函数栈帧中
                3->右->nullptr，返回nullptr到3的函数栈帧中
                交换左和右，返回当前3节点到2的函数栈帧中
        交换1和3，返回当前2节点到4的函数栈帧中
        至此，左子树的子树全部翻转完毕
    4->右->7->左->6->左->nullptr，返回nullptr到6的函数栈帧中
                6->右->nullptr，返回nullptr到6的函数栈帧中
                交换左和右，返回当前6到7的函数栈帧中
        7->右->8->左->nullptr，返回nullptr到8的函数栈帧中
                8->右->nullptr，返回nullptr到8的函数栈帧中
                交换左和右，返回8到7的函数栈帧中
        交换左和右，返回7到4的函数栈帧中
        至此，右子树的子树全部翻转完毕
    交换左和右，返回4结束函数
    至此，整棵树翻转完毕
    ```

2. 解法2：前序遍历

    前序遍历过程中，先处理当前节点再获取左右节点，本质和后序遍历基本一致，只不过是先交换再遍历之后的子树再交换

3. 解法3：中序遍历

    本题也可以考虑使用中序遍历，但是需要注意的是中序遍历的顺序是左中右，在本题中也就是先遍历到左节点，接着就进行交换。但是在接下来遍历右子树的时候就不难发现，上一步交换已经将原来的左节点和右节点进行了交换，此时的右子树就是原来的左子树，如果再进行交换就会回到原来的子树形式，所以下一次遍历不能遍历右子树而应该继续遍历左子树

4. 解法4：层序遍历

    本题也可以考虑使用层序遍历，只需要在插入节点到队列前先交换节点即可

**关键步骤：**

本题可以考虑在交换节点时使用`swap`函数，但是需要注意交换的不能是局部变量，即不可以交换用变量记录的节点

**参考代码：**

=== "后序遍历（不使用swap）"

    ```c++
    class Solution226_1_1
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {
            if (root == nullptr)
                return nullptr;

            TreeNode *left = invertTree(root->left);
            TreeNode *right = invertTree(root->right);

            // 单层函数处理逻辑
            root->left = right;
            root->right = left;

            return root;
        }
    };
    ```

=== "后序遍历（使用swap）"

    ```c++
    class Solution226_1_2
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {
            if (root == nullptr)
                return nullptr;

            invertTree(root->left);
            invertTree(root->right);

            // 单层函数处理逻辑
            swap(root->left, root->right);

            return root;
        }
    };
    ```

=== "前序遍历（递归）"

    ```c++
    class Solution226_2_1
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {
            if (root == nullptr)
                return nullptr;

            swap(root->left, root->right);
            invertTree(root->left);
            invertTree(root->right);

            return root;
        }
    };
    ```

=== "前序遍历（迭代）"

    ```c++
    class Solution226_2_2
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {

            stack<TreeNode*> st;

            st.push(root);
            while(!st.empty() && root != nullptr)
            {
                TreeNode* cur = st.top();
                st.pop();
                swap(cur->left, cur->right);
                if(cur->left)
                    st.push(cur->left);
                if(cur->right)
                    st.push(cur->right);
            }

            return root;
        }
    };
    ```

=== "中序遍历"

    ```c++
    class Solution226_3
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {
            if (root == nullptr)
                return nullptr;

            invertTree(root->left);
            swap(root->left, root->right);
            invertTree(root->left);

            return root;
        }
    };
    ```

=== "层序遍历"

    ```c++
    class Solution226_4
    {
    public:
        TreeNode *invertTree(TreeNode *root)
        {
            queue<TreeNode*> que;

            que.push(root);
            while(!que.empty() && root != nullptr)
            {
                int count = que.size();
                while(count--)
                {
                    TreeNode* cur = que.front();
                    que.pop();
                    swap(cur->left, cur->right);
                    if(cur->left)
                        que.push(cur->left);
                    if(cur->right)
                        que.push(cur->right);
                }
            }

            return root;
        }
    };
    ```

## 力扣965.单值二叉树

[力扣965.单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/description/)

**问题描述：**

!!! quote

    如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。

    只有给定的树是单值二叉树时，才返回`true`；否则返回`false`。

    示例 1：

    <img src="2. 二叉树基础题目.assets\screen-shot-2018-12-25-at-50104-pm.png" style="zoom:50%;">

    ```c++
    输入：[1,1,1,1,1,null,1]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\screen-shot-2018-12-25-at-50050-pm.png" style="zoom:50%;">

    ```c++
    输入：[2,2,2,5,2]
    输出：false
    ```

**思路分析：**

1. 解法1：中序遍历

    判断当前值是否和他的左孩子和右孩子相等，如果不相等直接返回`false`即可，如果遍历到空节点还没有出现`false`，那么就说明一直都是相等的

2. 解法2：层序遍历

    思路和中序遍历基本一致，只是通过一层一层的遍历判断每一个节点是否相同

**参考代码：**

=== "前序遍历"

    ```c++
    class Solution965_1
    {
    public:
        bool isUnivalTree(TreeNode *root)
        {
            if (!root)
                return true;

            if (root->left && root->val != root->left->val)
                return false;

            if (root->right && root->val != root->right->val)
                return false;

            return isUnivalTree(root->left) && isUnivalTree(root->right);
        }
    };
    ```

=== "层序遍历"

    ```c++
    class Solution965_2
    {
    public:
        bool isUnivalTree(TreeNode *root)
        {
            queue<TreeNode *> que;

            que.push(root);

            while (!que.empty())
            {
                TreeNode *cur = que.front();
                que.pop();

                if (cur->left && cur->val != cur->left->val)
                    return false;
                if (cur->right && cur->val != cur->right->val)
                    return false;

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }

            return true;
        }
    };
    ```

## 力扣101.对称二叉树

[力扣101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)

**问题描述：**

!!! quote

    给你一个二叉树的根节点`root`， 检查它是否轴对称。

    示例 1：

    <img src="2. 二叉树基础题目.assets\1698026966-JDYPDU-image.png">

    ```c++
    输入：root = [1,2,2,3,4,4,3]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\1698027008-nPFLbM-image.png">

    ```c++
    输入：root = [1,2,2,null,3,null,3]
    输出：false
    ```

**思路分析：**

判断一棵树是否是对称二叉树就是要比较左子树是否可以翻转为对应的右子树，即判断左子树的值是否等于右子树对应的值（左子树的外侧等于右子树的外侧，左子树的内侧等于右子树的内侧）

```
以下面的二叉树为例：
          1
    2           2
3       4   4        3
最基本的思路如下：
1->左->2->左->3
 ->右->2->左->3
 相等返回true给2节点的函数栈帧
       2->右->4
       2->左->4
 相等返回true给2节点的函数栈帧
左子树的2和右子树的2返回true给1的函数栈帧
```

从上面的过程可以发现，需要先判断左子树的孩子和右子树的孩子是否对应一致，所以采用的遍历顺序只能是后序（左右中），因为只有后序才能满足先遍历到左右子树获取到结果，再遍历根节点向上层返回结果，并且因为需要同时获取到左孩子和右孩子，仅仅使用一个根节点肯定是不够的，所以还需要额外添加一个函数，在函数内部同时遍历两棵子树，此时就确定了函数的参数为两个，分别是左节点和右节点，因为只需要判断节点是否相等，所以返回值为布尔类型即可接着考虑递归终止条件：一共有下面几种情况：
1. 左节点为空，右节点不为空->`false`
2. 左节点不为空，右节点为空->`false`
3. 左节点和右节点都为空->`true`
4. 左节点和右节点的值不相等->`false`

上面4步中的前三步是为了排除左节点和右节点可能为空的情况

最后就是单层处理逻辑：一旦判断了左节点和右节点相等，就可以向上层返回结果，例如基本思路中的「左子树的2和右子树的2返回`true`给1的函数

**参考代码：**

=== "前序遍历（递归）"

    ```c++
    class Solution101_1
    {
    public:
        // 同时判断两棵树
        bool _isSymmetric(TreeNode *left, TreeNode *right)
        {
            // 终止条件
            if (!left && right || left && !right)
                return false;
            else if (!left && !right)
                return true;
            else if (left->val != right->val)
                return false;

            // 遍历两棵子树的外侧
            bool outside = _isSymmetric(left->left, right->right);
            // 遍历两棵子树的内侧
            bool inside = _isSymmetric(left->right, right->left);

            // 单层处理逻辑
            return outside && inside;
        }

        bool isSymmetric(TreeNode *root)
        {
            if (!root)
                return true;
            return _isSymmetric(root->left, root->right);
        }
    };
    ```

=== "前序遍历（迭代）"

    ```c++
    class Solution101_2
    {
    public:
        bool isSymmetric(TreeNode *root)
        {
            if (!root)
                return true;
            queue<TreeNode *> que;

            que.push(root->left);
            que.push(root->right);

            while (!que.empty())
            {
                TreeNode *left = que.front();
                que.pop();
                TreeNode *right = que.front();
                que.pop();
                if (!left && right || left && !right)
                    return false;
                else if (!left && !right)
                    continue;
                else if (left->val != right->val)
                    return false;

                // 先插入外侧
                que.push(left->left);
                que.push(right->right);
                // 再插入内侧
                que.push(left->right);
                que.push(right->left);
            }

            return true;
        }
    };
    ```

## 力扣100.相同的树

[力扣100.相同的树](https://leetcode.cn/problems/same-tree/description/)

**问题描述：**

!!! quote

    给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。

    如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

    示例 1：

    <img src="2. 二叉树基础题目.assets\ex1.jpg">

    ```c++
    输入：p = [1,2,3], q = [1,2,3]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\ex2.jpg">

    ```c++
    输入：p = [1,2], q = [1,null,2]
    输出：false
    ```

    示例 3：

    <img src="2. 二叉树基础题目.assets\ex3.jpg">

    ```c++
    输入：p = [1,2,1], q = [1,1,2]
    输出：false
    ```

**思路分析：**

本题思路和前一题思路基本一样，只是从一棵树中判断变为了两棵树中判断，需要先比较两棵树的左右孩子再将结果返回给根节点，所以需要使用到后序遍历

**参考代码：**

```c++
class Solution100
{
public:
    bool isSameTree(TreeNode *p, TreeNode *q)
    {
        if (!p && q || p && !q)
            return false;
        else if (!p && !q)
            return true;
        else if (p->val != q->val)
            return false;

        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## 力扣572.另一棵树的子树

[力扣572.另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)

**问题描述：**

!!! quote
    给你两棵二叉树`root`和`subRoot`。检验`root`中是否包含和`subRoot`具有相同结构和节点值的子树。如果存在，返回`true`；否则，返回`false`。

    二叉树`tree`的一棵子树包括`tree`的某个节点和这个节点的所有后代节点。`tree`也可以看做它自身的一棵子树。

    示例 1：

    <img src="2. 二叉树基础题目.assets\1724998676-cATjhe-image.png">

    ```c++
    输入：root = [3,4,5,1,2], subRoot = [4,1,2]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\1724998698-sEJWnq-image.png">

    ```c++
    输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
    输出：false
    ```

**思路分析：**

本题判断一棵树是否是另一棵树的子树，就是判断是否存在一棵树和给定树相同，所以需要用到上一题的思路对两棵树是否相同做出判断，但是本题还需要考虑一个问题：如何在一棵完整的树中找到子树，实际上只需要将每一个节点作为根，依次判断以该根节点出发的子树是否和给定树相同

**参考代码：**

```c++
class Solution572
{
public:
    bool isSameTree(TreeNode *p, TreeNode *q)
    {
        if (!p && q || p && !q)
            return false;
        else if (!p && !q)
            return true;
        else if (p->val != q->val)
            return false;

        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }

    bool isSubtree(TreeNode *root, TreeNode *subRoot)
    {
        if (!root)
            return false;
        // 先判断根是否与子树相同
        if (isSameTree(root, subRoot))
            return true;

        // 再判断左子树或者右子树是否与子树相同
        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);
    }
};
```

## 力扣104.二叉树的最大深度

[力扣104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

**问题描述：**

!!! quote

    给定一个二叉树`root`，返回其最大深度。

    二叉树的最大深度是指从根节点到最远叶子节点的最长路径上的节点数。

    示例 1：

    <img src="2. 二叉树基础题目.assets\tmp-tree.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：3
    ```

    示例 2：

    ```c++
    输入：root = [1,null,2]
    输出：2
    ```

**思路分析：**

1. 解法1：后序遍历
    
    二叉树的最大深度实际上应该用前序遍历进行求解，而后序遍历一般用来求二叉树的高度。但是因为二叉树的最大深度就是根节点的高度，而后序遍历的思路就是将当前层的高度返回给上一层，由上一层统计当前高度，一直到根节点，此时根节点的高度就是二叉树的最大深度

2. 解法2：层序遍历

    既然是层序遍历，那么就是按照层进行的，此时二叉树的高度就是当前二叉树的层数，只需要每遍历一层就更新层数

**参考代码：**

=== "后序遍历"

    ```c++
    class Solution104_1
    {
    public:
        int maxDepth(TreeNode *root)
        {
            if (root == nullptr)
                return 0;
            if (!root->left && !root->right)
                return 1;

            int leftHeight = maxDepth(root->left);
            int rightHeight = maxDepth(root->right);

            return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;
        }
    };
    ```

=== "层序遍历"

    ```c++
    class Solution104_2
    {
    public:
        int maxDepth(TreeNode *root)
        {
            int floor = 0;
            int count = 0;
            queue<TreeNode *> que;
            que.push(root);

            while (!que.empty() && root != nullptr)
            {
                count = que.size();

                while (count--)
                {
                    TreeNode *cur = que.front();
                    que.pop();

                    if (cur->left)
                        que.push(cur->left);

                    if (cur->right)
                        que.push(cur->right);
                }

                floor++;
            }

            return floor;
        }
    };
    ```

## 力扣559.N叉树的最大深度

[力扣559.N叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)

**问题描述：**

!!! quote

    给定一个`N`叉树，找到其最大深度。

    最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

    `N`叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

    示例 1：

    <img src="2. 二叉树基础题目.assets\narytreeexample.png">

    ```c++
    输入：root = [1,null,3,2,4,null,5,6]
    输出：3
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\sample_4_964.png">

    ```c++
    输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
    输出：5
    ```

**思路分析：**

1. 解法1：后序遍历
    
    本题和上一题思路基本一致，只是在处理遍历孩子节点时需要使用到循环依次获取到孩子进行遍历

2. 解法2：层序遍历

    和上题思路一致，但是需要使用循环遍历获取孩子

**参考代码：**

=== "后序遍历"

    ```c++
    class Solution559_1
    {
    public:
        int maxDepth(Node *root)
        {
            if (!root)
                return 0;

            int depth = 0;
            for (int i = 0; i < root->children.size(); i++)
            {
                depth = max(depth, maxDepth(root->children[i]));
            }

            return depth + 1;
        }
    };
    ```

=== "层序遍历"

    ```c++
    class Solution559_2
    {
    public:
        int maxDepth(Node *root)
        {
            queue<Node *> que;
            int floor = 0, count = 0;
            que.push(root);

            while (!que.empty() && root)
            {
                count = que.size();
                while (count--)
                {
                    Node *cur = que.front();
                    que.pop();

                    for (int i = 0; i < cur->children.size(); i++)
                    {
                        que.push(cur->children[i]);
                    }
                }

                floor++;
            }

            return floor;
        }
    };
    ```

## 力扣111.二叉树的最小深度

[力扣111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

**问题描述：**

!!! quote

    给定一个二叉树，找出其最小深度。

    最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

    说明：叶子节点是指没有子节点的节点。

    示例 1：

    <img src="2. 二叉树基础题目.assets\tmp-tree.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：2
    ```

    示例 2：

    ```c++
    输入：root = [2,null,3,null,4,null,5,null,6]
    输出：5
    ```

**思路分析：**

1. 解法1：后序遍历

    求二叉树的最小深度只需要在二叉树的最大深度的求解过程中取出最小值即可，但是需要注意，如果左子树或者右子树不存在，此时不存在的子树高度就为0，此时0就会被当做最小高度，但是实际上此时的最小高度应该是存在的子树的高度，所以需要额外处理左子树或者右子树不存在的情况

2. 解法2：层序遍历

    求最小深度本质就是找到最近的一个叶子结点，所以在层序遍历中第一次遇到叶子节点就返回该叶子结点的深度即可

**参考代码：**

=== "后序遍历"

    ```c++
    class Solution111_1
    {
    public:
        int minDepth(TreeNode *root)
        {
            if (!root)
                return 0;

            int leftHeight = minDepth(root->left);
            int rightHeight = minDepth(root->right);

            int depth = 0;
            if (leftHeight && rightHeight)
                depth = min(leftHeight, rightHeight);
            else if (leftHeight || rightHeight)
                depth = leftHeight ? leftHeight : rightHeight;

            return depth + 1;
        }
    };
    ```

=== "层序遍历"

    ```c++
    class Solution111_2
    {
    public:
        int minDepth(TreeNode *root)
        {
            // 初始化时高度为1
            int count = 0, floor = 1;
            queue<TreeNode *> que;
            que.push(root);

            while (!que.empty() && root != nullptr)
            {
                count = que.size();

                while (count--)
                {
                    TreeNode *cur = que.front();
                    que.pop();

                    if (cur->left)
                        que.push(cur->left);
                    if (cur->right)
                        que.push(cur->right);

                    // 找到一个叶子节点就直接返回
                    if (!cur->left && !cur->right)
                    {
                        return floor + 1;
                    }
                }
                floor++;
            }

            return 0;
        }
    };
    ```

## 力扣222.完全二叉树的节点个数

[力扣222.完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

**问题描述：**

!!! quote

    给你一棵完全二叉树的根节点`root`，求出该树的节点个数。

    完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第$h$层（从第 0 层开始），则该层包含$1~2^h$个节点。

    示例 1：

    <img src="2. 二叉树基础题目.assets\complete.jpg">

    ```c++
    输入：root = [1,2,3,4,5,6]
    输出：6
    ```

    示例 2：

    ```c++
    输入：root = []
    输出：0
    ```

    示例 3：

    ```c++
    输入：root = [1]
    输出：1
    ```

**思路分析：**

本题最直接的思路就是遍历整棵二叉树，遍历过程中遇到一个节点总数加1即可，但是这个做法没有用到题目给的「完全二叉树」的条件，对于一棵完全二叉树来说，可以使用公式来计算对应的满二叉树的节点个数，不是满二叉树再进行一一统计即可

**参考代码：**

=== "对于一般二叉树——直接累加"

    ```c++
    class Solution222_1
    {
    public:
        int countNodes(TreeNode *root)
        {
            if (root == nullptr)
                return 0;

            int leftNum = countNodes(root->left);
            int rightNum = countNodes(root->right);

            return leftNum + rightNum + 1;
        }
    };
    ```

=== "对于完全二叉树——满二叉树时使用公式计算跳过遍历"

    ```c++
    class Solution222_2
    {
    public:
        int countNodes(TreeNode *root)
        {
            if (!root)
                return 0;

            // 是满二叉树时直接返回2^深度-1
            // 如果左子树和右子树深度相等说明当前子树是满二叉树（以完全二叉树为前提）
            int leftHeight = 0;
            int rightHeight = 0;
            TreeNode *leftNode = root->left;
            TreeNode *rightNode = root->right;
            while (leftNode)
            {
                leftHeight++;
                leftNode = leftNode->left;
            }
            while (rightNode)
            {
                rightHeight++;
                rightNode = rightNode->right;
            }

            if (leftHeight == rightHeight)
            {
                // 说明是满二叉树
                // 注意运算优先级
                return (2 << leftHeight) - 1;
            }

            // 遍历剩余子树
            leftHeight = countNodes(root->left);
            rightHeight = countNodes(root->right);

            return leftHeight + rightHeight + 1;
        }
    };
    ```

## 力扣110.平衡二叉树

[力扣110.平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)

**问题描述：**

!!! quote

    给定一个二叉树，判断它是否是平衡二叉树

    示例 1：

    <img src="2. 二叉树基础题目.assets\balance_1.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\balance_2.jpg">

    ```c++
    输入：root = [1,2,2,3,3,null,null,4,4]
    输出：false
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：true
    ```

**思路分析：**

所谓平衡二叉树，就是该树所有节点的左右子树的高度相差不超过1。根据这个特点可以想到本题的基本思路就是获取左右子树的高度，判断差值的绝对值是否大于1，不大于就继续比较

**参考代码：**

```c++
class Solution110
{
public:
    // 获取二叉树高度
    int getHeight(TreeNode *root)
    {
        if (!root)
            return 0;

        int leftHeight = getHeight(root->left);
        int rightHeight = getHeight(root->right);

        return max(leftHeight, rightHeight) + 1;
    }

    bool isBalanced(TreeNode *root)
    {
        if (!root)
            return true;

        int leftHeight = getHeight(root->left);
        int rightHeight = getHeight(root->right);

        if (abs(rightHeight - leftHeight) > 1)
            return false;

        return isBalanced(root->left) && isBalanced(root->right);
    }
};
```

## 力扣257.二叉树的所有路径

**问题描述：**

!!! quote

    给你一个二叉树的根节点`root`，按任意顺序，返回所有从根节点到叶子节点的路径。

    叶子节点 是指没有子节点的节点。
    
    示例 1：

    <img src="2. 二叉树基础题目.assets\paths-tree.jpg">

    ```c++
    输入：root = [1,2,3,null,5]
    输出：["1->2->5","1->3"]
    ```

    示例 2：

    ```c++
    输入：root = [1]
    输出：["1"]
    ```

**思路分析：**

本题的基本思路就是遍历一个节点就向`temp`结构中插入该节点，记录当前节点被遍历到。如果遇到一个节点左孩子为空，右孩子也为空，则一定是叶子节点，此时就要将`temp`中的字符依次构成路径字符串插入到结果集中，插入完成后需要弹出当前的叶子，继续遍历右子树。此处需要注意一个细节：如果当前就是右子树，那么需要继续弹出`temp`中的最后一个元素，所以需要将弹出逻辑单独作为一条语句，作为向上返回前一定要执行的语句

```
以下面的二叉树为例
     1
  2     3
4   5
结果集：["1->2->4", "1->2->5", "1->3"]
基本思路如下：
1->左->2->左->4->左->nullptr，返回到4的函数栈帧。temp=["1", "2", "4"]
             4->右->nullptr，返回到4的函数栈帧
             判断4左右均为空，说明是叶子节点，此时将temp中的内容构成结果：1->2->4
             弹出最后一个元素。temp=["1", "2"]
             返回到2的函数栈帧
       2->右->5->左->nullptr，返回到5的函数栈帧。temp=["1", "2", "5"]
              5->右->nullptr，返回到5的函数栈帧
              判断5左右均为空，说明是叶子节点，此时将temp中的内容构成结果：1->2->5
              弹出最后一个元素。temp=["1", "5"]
              返回到2的函数栈帧
       弹出最后一个元素。temp=["1"]
       返回到1的函数栈帧
1->右->3->左->nullptr，返回到3的函数栈帧。temp=["1", "3"]
       3->右->nullptr，返回到3的函数栈帧
       判断3左右均为空，说明是叶子节点，此时将temp中的内容构成结果：1->3
       弹出最后一个元素。temp=["1"]
       返回到1的函数栈帧
弹出最后一个元素。temp=[]
回到主调函数，结束
```

**参考代码：**

```c++
class Solution257
{
public:
    void addchar(TreeNode *root, vector<string> &ret, vector<string> &temp)
    {
        if (!root)
            return;

        temp.push_back(to_string(root->val));
        addchar(root->left, ret, temp);
        addchar(root->right, ret, temp);

        if (!root->left && !root->right)
        {
            string backup = "";
            for (int i = 0; i < temp.size(); i++)
            {
                backup += temp[i];
                if (i != temp.size() - 1)
                    backup += "->";
            }
            ret.push_back(backup);
        }
        temp.pop_back();
    }

    vector<string> binaryTreePaths(TreeNode *root)
    {
        vector<string> ret;
        vector<string> temp;

        addchar(root, ret, temp);

        return ret;
    }
};
```

## 力扣404.左叶子之和

[力扣404.左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/description/)

**问题描述：**

!!! quote

    给定二叉树的根节点`root`，返回所有左叶子之和。

    示例 1：

    <img src="2. 二叉树基础题目.assets\avg1-tree.jpg">

    ```c++
    输入: root = [3,9,20,null,null,15,7] 
    输出: 24 
    解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
    ```

    示例 2:

    ```c++
    输入: root = [1]
    输出: 0
    ```

**思路分析：**

本题最直观的思路就是遍历到左孩子时再处理左孩子，但是这里会陷入一个误区：不遍历右孩子。实际上，本题除了要遍历左子树的左孩子外，也需要遍历左子树的右孩子的左孩子、右子树的左孩子和右子树的右孩子的左孩子，所以本题的思路是：遍历整棵树，但是只处理是左孩子的情况

```
以下面的二叉树为例：
           3
     9           20
 11     21    15      7
      5
计算结果为：11+5+15=31
基本思路为：
3->左->9->左->11->左->nullptr，返回0到11的函数栈帧
              11->右->nullptr，返回0到11的函数栈帧
              返回0到9的函数栈帧
       判断11为9的左叶子，更新左叶子结果
       9->右->21->左->5->左->nullptr，返回0到5的函数栈帧
                     5->右->nullptr，返回0到5的函数栈帧
                     返回0到21的函数栈帧
             判断5为左孩子，更新左孩子结果
             21->右->nullptr，返回0到21的函数栈帧
             返回5到9的函数栈帧
        返回16到3的函数栈帧
3->右->20->左->15->左->nullptr，返回0到15的函数栈帧
              15->右->nullptr，返回0到15的函数栈帧
              返回0到20的函数栈帧
       判断15为20的左叶子，更新左叶子结果
       20->右->7->左->nullptr，返回0到7的函数栈帧
               7->右->nullptr，返回0到7的函数栈帧
               返回0到20的函数栈帧
       返回15到3的函数栈帧
返回31
```

**参考代码：**

```c++
class Solution404
{
public:
    int sumOfLeftLeaves(TreeNode *root)
    {
        if (!root)
            return 0;
        if (!root->left && !root->right)
            // 左孩子和右孩子都会空，无法判断当前孩子一定为左孩子
            // 所以直接返回0即可
            return 0;

        // 遍历左子树
        int leftNum = sumOfLeftLeaves(root->left);
        // 判断是否是左孩子，是就处理
        if (root->left && (!root->left->left && !root->left->right))
            leftNum = root->left->val;

        // 遍历右子树
        int rightNum = sumOfLeftLeaves(root->right);
        // 虽然遍历右子树，但是右孩子都不做处理

        return leftNum + rightNum;
    }
};
```

## 力扣513.找树左下角的值

[力扣513.找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

**问题描述：**

!!! quote

    给定一个二叉树的根节点`root`，请找出该二叉树的最底层最左边节点的值。

    假设二叉树中至少有一个节点。

    示例 1:

    <img src="2. 二叉树基础题目.assets\findbtnlefvalue1.jpg">

    ```c++
    输入: root = [2,1,3]
    输出: 1
    ```

    示例 2:

    <img src="2. 二叉树基础题目.assets\findbtnleftvalue2.jpg">

    ```c++
    输入: [1,2,3,4,null,5,6,null,null,7]
    输出: 7
    ```

**思路分析：**

1. 解法1：层序遍历

    本题最容易想到的解法就是层序遍历，在层序遍历中，只需要找到最底层的第一个出现的节点即可，为了防止被同层的节点覆盖，可以使用`flag`标记

2. 解法2：递归遍历

    递归法就是通过求深度控制最底层，在获取到最底层时就记录节点，否则继续遍历

**参考代码：**

=== "层序遍历"

    ```c++
    class Solution513_1
    {
    public:
        int findBottomLeftValue(TreeNode *root)
        {
            if (!root->left && !root->right)
                return root->val;
            queue<TreeNode *> que;
            que.push(root);

            TreeNode *ret = nullptr;

            while (!que.empty())
            {
                int count = que.size();
                bool floor = true;
                while (count--)
                {
                    TreeNode *cur = que.front();
                    que.pop();

                    if (cur->left && !cur->left->left && !cur->left->right && floor)
                    {
                        ret = cur->left;
                        floor = false;
                    }
                    else if (cur->right && !cur->right->left && !cur->right->right && floor)
                    {
                        ret = cur->right;
                        floor = false;
                    }

                    if (cur->left)
                        que.push(cur->left);
                    if (cur->right)
                        que.push(cur->right);
                }
            }

            return ret->val;
        }
    };
    ```

=== "递归遍历"

    ```c++
    class Solution513_2
    {
    public:
        int maxDepth = INT_MIN;
        int result = 0;

        void traversalWithDepth(TreeNode *root, int depth)
        {
            // 遍历到叶子节点时判断是不是最底层的叶子
            if (!root->left && !root->right)
            {
                if (depth > maxDepth)
                {
                    maxDepth = depth;
                    result = root->val;
                }
                return;
            }

            // 遍历左子树
            if (root->left)
            {
                depth++;
                traversalWithDepth(root->left, depth);
                // 返回调用处时会向上一层返回
                depth--;
            }

            // 遍历右子树
            if (root->right)
            {
                depth++;
                traversalWithDepth(root->right, depth);
                // 返回调用处时会向上一层返回
                depth--;
            }
        }

        int findBottomLeftValue(TreeNode *root)
        {
            if (!root->left && !root->right)
                return root->val;

            int depth = 0;
            traversalWithDepth(root, depth);

            return result;
        }
    };
    ```

## 力扣112.路径总和

[力扣112.路径总和](https://leetcode.cn/problems/path-sum/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和`targetSum`。如果存在，返回`true`；否则，返回`false`。

    叶子节点是指没有子节点的节点。

    示例 1：

    <img src="2. 二叉树基础题目.assets\pathsum1.jpg">

    ```c++
    输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
    输出：true
    解释：等于目标和的根节点到叶节点路径如上图所示。
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\pathsum2.jpg">

    ```c++
    输入：root = [1,2,3], targetSum = 5
    输出：false
    解释：树中存在两条根节点到叶子节点的路径：
    (1 --> 2): 和为 3
    (1 --> 3): 和为 4
    不存在 sum = 5 的根节点到叶子节点的路径。
    ```

    示例 3：

    ```c++
    输入：root = [], targetSum = 0
    输出：false
    解释：由于树是空的，所以不存在根节点到叶子节点的路径。
    ```

**思路分析：**

本题基本思路：通过`sum`变量的值判断是否与目标值`targetSum`相等，并且当前节点需要满足是叶子节点，「当前节点是叶子」在本题中尤为重要，因为存在一种情况：还没到叶子时，`sum`就已经和`targetSum`相等，或者`sum`大于`targetSum`，对于上面这两种情况，如果单独处理会非常麻烦还不容易处理，所以针对上面的思路，考虑出递归的终止条件：

1. 当前节点是叶子节点，并且当前的`sum == targetSum`时，说明找到一条路径满足
2. 当前节点是叶子节点，但是当前的`sum != targetSum`时，说明当前路径此时不满足

既然要判断是叶子节点，就需要判断当前节点的左孩子和右孩子都是`nullptr`，所以为了防止出现空指针解引用的错误，在遍历下一层时也需要判断下一层是否为空。最后就是需要考虑到`sum`的计算问题，因为是不同的函数栈帧，在退回时`sum`的值会进行改变，或者说在一个函数内对`sum`的修改不影响另外一个函数中的`sum`，所以需要考虑到`sum`何时需要恢复到原来的数值，给出一种思路：先遍历左子树，此时`sum`加上左子树节点的值，进入新的函数栈帧，如果为`true`直接返回，代表找到一条路径；如果为`false`就要走右子树，此时就需要更新`sum`，让其减去左子树回到没有加左子树值的状态；接着遍历右子树，此时`sum`也是加上右子树节点的值，进入新的函数栈帧，如果为`true`直接返回，代表找到一条路径；如果为`false`就要走右子树，此时可以考虑恢复`sum`，也可以不考虑，因为走到右子树还没有找到路径，说明当前子树不存在一条根节点到叶子节点的路径和为`targetSum`，直接返回`false`，此时的`sum`因为是在当前节点的栈帧中更新的，既然不存在满足条件的路径，那么说明当前子树一定不存在满足条件的路径，向上返回时`sum`还是原来的`sum`

**参考代码：**

```c++
class Solution112
{
public:
    bool _hashPathSum(TreeNode *root, int targetSum, int sum)
    {
        if (!root->left && !root->right && sum == targetSum)
            return true;
        else if (!root->left && !root->right && sum != targetSum)
            return false;

        if (root->left)
        {
            sum += root->left->val;
            if (_hashPathSum(root->left, targetSum, sum))
                return true;

            sum -= root->left->val;
        }

        if (root->right)
        {
            sum += root->right->val;
            if (_hashPathSum(root->right, targetSum, sum))
                return true;

            // 此处的回溯可以保留也可以去掉，因为走到了这一步说明上面sum改变的值进入到右子树的栈帧空间返回的是false
            // 如果没有下面的回溯，那么走完if就直接走到了下面的return false回到上一层函数栈帧
            // 此时的sum依旧是没有加上右子树节点值的sum
            sum -= root->right->val;
        }

        return false;
    }

    bool hasPathSum(TreeNode *root, int targetSum)
    {
        if (!root)
            return false;
        else if (!root->left && !root->right && root->val == targetSum)
            return true;

        return _hashPathSum(root, targetSum, root->val);
    }
};
```

## 力扣113.路径总和Ⅱ

[力扣113.路径总和Ⅱ](https://leetcode.cn/problems/path-sum-ii/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`和一个整数目标和`targetSum`，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。

    叶子节点是指没有子节点的节点。

    示例 1：

    <img src="2. 二叉树基础题目.assets\pathsum1.jpg">

    ```c++
    输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
    输出：[[5,4,11,2],[5,8,4,5]]
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\pathsum2.jpg">

    ```c++
    输入：root = [1,2,3], targetSum = 5
    输出：[]
    ```

    示例 3：

    ```c++
    输入：root = [1,2], targetSum = 0
    输出：[]
    ```

**思路分析：**

本题和上题基本类似，不同的是，本题不是找到一条满足条件的路径就结束，而是找到所有满足条件的路径，所以不论是找到还是没有找到，都需要继续执行上层栈帧的回溯

**参考代码：**

```c++
class Solution113
{
public:
    void _pathSum(TreeNode *root, int targetSum, int sum, vector<int> &temp, vector<vector<int>> &ret)
    {
        if (!root->left && !root->right && sum == targetSum)
        {
            ret.push_back(temp);
            return;
        }

        if (root->left)
        {
            sum += root->left->val;
            temp.push_back(root->left->val);
            _pathSum(root->left, targetSum, sum, temp, ret);

            sum -= root->left->val;
            temp.pop_back();
        }

        if (root->right)
        {
            sum += root->right->val;
            temp.push_back(root->right->val);
            _pathSum(root->right, targetSum, sum, temp, ret);

            sum -= root->right->val;
            temp.pop_back();
        }
    }

    vector<vector<int>> pathSum(TreeNode *root, int targetSum)
    {
        if (!root)
            return {};
        else if (!root->left && !root->right && root->val == targetSum)
            return {{root->val}};

        vector<int> temp;
        vector<vector<int>> ret;
        temp.push_back(root->val);

        _pathSum(root, targetSum, root->val, temp, ret);

        return ret;
    }
};
```

## 力扣106.从中序与后序遍历序列构造二叉树

[力扣106.从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

**问题描述：**

!!! quote

    给定两个整数数组`inorder`和`postorder`，其中`inorder`是二叉树的中序遍历，`postorder`是同一棵树的后序遍历，请你构造并返回这棵二叉树。

    示例 1:

    <img src="2. 二叉树基础题目.assets\avg1-tree.jpg">

    ```c++
    输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
    输出：[3,9,20,null,null,15,7]
    ```

    示例 2:

    ```c++
    输入：inorder = [-1], postorder = [-1]
    输出：[-1]
    ```

**思路分析：**

根据后序遍历找出根节点，再根据根节点分别切割前序遍历数组和后序遍历数组重复调用函数直到数组为空时代表遍历完成，每一次遍历都会在其中找出当前数组的根节点，此时的根节点就是其对应的子树的根节点，将这个根节点向上返回即可依次构造出一棵完整的二叉树

**参考代码：**

```c++
class Solution106
{
public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
    {
        if (postorder.size() == 0)
            return nullptr;
        // 1. 根据后序遍历获取根节点
        int rootVal = postorder[postorder.size() - 1];
        TreeNode *root = new TreeNode(rootVal);

        // 2. 根据根节点在中序中分左区间数组和右区间数组
        int rootIndex = 0;
        for (int i = 0; i < inorder.size(); i++)
        {
            if (inorder[i] == rootVal)
            {
                rootIndex = i;
                break;
            }
        }

        // 左闭右开原则分割
        vector<int> inorderLeft(inorder.begin(), inorder.begin() + rootIndex);
        vector<int> inorderRight(inorder.begin() + rootIndex + 1, inorder.end());

        // 3. 根据根节点在后序中分左区间数组和右区间数组
        // 先舍去后序的最后一个元素
        postorder.resize(postorder.size() - 1);
        // 左闭右开原则分割
        vector<int> postorderLeft(postorder.begin(), postorder.begin() + inorderLeft.size());
        vector<int> postorderRight(postorder.begin() + inorderLeft.size(), postorder.end());

        // 4. 根据左中和左后、右中和右后重复上述步骤
        root->left = buildTree(inorderLeft, postorderLeft);
        root->right = buildTree(inorderRight, postorderRight);

        // 5. 返回根节点
        return root;
    }
};
```

## 力扣105.从前序与中序遍历序列构造二叉树

[力扣105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

**问题描述：**

!!! quote
    给定两个整数数组`preorder`和`inorder`，其中`preorder`是二叉树的先序遍历，`inorder`是同一棵树的中序遍历，请构造二叉树并返回其根节点。

    示例 1:

    <img src="2. 二叉树基础题目.assets\avg1-tree.jpg">

    ```c++
    输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
    输出: [3,9,20,null,null,15,7]
    ```

    示例 2:

    ```c++
    输入: preorder = [-1], inorder = [-1]
    输出: [-1]
    ```

**思路分析：**

本题和上题思路基本一致，只是使用的数组不同而已

**思考问题：**

!!! question

    是否可以根据前序遍历和后序遍历结果唯一确定一棵二叉树？

实际上是不可以的，因为前序遍历和后序遍历本质都是确定根节点所在位置，但是此时只能在这两个数组中确定整棵树的根节点，没有办法确定其他子树的节点，所以导致结果二叉树不唯一

**参考代码：**

```c++
class Solution105
{
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder)
    {
        // 检查输入数组的有效性
        if (preorder.size() == 0)
            return nullptr;

        // 获取根节点值
        int rootVal = preorder[0];
        TreeNode *root = new TreeNode(rootVal);

        // 在中序遍历中查找根节点位置
        int rootIndex = -1;
        for (int i = 0; i < inorder.size(); i++)
        {
            if (inorder[i] == rootVal)
            {
                rootIndex = i;
                break;
            }
        }

        // 分割中序数组 - 左子树
        vector<int> inorderLeft(inorder.begin(), inorder.begin() + rootIndex);
        // 分割中序数组 - 右子树
        vector<int> inorderRight(inorder.begin() + rootIndex + 1, inorder.end());

        // 分割前序数组时确保不会越界
        if (inorderLeft.size() > preorder.size() - 1)
            return nullptr;

        // 分割前序数组 - 左子树
        vector<int> preorderLeft(preorder.begin() + 1,preorder.begin() + 1 + inorderLeft.size());
        // 分割前序数组 - 右子树
        vector<int> preorderRight(preorder.begin() + 1 + inorderLeft.size(),preorder.end());

        // 递归构建左右子树
        root->left = buildTree(preorderLeft, inorderLeft);
        root->right = buildTree(preorderRight, inorderRight);

        return root;
    }
};
```

## 力扣654.最大二叉树

[力扣654.最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/)

**问题描述：**

给定一个不重复的整数数组`nums`。最大二叉树可以用下面的算法从`nums`递归地构建:

- 创建一个根节点，其值为`nums`中的最大值。
- 递归地在最大值左边的子数组前缀上构建左子树。
- 递归地在最大值右边的子数组后缀上构建右子树。
- 返回`nums`构建的最大二叉树。

示例 1：

<img src="2. 二叉树基础题目.assets\constructmaxvaluetree1.jpg">

```c++
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

示例 2：

<img src="2. 二叉树基础题目.assets\constructmaxvaluetree2.jpg">

```c++
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

**思路分析：**

1. 解法1：常规构建
   
    本题思路和前序、中序以及后序、中序构建二叉树思路基本一致，只是按照某种特定的规则

2. 解法2：单调栈

    具体见[算法：单调栈篇](#)

**参考代码：**

```c++
class Solution654
{
public:
    TreeNode *constructMaximumBinaryTree(vector<int> &nums)
    {
        if (nums.size() == 0)
            return nullptr;

        // 1. 找出最大值作为根节点
        int maxRootIndex = 0;
        for (int i = 0; i < nums.size(); i++)
            if (nums[i] > nums[maxRootIndex])
                maxRootIndex = i;

        TreeNode *root = new TreeNode(nums[maxRootIndex]);

        // 2. 根据最大值分割数组（左闭右开）
        vector<int> numsLeft(nums.begin(), nums.begin() + maxRootIndex);
        vector<int> numsRight(nums.begin() + maxRootIndex + 1, nums.end());

        // 3. 构建左子树和右子树
        root->left = constructMaximumBinaryTree(numsLeft);
        root->right = constructMaximumBinaryTree(numsRight);

        return root;
    }
};
```

## 力扣617.合并二叉树

[力扣617.合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/description/)

**问题描述：**

!!! quote

    给你两棵二叉树：`root1`和`root2`。

    想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为`null`的节点将直接作为新二叉树的节点。

    返回合并后的二叉树。

    注意: 合并过程必须从两个树的根节点开始。

    示例 1：

    <img src="2. 二叉树基础题目.assets\merge.jpg">

    ```c++
    输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
    输出：[3,4,5,5,4,null,7]
    ```

    示例 2：

    ```c++
    输入：root1 = [1], root2 = [1,2]
    输出：[2,2]
    ```

**思路分析：**

本题的基本思路如下：

1. 遍历两个树，如果两个树的同一个位置都有节点，直接累加，再遍历左子树和右子树，将结果节点链接到一棵树即可
2. 如果其中一个树节点为空，返回另外一棵树即可
3. 如果两个树都为空，直接返回空指针

**参考代码：**

```c++
class Solution617
{
public:
    TreeNode *mergeTrees(TreeNode *root1, TreeNode *root2)
    {
        if (!root1 && !root2)
            return nullptr;
        else if (!root1)
            return root2;
        else if (!root2)
            return root1;

        root1->val += root2->val;

        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);

        return root1;
    }
};
```

## 力扣700.二叉搜索树中的搜索

[力扣700.二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

**问题描述：**

!!! quote

    给定二叉搜索树（BST）的根节点`root`和一个整数值`val`。

    你需要在BST中找到节点值等于`val`的节点。 返回以该节点为根的子树。如果节点不存在，则返回`null`。

    示例 1:

    <img src="2. 二叉树基础题目.assets\searchBST1.jpg">

    ```c++
    输入：root = [4,2,7,1,3], val = 2
    输出：[2,1,3]
    ```

    示例 2:

    <img src="2. 二叉树基础题目.assets\searchBST2.jpg">

    ```c++
    输入：root = [4,2,7,1,3], val = 5
    输出：[]
    ```

**思路分析：**

本题的基本思路是根据二叉搜索树的特性进行折半查找，但是需要注意，本题虽然说返回的是以查找到的节点的子树，实际上还是返回指定的节点，只是在后台会用这个根节点遍历整棵子树，这一点是不需要刷题者关心的问题

**参考代码：**

```c++
class Solution700
{
public:
    TreeNode *searchBST(TreeNode *root, int val)
    {
        if (!root)
            return nullptr;

        else if (root->left && val < root->val)
            return searchBST(root->left, val);
        else if (root->right && val > root->val)
            return searchBST(root->right, val);

        return root->val == val ? root : nullptr;
    }
};
```

## 力扣98.验证二叉搜索树

[力扣98.验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/description/)

**问题描述：**

!!! quote

    给你一个二叉树的根节点`root`，判断其是否是一个有效的二叉搜索树。

    有效二叉搜索树定义如下：

    - 节点的左子树只包含小于当前节点的数。
    - 节点的右子树只包含大于当前节点的数。
    - 所有左子树和右子树自身必须也是二叉搜索树。

    示例 1：

    <img src="2. 二叉树基础题目.assets\isvalidBST1.jpg">

    ```c++
    输入：root = [2,1,3]
    输出：true
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\isvalidBST2.jpg">

    ```c++
    输入：root = [5,1,4,null,null,3,6]
    输出：false
    解释：根节点的值是 5 ，但是右子节点的值是 4 。
    ```

**思路分析：**

1. 解法1：中序遍历有序+额外空间

    本题最直接的思路就是根据题目给出的规则模拟，但是不能仅仅只判断单棵子树是否满足二叉搜索树的条件，例如下面的一棵树：

    ```
          5
      4       6
           3     7
    ```

    这棵树根节点为5，其左子树是4，4<5，右子树为6，6>5，当前子树满足二叉搜索树的条件
    再看根节点为6的子树，左子树为3，3<6，右子树为7，7>6，当前子树满足二叉搜索树的条件
    但是二叉搜索树除了叫「搜索树」，还叫「排序树」，即其中序遍历的结果是一个升序排序
    很明显，当前子树如果进行中序遍历，结果是45367，不满足排序树的特点，所以其不是二叉搜索树
    通过上面的例子可以看成，仅仅只判断每一棵子树是否是二叉搜索树不一定保证本题可以通过
    最简单的做法就是将二叉树的中序遍历结果插入到数组中，判断数组中的元素是否是升序，如果是那么当前树就是二叉搜索树，否则就不是

2. 解法2：双指针

    使用一个节点记录前一个节点的数值，在遍历二叉树的过程中直接进行比较

**参考代码：**

=== "中序遍历有序+额外空间"

    ```c++
    class Solution98_1
    {
    public:
        void traversal(TreeNode* root, vector<int>& ret)
        {
            if(!root)
                return;

            traversal(root->left, ret);
            ret.push_back(root->val);
            traversal(root->right, ret);
        }

        bool isValidBST(TreeNode *root)
        {
            vector<int> ret;

            traversal(root, ret);

            for(int i = 0; i < ret.size() - 1; i++)
                if(ret[i] >= ret[i + 1])
                    return false;

            return true;
        }
    };
    ```

=== "双指针"

    ```c++
    class Solution98_2
    {
    public:
        TreeNode* pre = nullptr;
        bool isValidBST(TreeNode *root)
        {
            if(!root)
                return true;

            bool left = isValidBST(root->left);
            if(pre && pre->val >= root->val)
                return false;

            // 更新pre为前一个节点
            pre = root;
            bool right = isValidBST(root->right);

            return left && right;
        }
    };
    ```

## 力扣530.二叉搜索树的最小绝对差

[力扣530.二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

**问题描述：**

!!! quote

    给你一个二叉搜索树的根节点`root`，返回树中任意两不同节点值之间的最小差值。

    差值是一个正数，其数值等于两值之差的绝对值。

    示例 1：

    <img src="2. 二叉树基础题目.assets\bst1.jpg">

    ```c++
    输入：root = [4,2,6,1,3]
    输出：1
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\bst2.jpg">

    ```c++
    输入：root = [1,0,48,null,null,12,49]
    输出：1
    ```

**思路分析：**

本题的基本思路是当前节点值减去前一个节点值，取`minVal`和该值的最小值即可

**参考代码：**

```c++
class Solution530
{
public:
    int minVal = INT_MAX;
    TreeNode *prev = nullptr;

    int getMinimumDifference(TreeNode *root)
    {
        if (!root)
            return 0;

        getMinimumDifference(root->left);
        if (prev && prev->val != root->val)
            minVal = min(minVal, abs(root->val - prev->val));
        prev = root;
        getMinimumDifference(root->right);

        return minVal;
    }
};
```

## 力扣501.二叉搜索树中的众数

[力扣501.二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

**问题描述：**

!!! quote

    给你一个含重复值的二叉搜索树（BST）的根节点`root`，找出并返回BST中的所有众数（即，出现频率最高的元素）。

    如果树中有不止一个众数，可以按 任意顺序 返回。

    假定BST满足如下定义：

    - 结点左子树中所含节点的值小于等于当前节点的值
    - 结点右子树中所含节点的值大于等于当前节点的值
    - 左子树和右子树都是二叉搜索树

    示例 1：

    <img src="2. 二叉树基础题目.assets\mode-tree.jpg">

    输入：root = [1,null,2,2]
    输出：[2]
    示例 2：

    输入：root = [0]
    输出：[0]

**思路分析：**

1. 解法1：中序遍历有序+个数统计
   
    本题最直观的思路就是遍历二叉搜索树，将元素依次插入vector，遍历vector使用哈希表统计元素出现的次数，找出出现次数最大的所有元素，这个思路适合于普通的二叉树，所以也同样适合于二叉搜索树

2. 解法2：双指针

    根据二叉搜索树的特性可以保证相同的元素出现在一起，类比有序数组。注意下面示例代码里面的一些处理技巧

**参考代码：**

=== "中序遍历有序+个数统计"

    ```c++
    class Solution501_1
    {
    public:
        void traversal(TreeNode *root, unordered_map<int, int> &countMap)
        {
            if (!root)
                return;

            traversal(root->left, countMap);
            // 统计出现频率
            countMap[root->val]++;
            traversal(root->right, countMap);
        }

        vector<int> findMode(TreeNode *root)
        {

            unordered_map<int, int> countMap;
            traversal(root, countMap);

            int maxCount = 0;
            vector<int> ret;
            for (auto &kv: countMap)
            {
                if (kv.second > maxCount)
                    maxCount = kv.second;
            }

            for (auto &kv: countMap)
            {
                if (kv.second == maxCount)
                    ret.push_back(kv.first);
            }

            for (auto &kv: countMap)
            {
                // 注意使用find确保当前插入的元素不存在于结果集中
                if (kv.second == maxCount && kv.first != ret[0] && find(ret.begin(), ret.end(), kv.first) == ret.end())
                    ret.push_back(kv.first);
            }

            return ret;
        }
    };
    ```

=== "双指针"

    ```c++
    class Solution501_2
    {
    public:
        // 记录最大频率
        int maxCount = 0;
        // 记录当前元素出现的频率
        int count = 0;
        // 结果集
        vector<int> ret;
        // 上一个节点
        TreeNode *prev = nullptr;

        void traversal(TreeNode *root)
        {
            if (!root)
                return;

            // 中序遍历
            traversal(root->left);

            // 中间处理
            // 统计当前元素出现频率
            if (prev == nullptr) // 前一个为空元素，说明当前元素一定为新出现的元素，count更新为1
                count = 1;
            else if (prev->val == root->val) // 前一个元素和当前元素相等，说明一定是重复元素
                count++;
            else
                count = 1; // 前一个元素和当前元素不相等，说明遇到新元素，count更新为1
            // 更新prev
            prev = root;

            // 如果count与maxCount相等，说明此时找到了最大出现频率的元素
            // 更新结果集
            // 使用if确保只插入一次满足最大出现频率的元素
            if (count == maxCount)
                ret.push_back(root->val);

            // 如果count大于maxCount说明前面已经更新的结果集有误，此时更新maxCount和结果集
            // 通过第二次的更新一定可以满足在当前状态下结果集中是当前出现频率最大的
            // 如果下一次有不同的值但是出现频率与最大频率相同，那么会因为上面的if插入到结果集而不会更新结果集
            if (count > maxCount)
            {
                maxCount = count;
                // 清空上一次的结果集
                ret.clear();
                // 重新更新结果集
                ret.push_back(root->val);
            }

            traversal(root->right);
        }

        vector<int> findMode(TreeNode *root)
        {
            traversal(root);

            return ret;
        }
    };
    ```

## 力扣236.二叉树的最近公共祖先

[力扣236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

**问题描述：**

!!! quote
    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

    百度百科中最近公共祖先的定义为：“对于有根树T的两个节点`p`、`q`，最近公共祖先表示为一个节点`x`，满足`x`是`p`、`q`的祖先且`x`的深度尽可能大（一个节点也可以是它自己的祖先）。”

    示例 1：

    <img src="2. 二叉树基础题目.assets\binarytree.png">

    ```c++
    输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输出：3
    解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\binarytree1.png">

    ```c++
    输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出：5
    解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
    ```
    示例 3：

    ```c++
    输入：root = [1,2], p = 1, q = 2
    输出：1
    ```

**思路分析：**

首先必须理解何为最近公共祖先，所谓祖先节点就是所有节点的父亲节点，一般指根节点，那么最近公共祖先就是最近的一个包含两个子节点的子树的根节点，其中要求深度最大，意味着如果出现一个根节点中包含了一棵子树，这棵子树的根节点包括了指定的两个子节点，那么这棵子树的根节点即为最近公共祖先，而不是子树根节点的父亲节点

理解了何为最近公共祖先，接下来就可以考虑本题的思路，本题最基本的思路就是：

1. 同一个子树中存在`p`，`q`，则此时`p`或者`q`其中一个可能是公共祖先
2. 不同子树中存在`p`，`q`，则此时二者的公共父亲就是公共祖先

所以现在的问题就演变为如何判断在一棵子树下：
1. 如果在`p`中找到`q`，则说明`p`是公共祖先，否则`q`是公共祖先
2. 如果`p`和`q`都是叶子节点，则找他们的公共祖先

在下面的代码中，有两种写法，第一种写法就是考虑了所有的情况，相对比较复杂，第二种情况就是在处理一般情况的同时处理了`p`或者`q`为最近公共祖先的情况，因为情况2的本质就是`p`和`q`在`p`或者`q`的子树下，那么在遍历二叉树的过程中，一定会优先查找到`p`或者`q`，此时就会返回`p`或者`q`，而因为`p`或者`q`一直是`q`或者`p`的孩子，所以在返回`left`或者`right`时只会返回其中一个，具体见代码

**参考代码：**

=== "写法1"

    ```c++
    class Solution236_1
    {
    public:
        // 判断是否在同一棵子树下
        bool isUnder(TreeNode *root, TreeNode *target)
        {
            if (!root)
                return false;

            if (root->val == target->val)
                return true;
            // 在该子树中找到了就返回true
            return isUnder(root->left, target) || isUnder(root->right, target);
        }

        // 遍历查找节点
        TreeNode *traversal(TreeNode *root, TreeNode *target)
        {
            if (!root)
                return nullptr;

            if (root->val == target->val)
                return root;

            TreeNode *left = traversal(root->left, target);
            TreeNode *right = traversal(root->right, target);

            if (left)
                return left;

            if (right)
                return right;

            return nullptr;
        }

        TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
        {
            // 找到两个节点
            TreeNode *node1 = traversal(root, p);
            TreeNode *node2 = traversal(root, q);

            // 判断p和q是否在同一棵子树下
            if (isUnder(node1, node2)) // q在p的子树中
                return p;
            else if (isUnder(node2, node1)) // p在q的子树中
                return q;

            // 如果既不在q也不再p，直接二者共有的父亲节点
            // 思路如下：
            // 从根节点开始遍历，如果在cur->left中找到了node1和node2，说明node1和node2在cur的左子树中
            // 继续向下遍历，直到cur->left不存在node1和node2，此时cur就是共有的父亲节点
            // 如果在cur->right中找到了node1和node2，说明node1和node2在cur的右子树中
            // 继续向下遍历，直到cur->right不存在node1和node2，此时cur就是共有的父亲节点
            TreeNode *cur = root;
            while (cur)
            {
                if (isUnder(cur->left, node1) && isUnder(cur->left, node2))
                    cur = cur->left;
                else if (isUnder(cur->right, node1) && isUnder(cur->right, node2))
                    cur = cur->right;
                else
                    break;
            }

            return cur;
        }
    };
    ```

=== "写法2"

    ```c++
    class Solution236_2
    {
    public:
        TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
        {
            // 如果当前节点为p或者q，则直接返回当前节点
            if (root == p || root == q || root == nullptr)
                return root;

            // 后序遍历
            // 先在左子树中找p和q，如果找到了p就会一直向上返回而不会继续找q
            // 对于一般情况（即p或者q都不是最近公共祖先）来说，p和q不会存在于同一条路径下
            // 所以也就不会出现遍历左子树和右子树都遍历的是同一个值p或者q
            TreeNode *left = lowestCommonAncestor(root->left, p, q);
            // 遍历右子树找p和q
            TreeNode *right = lowestCommonAncestor(root->right, p, q);

            // 处理
            // 如果左孩子不为空，右孩子也不为空，说明当前函数栈帧的root的值就是最近公共祖先
            if (left && right)
                return root;
            else if (!left && right) // 如果左为空，右不为空，说明还没有找到最近公共祖先，只找到了一棵子树的根
                return right;
            else if (left && !right) // 同上面的情况
                return left;

            return nullptr;
        }
    };
    ```

## 力扣235.二叉搜索树的最近公共祖先

[力扣235.二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

**问题描述：**

!!! quote

    给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

    百度百科中最近公共祖先的定义为：“对于有根树T的两个结点`p`、`q`，最近公共祖先表示为一个结点`x`，满足`x`是`p`、`q`的祖先且`x`的深度尽可能大（一个节点也可以是它自己的祖先）。”

    例如，给定如下二叉搜索树:  `root = [6,2,8,0,4,7,9,null,null,3,5]`

    <img src="2. 二叉树基础题目.assets\binarysearchtree_improved.png">

    示例 1:

    ```c++
    输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
    输出: 6 
    解释: 节点 2 和节点 8 的最近公共祖先是 6。
    ```

    示例 2:

    ```c++
    输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
    输出: 2
    解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
    ```

**思路分析：**

1. 解法1：针对任何二叉树
   
    第一种写法和上一题的写法2一模一样，因为二叉搜索树本质也是二叉树
    
2. 解法2：二叉搜索树
   
    第二种解法就略有不同，因为需要用到二叉搜索树的特性：左子树所有节点均小于根节点，右子树所有节点均大于根节点可以分出下面的三种情况：

      1. 当前节点大于`p`和`q`，说明最近公共祖先在左子树
      2. 当前节点小于`p`和`q`，说明最近公共祖先在右子树
      3. 当前节点介于`p`和`q`，说明当前节点就是最近公共祖先

    注意，不会出现「当前节点介于`p`和`q`，说明当前节点不是最近公共祖先」的情况，因为一旦当前节点介于`p`和`q`，则左子树一定小于当前节点，右子树一定大于当前节点，那么当前节点不论是向左遍历还是向右遍历都会出现错过一个节点的情况

**参考代码：**

=== "一般二叉树"

    ```c++
    class Solution235_1
    {
    public:
        TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
        {
            if (root == p || root == q || root == nullptr)
                return root;

            TreeNode *left = lowestCommonAncestor(root->left, p, q);
            TreeNode *right = lowestCommonAncestor(root->right, p, q);

            // 如果左孩子不为空，右孩子也不为空，说明当前函数栈帧的root的值就是最近公共祖先
            if (left && right)
                return root;
            else if (!left && right) // 如果左为空，右不为空，说明还没有找到最近公共祖先，只找到了一棵子树的根
                return right;
            else if (left && !right) // 同上面的情况
                return left;

            return nullptr;
        }
    };
    ```

=== "利用二叉搜索树特性"

    ```c++
    class Solution235_2
    {
    public:
        TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
        {
            if (!root)
                return root;

            // 如果当前节点的值在p值和q值之间，则说明一定是最进公共祖先，因为如果p和q不在同一个子树
            // 那么根据二叉搜索树定义就会出现：
            // 1. p和q都在当前节点左侧
            // 2. p和q都在当前节点右侧

            // 当前节点比p和q都大，走左子树继续找
            if (root->val > p->val && root->val > q->val)
            {
                TreeNode *left = lowestCommonAncestor(root->left, p, q);
                if (left)
                    return left;
            }

            // 当前节点比p和q都小，走右子树继续找
            if (root->val < p->val && root->val < q->val)
            {
                TreeNode *right = lowestCommonAncestor(root->right, p, q);
                if (right)
                    return right;
            }

            // 如果不满足上面三个if，说明当前节点就在p和q中间，即为最近公共祖先
            return root;
        }
    };
    ```

## 力扣701.二叉搜索树中的插入操作

[力扣701.二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)

**问题描述：**

!!! quote

    给定二叉搜索树（BST）的根节点`root`和要插入树中的值`value`，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据保证新值和原始二叉搜索树中的任意节点值都不同。

    注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。你可以返回任意有效的结果。

    示例 1：

    <img src="2. 二叉树基础题目.assets\insertbst.jpg">

    ```c++
    输入：root = [4,2,7,1,3], val = 5
    输出：[4,2,7,1,3,5]
    ```

    解释：另一个满足题目要求可以通过的树是：

    <img src="2. 二叉树基础题目.assets\bst.jpg">

    示例 2：

    ```c++
    输入：root = [40,20,60,10,30,50,70], val = 25
    输出：[40,20,60,10,30,50,70,null,null,25]
    ```

    示例 3：

    ```c++
    输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
    输出：[4,2,7,1,3,5]
    ```

**思路分析：**

二叉搜索树的插入相对容易，只需要根据二叉搜索树的性质遍历二叉树找到合适的插入位置插入节点即可

**参考代码：**

```c++
class Solution701
{
public:
    TreeNode *insertIntoBST(TreeNode *root, int val)
    {
        // 根节点为空，则当前节点作为根节点
        if (!root)
            return new TreeNode(val);

        TreeNode *cur = root;
        // 记录前一个节点
        TreeNode *prev = nullptr;
        while (cur)
        {
            // 当前节点的值小于val，走到右子树
            prev = cur;
            if (cur->val < val)
                cur = cur->right;
            else if (cur->val > val) // 当前节点的值小于val，走到左子树
                cur = cur->left;
        }

        if (val < prev->val)
            prev->left = new TreeNode(val);
        else if (val > prev->val)
            prev->right = new TreeNode(val);

        return root;
    }
};
```

## 力扣450.删除二叉搜索树中的节点

[力扣450.删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

**问题描述：**

!!! quote

    给定一个二叉搜索树的根节点`root`和一个值`key`，删除二叉搜索树中的`key`对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

    一般来说，删除节点可分为两个步骤：

    1. 首先找到需要删除的节点；
    2. 如果找到了，删除它。

    示例 1:

    <img src="2. 二叉树基础题目.assets\del_node_1.jpg">

    ```c++
    输入：root = [5,3,6,2,4,null,7], key = 3
    输出：[5,4,6,2,null,null,7]
    ```

    解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
    一个正确的答案是`[5,4,6,2,null,null,7]`，如上图所示。
    另一个正确答案是`[5,2,6,null,4,null,7]`，如下图所示。

    <img src="2. 二叉树基础题目.assets\del_node_supp.jpg">

    示例 2:

    ```c++
    输入: root = [5,3,6,2,4,null,7], key = 0
    输出: [5,3,6,2,4,null,7]
    解释: 二叉树不包含值为 0 的节点
    ```

    示例 3:

    ```c++
    输入: root = [], key = 0
    输出: []
    ```

**思路分析：**

见[数据结构：二叉搜索树篇](https://www.help-doc.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/10.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#_8)

**参考代码：**

```c++
class Solution450
{
public:
    // 判断查找的节点是否存在于BST中
    bool find(TreeNode *root, int key)
    {
        TreeNode *cur = root;
        while (cur)
        {
            // 当前节点偏大，走左子树
            if (cur->val > key)
                cur = cur->left;
            else if (cur->val < key) // 当前节点偏小，走右子树
                cur = cur->right;
            else
                return true; // 找到返回true
        }

        return false; // 循环走完说明没找到
    }
    TreeNode *deleteNode(TreeNode *root, int key)
    {
        // 根节点为空不执行或者不存在指定的key则返回空删除
        if (!root)
            return nullptr;

        if (!find(root, key))
            return root;

        // 先查找到指定节点
        TreeNode *cur = root;
        TreeNode *prev = prev;

        while (cur)
        {
            // 记录当前节点
            if (cur->val > key)
            {
                // 注意prev的位置要在if里面
                // 防止出现下一次cur为待删除的节点时，prev也变成了当前待删除的节点
                prev = cur;
                cur = cur->left;
            }
            else if (cur->val < key)
            {
                prev = cur;
                cur = cur->right;
            }
            else // 相等时执行删除
            {
                // 第一种和第二种情况
                // 如果当前节点的左孩子为空
                if (!cur->left)
                {
                    // 注意根节点为待删除的数值时需要单独考虑
                    if(cur == root)
                        root = cur->right;
                    else if (prev->left == cur) // 判断当前节点是其父亲节点的左孩子还是右孩子
                        prev->left = cur->right;
                    else if (prev->right == cur)
                        prev->right = cur->right;
                    delete cur;
                }
                else if (!cur->right)
                {
                    // 注意根节点为待删除的数值时需要单独考虑
                    if(cur == root)
                        root = cur->left;
                    else if (prev->left == cur)
                        prev->left = cur->left;
                    else if (prev->right == cur)
                        prev->right = cur->left;
                    delete cur;
                }
                else
                {
                    // 第三种情况
                    // 先找到待删除节点的右孩子的最左孩子
                    TreeNode *replaceNode = cur->right;
                    TreeNode *replaceNodePrev = cur;

                    while (replaceNode->left)
                    {
                        replaceNodePrev = replaceNode;
                        replaceNode = replaceNode->left;
                    }

                    // 将待删除节点的值替换为右孩子的最左孩子的值
                    cur->val = replaceNode->val;
                    if (replaceNode == replaceNodePrev->left)
                        replaceNodePrev->left = replaceNode->right;
                    else if (replaceNode == replaceNodePrev->right)
                        replaceNodePrev->right = replaceNode->right;

                    delete replaceNode;
                }
                break;
            }
        }

        return root;
    }
};
```

## 力扣669.修剪二叉搜索树

[力扣669.修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

**问题描述：**

!!! quote
    给你二叉搜索树的根节点`root`，同时给定最小边界`low`和最大边界`high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树不应该改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在唯一的答案。

    所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

    示例 1：

    <img src="2. 二叉树基础题目.assets\trim1.jpg">

    ```c++
    输入：root = [1,0,2], low = 1, high = 2
    输出：[1,null,2]
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\trim2.jpg">

    ```c++
    输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
    输出：[3,2,null,1]
    ```

**思路分析：**

本题不可以使用二叉树删除节点的逻辑，因为题目提到了不能修改二叉树的父子关系，而在二叉树删除节点的过程中会涉及到挪动节点，从而导致父子关系改变。本题的正确做法是：直接删除指定节点，如果当前节点不在要求的`[low, high]`中，就找到其对应的子树继续遍历：

1. 如果当前节点小于`low`，因为是二叉搜索树，所以其左子树的全部节点一定也小于`low`，此时只需要向右子树递归判断找到满足条件的子树返回
2. 如果当前节点大于`high`，因为是二叉搜索树，所以其左子树的全部节点一定也大于`high`，此时只需要向左子树递归判断找到满足条件的子树返回

**参考代码：**

```c++
class Solution669
{
public:
    TreeNode *trimBST(TreeNode *root, int low, int high)
    {
        // 如果节点为空，直接返回空
        if (!root)
            return nullptr;

        // 如果当前节点小于low，因为是二叉搜索树，所以其左子树的全部节点一定也小于low
        // 此时只需要向右子树递归判断找到满足条件的子树返回
        if (root->val < low)
            return trimBST(root->right, low, high); // 直接返回子树给当前节点的父亲节点相当于删除当前节点
        else if (root->val > high) // 否则向左遍历
            return trimBST(root->left, low, high);

        // 链接子树
        // 如果不满足上面的条件，说明当前节点在[low, high]之内，继续向下遍历
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);

        return root;
    }
};
```

## 力扣108.将有序数组转换为二叉搜索树

[力扣108.将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

**问题描述：**

!!! quote

    给你一个整数数组`nums`，其中元素已经按升序排列，请你将其转换为一棵平衡二叉搜索树。

    示例 1：

    <img src="2. 二叉树基础题目.assets\btree1.jpg">

    ```c++
    输入：nums = [-10,-3,0,5,9]
    输出：[0,-3,9,-10,null,5]
    ```

    解释：`[0,-10,5,null,-3,null,9]`也将被视为正确答案：

    <img src="2. 二叉树基础题目.assets\btree2.jpg">

    示例 2：

    <img src="2. 二叉树基础题目.assets\btree.jpg">

    ```c++
    输入：nums = [1,3]
    输出：[3,1]
    解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
    ```

**思路分析：**

本题不可以直接使用二叉搜索树的节点插入方法，因为这个方法没有考虑到平衡的情况从而导致二叉树变为单链表。因为本题的数组是升序排序的，所以默认情况下所有的节点也就是二叉搜索树的中序遍历结果

需要注意的是，本题已经提到了二叉搜索树最后的结构可以不同，所以可以直接取中间值作为根节点，这样就可以保证左右子树的高度最大不会超过1

**参考代码：**

```c++
class Solution108
{
public:
    TreeNode *sortedArrayToBST(vector<int> &nums)
    {
        if (nums.size() == 0)
            return nullptr;

        // 取出中间值作为根节点
        int mid = (nums.size() - 1) / 2;
        TreeNode *root = new TreeNode(nums[mid]);

        // 根据根节点位置构造左子树和右子树——左闭右开区间
        vector<int> left(nums.begin(), nums.begin() + mid);
        vector<int> right(nums.begin() + mid + 1, nums.end());

        root->left = sortedArrayToBST(left);
        root->right = sortedArrayToBST(right);

        return root;
    }
};
```

## 力扣538.把二叉搜索树转换为累加树

[力扣538.把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

**问题描述：**

!!! quote
    给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点`node`的新值等于原树中大于或等于`node.val`的值之和。

    提醒一下，二叉搜索树满足下列约束条件：

    - 节点的左子树仅包含键小于节点键的节点。
    - 节点的右子树仅包含键大于节点键的节点。
    - 左右子树也必须是二叉搜索树。

    注意：本题和[1038.从二叉搜索树到更大和树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/)相同

    示例 1：

    <img src="2. 二叉树基础题目.assets\tree.png">

    ```c++
    输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
    ```

    示例 2：

    ```c++
    输入：root = [0,null,1]
    输出：[1,null,1]
    ```

    示例 3：

    ```c++
    输入：root = [1,0,2]
    输出：[3,3,2]
    ```

    示例 4：

    ```c++
    输入：root = [3,2,4,1]
    输出：[7,9,4,10]
    ```

**思路分析：**

1. 解法1：中序遍历有序计算和+额外空间

    本题的基本思路是使用中序遍历将结果存放到数组中，再计算该数组的后缀和，将后缀和与原节点进行映射，最后使用对应节点的后缀和覆盖原树的节点即可

2. 解法2：双指针（遍历时累加）

    在解法1中，将二叉搜索树转换为数组的过程是为了更好得理解从后向前遍历，但是因为转换数组之后节点和元素之和不对应，所以还需要一个哈希表来记录元素和后缀和的映射，导致整个代码的思路虽然清晰，但是空间复杂度比较高。理解了解法1的过程，实际上就可以直接使用双指针在原树上进行修改，但是修改的过程应该是右中左，保证倒序。使用两个指针，其中一个指针表示前一个数值（即已经计算过后缀和的结果），另一个指针就是递归过程中的`root`，记录当前节点的值，在遍历过程中，当前节点加上前一个节点的数值即可

**参考代码：**

=== "中序遍历有序计算和+额外空间"

    ```c++
    class Solution538_2
    {
    public:
        // 使用变量记录前一个节点计算出的总和
        // 使用使用数值记录，防止空指针解引用错误以及额外空指针处理逻辑
        int prev = 0;

        TreeNode *convertBST(TreeNode *root)
        {
            // 节点为空，返回0
            if (!root)
                return 0;

            // 使用右中左遍历
            root->right = convertBST(root->right);
            root->val += prev;
            prev = root->val;
            root->left = convertBST(root->left);

            return root;
        }
    };
    ```

=== "双指针（遍历时累加）"

    ```c++
    class Solution538_2
    {
    public:
        // 使用变量记录前一个节点计算出的总和
        // 使用使用数值记录，防止空指针解引用错误以及额外空指针处理逻辑
        int prev = 0;

        TreeNode *convertBST(TreeNode *root)
        {
            // 节点为空，返回0
            if (!root)
                return 0;

            // 使用右中左遍历
            root->right = convertBST(root->right);
            root->val += prev;
            prev = root->val;
            root->left = convertBST(root->left);

            return root;
        }
    };
    ```

## 力扣606.根据二叉树创建字符串

[力扣606.根据二叉树创建字符串](https://leetcode.cn/problems/construct-string-from-binary-tree/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。

    空节点使用一对空括号对`()`表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

    示例 1：

    <img src="2. 二叉树基础题目.assets\cons1-tree.jpg">

    ```c++
    输入：root = [1,2,3,4]
    输出："1(2(4))(3)"
    解释：初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。
    ```

    示例 2：

    <img src="2. 二叉树基础题目.assets\cons2-tree.jpg">

    ```c++
    输入：root = [1,2,3,null,4]
    输出："1(2()(4))(3)"
    解释：和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。
    ```

**思路分析：**

本题基本思路如下：

1. 当前节点的左孩子和右孩子均不为空时，正常插入并正确闭合括号
2. 当前节点的左孩子不为空，右孩子为空时，正常插入并正确闭合括号
3. 当前节点的左孩子为空，但是右孩子不为空时，左孩子需要插入空括号对，再插入右节点

根据上面的思路可以写出第一种详细的写法，但是从上面的思路看出，其实只需要考虑最后一种情况，也就是左为空，但是右不为空时就需要额外添加左子树的括号，所以可以考虑先写出加上全部括号的逻辑再使用`if`划分情况，但是，第二种写法会在性能上有很大影响，因为每一次递归都会创建一个新的string对象，并且在每一次返回时都需要进行构造，导致额外的时间和空间的开销

**参考代码：**

=== "写法1"

    ```c++
    class Solution606_1
    {
    public:
        void _tree2str(TreeNode *root, string &ret)
        {
            ret += "(" + to_string(root->val);
            if (!root->left && root->right)
                ret += "()";

            if (root->left)
                _tree2str(root->left, ret);

            if (root->right)
                _tree2str(root->right, ret);

            // 左右子树都遍历完毕后右括号首尾
            ret += ")";
        }

        string tree2str(TreeNode *root)
        {
            if (!root)
                return "";

            string ret;
            // 单独处理根节点
            ret += to_string(root->val);

            if (root->left)
                _tree2str(root->left, ret);
            else if (!root->left && root->right)
                ret += "()";

            if (root->right)
                _tree2str(root->right, ret);

            return ret;
        }
    };
    ```

=== "写法2"

    ```c++
    class Solution606_2
    {
    public:
        string tree2str(TreeNode *root)
        {
            string ret;
            if (!root)
                return ret;

            // 插入节点值
            ret += to_string(root->val);

            // 左子树不为空，正常插入左子树和括号
            // 左子树为空，但右子树不为空，正常插入括号
            if (root->left || root->right)
            {
                ret += "(";
                if (root->left)
                    ret += tree2str(root->left);
                ret += ")";
            }

            // 右子树不为空时，正常插入右子树和括号
            if (root->right)
            {
                ret += "(";
                ret += tree2str(root->right);
                ret += ")";
            }

            return ret;
        }
    };
    ```

## 力扣LCR155.将二叉搜索树转化为排序的双向链表

[力扣LCR155.将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/)

**问题描述：**

!!! quote
    将一个二叉搜索树就地转化为一个已排序的双向循环链表 。

    对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

    特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

    示例 1：

    ```c++
    输入：root = [4,2,5,1,3] 
    ```

    <img src="2. 二叉树基础题目.assets\bstdllreturndll.png">

    ```c++
    输出：[1,2,3,4,5]
    ```

    解释：下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。

    <img src="2. 二叉树基础题目.assets\bstdllreturnbst.png">

    示例 2：

    ```c++
    输入：root = [2,1,3]
    输出：[1,2,3]
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    解释：输入是空树，所以输出也是空链表。
    ```

    示例 4：

    ```c++
    输入：root = [1]
    输出：[1]
    ```

**问题描述：**

1. 解法1：异地处理

    异地处理只需要将二叉搜索树进行中序遍历，再根据中序遍历的结果数组创建链表即可

2. 解法2：双指针（原地处理）

    需要一个节点单独`prev`记录之前的一个节点，中序遍历过程中，将当前节点的前驱指针指向`prev`，`prev`的后继指向当前节点即可完成链接，注意`prev`不为空的情况，处理完中间的所有节点后，需要额外处理第一个节点和最后一个节点链接

**参考代码：**

=== "异地处理"

    ```c++
    class SolutionLCR155_1
    {
    public:
        void traversal(Node *root, vector<Node *> &nodes)
        {
            if (!root)
                return;

            traversal(root->left, nodes);
            nodes.push_back(root);
            traversal(root->right, nodes);
        }

        Node *treeToDoublyList(Node *root)
        {
            if (!root)
                return nullptr;

            vector<Node *> nodes;
            traversal(root, nodes);

            // 构建链表
            Node *prev = nullptr;
            Node *dummy = new Node(0);
            for (auto &node: nodes)
            {
                if (!dummy->right)
                {
                    dummy->right = node;
                    if (nodes.size() == 1)
                    {
                        node->left = node;
                        node->right = node;
                        return node;
                    }
                }
                else
                {
                    dummy->right->left = node;
                    node->right = dummy->right;
                }

                if (prev)
                {
                    prev->right = node;
                    node->left = prev;
                }

                prev = node;
            }

            return dummy->right;
        }
    };
    ```

=== "双指针（原地处理）"

    ```c++
    class SolutionLCR155_2
    {
    public:
        Node *prev = nullptr;

        void _treeToDoublyList(Node *root)
        {
            if (!root)
                return;

            _treeToDoublyList(root->left);

            root->left = prev;
            if (prev)
                prev->right = root;
            prev = root;

            _treeToDoublyList(root->right);
        }

        Node *treeToDoublyList(Node *root)
        {
            if (!root)
                return nullptr;

            // 找到最左节点作为头节点
            Node *head = root;
            while (head->left)
            {
                head = head->left;
            }

            // 找到头结点后再修改
            // 也可以考虑在找到头结点之前修改
            // 此时就是通过链表向前遍历找到头结点head，而不是通过树的遍历
            _treeToDoublyList(root);

            // 头尾相连
            head->left = prev;
            prev->right = head;

            return head;
        }
    };
    ```