# 二叉树基础题目

## 本篇介绍

二叉树的题目大部分考察的都是如何正确使用二叉树的遍历，二叉树的遍历主要分为深度优先搜索和广度优先搜索，深度优先一般就是前中后序三个遍历方式，深度优先就是层序遍历，在下面的题目中，也主要考察这两种遍历方式

## 二叉树的深度优先搜索

### 力扣144.二叉树的前序遍历

[力扣144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，返回它节点值的前序遍历。

    示例 1：

    ```c++
    输入：root = [1,null,2,3]
    输出：[1,2,3]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\screenshot-2024-08-29-202743.png">

    示例 2：

    ```c++
    输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]
    输出：[1,2,4,5,6,7,3,8,9]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\tree_2.png">

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

    示例 4：

    ```c++
    输入：root = [1]
    输出：[1]
    ```

**思路分析：**

1. 解法1：递归
   
    二叉树的前序遍历在[数据结构：二叉树（基础）](#)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树前序遍历的迭代写法的主要思路就是用栈模拟递归的过程，因为前序遍历的顺序是：中左右，所以根节点是第一个被处理的节点，此时栈内的数据就是当前子树的根节点。如果栈不为空说明还没有走完整棵二叉树，否则每一次遍历时，先取出当前栈顶的元素，该元素就是当前子树的根节点，取出后弹出当前元素，接着走向右子树，注意不是左子树，因为栈是先进后出，而下一次是左子树先被去除，所以右子树先进才能保证左子树在栈顶

**参考代码：**

=== "递归"

    ```c++
    class Solution144_1
    {
    public:
        void _preorderTraversal(TreeNode *root, vector<int> &ret)
        {
            if (root == nullptr)
                return;

            // 处理节点
            ret.push_back(root->val);
            _preorderTraversal(root->left, ret);
            _preorderTraversal(root->right, ret);
        }

        vector<int> preorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _preorderTraversal(root, ret);
            return ret;
        }
    };
    ```

=== "迭代"

    ```c++
    class Solution144_2
    {
    public:
        vector<int> preorderTraversal(TreeNode *root)
        {
            // 用栈模拟
            stack<TreeNode *> st;
            // 先插入根节点
            st.push(root);
            vector<int> ret;

            while (!st.empty())
            {
                // 获取栈顶节点
                TreeNode *cur = st.top();
                st.pop();
                // 处理逻辑
                if (cur != nullptr)
                    ret.push_back(cur->val);
                else
                    continue;

                // 先插入右节点
                st.push(cur->right);
                // 再插入左节点
                st.push(cur->left);
            }

            return ret;
        }
    };
    ```

### 力扣94.二叉树的中序遍历

[力扣94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

**问题描述：**

!!! quote

    给定一个二叉树的根节点`root`，返回它的中序遍历。

    示例 1：

    <img src="2. 二叉树基础题目.assets\inorder_1.jpg">
    
    ```c++
    输入：root = [1,null,2,3]
    输出：[1,3,2]
    ```
    
    示例 2：

    ```c++
    输入：root = []
    输出：[]
    ```

    示例 3：

    ```
    输入：root = [1]
    输出：[1]
    ```c++

**思路分析：**

1. 解法1：递归

    二叉树的中序遍历在[数据结构：二叉树（基础）](#)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树中序遍历的迭代写法相对比较简单，先找到左子树，再取出当前节点，当取出左节点后，下一个节点一定是根节点，所以只需要将`root`更新为`nullptr`就可以防止重复走到原来的节点。考虑到如果左节点是叶子，那么此时`root->right`一定为`nullptr`，所以可以更新为`root = root->right`，如果存在右节点，则下一次又会走右侧子树重复前面的步骤。如果不存在右节点，则下一次取出的就是根节点

**参考代码：**

=== "递归"

    ```c++
    class Solution94_1
    {
    public:
        void _inorderTraversal(TreeNode *cur, vector<int> &ret)
        {
            if (cur == nullptr)
                return;

            _inorderTraversal(cur->left, ret);
            ret.push_back(cur->val);
            _inorderTraversal(cur->right, ret);
        }

        vector<int> inorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _inorderTraversal(root, ret);

            return ret;
        }
    };
    ```

=== "迭代"

    ```c++
    class Solution94_2
    {
    public:
        vector<int> inorderTraversal(TreeNode *root)
        {
            stack<TreeNode *> st;
            vector<int> ret;

            TreeNode *prev = nullptr;

            while (!st.empty() || root != nullptr)
            {
                // 先找到最左节点
                while (root)
                {
                    st.push(root);
                    root = root->left;
                }

                // 获取当前节点
                root = st.top();
                st.pop();
                ret.push_back(root->val);

                // 不论是否为空都要走右子树，一旦右为空，下一次就会取到当前子树的根节点
                root = root->right;
            }

            return ret;
        }
    };
    ```

### 力扣145.二叉树的后序遍历

[力扣145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

**问题描述：**

!!! quote

    给你一棵二叉树的根节点`root`，返回其节点值的后序遍历。

    示例 1：

    ```c++
    输入：root = [1,null,2,3]

    输出：[3,2,1]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\screenshot-2024-08-29-202743.png">

    示例 2：

    ```c++
    输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]

    输出：[4,6,7,5,2,9,8,3,1]
    ```

    解释：

    <img src="2. 二叉树基础题目.assets\tree_2.png">

    示例 3：

    ```c++
    输入：root = []

    输出：[]
    ```

    示例 4：

    ```c++
    输入：root = [1]

    输出：[1]
    ```
    
**思路分析：**

1. 解法1：递归

    二叉树的后序遍历在[数据结构：二叉树（基础）](#)部分已经提过基本的递归思路，本题最简单的思路也就是递归写法，此处不再赘述

2. 解法2：迭代

    二叉树后序遍历的迭代写法有两种，一种是变向的前序遍历，另外一种就是常规意义上的后序遍历

    对于变向的前序遍历，其实就是根据后序遍历的顺序「中右左」的前序遍历的反向「左右中」，所以只需要将前序遍历的「中左右」改为「中右左」，再反向结果集即可。但是注意，这个方法只是完成了遍历的结果，遍历的方法基本上是不太严谨的，或者说是异构的前序遍历（即利用了两次反转：先反转为中右左，再反转结果集）

    常规意义上的后序遍历就是按照「左右中」的顺序进行，基本思路和中序遍历很类似，先一直走左子树，直到找到最左节点，这个过程中也要记录遍历过的节点。接着获取到当前节点，与中序不同的是，此时需要判断是否存在右孩子，因为后序遍历处理中间节点的逻辑是在遍历完右子树之后，如果右子树存在，那么还需要继续遍历，即将右子树节点压栈，否则当前节点就是当前子树的最后一个节点

**关键步骤：**

后序遍历的常规迭代法需要注意，要使用到一个变量`prev`表示前一个节点，如果当前节点的右孩子等于`prev`，说明当前子树的右子树遍历完毕，当前及诶点就是当前子树的根节点，并且还需要在插入节点到结果集之后将`root`置为空，防止多次走向同一棵左子树

例如下面的例子中，`prev`当前指向的是7节点：

<img src="2. 二叉树基础题目.assets\Snipaste_2024-12-30_16-29-54.png">

下一次循环中，首先会从栈内取出元素，当前栈顶元素为5，所以当前节点就是5，如果没有判断5的右子树是否等于`prev`，那么就会出现再一次走到右子树将5再次插入到栈内并再次走向同一棵右子树的情况

**参考代码：**

=== "递归"

    ```c++
    class Solution145_1
    {
    public:
        void _postOrderTraversal(TreeNode *cur, vector<int> &ret)
        {
            if (cur == nullptr)
                return;

            // 访问左节点
            _postOrderTraversal(cur->left, ret);
            // 访问右节点
            _postOrderTraversal(cur->right, ret);
            // 处理当前节点
            ret.push_back(cur->val);
        }

        vector<int> postorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            _postOrderTraversal(root, ret);

            return ret;
        }
    };
    ```

=== "迭代（常规）"

    ```c++
    class Solution145_2_1
    {
    public:
        vector<int> postorderTraversal(TreeNode *root)
        {
            vector<int> ret;
            // 使用栈模拟
            stack<TreeNode *> st;
            // 根节点为空直接返回空
            if (root == nullptr)
                return ret;

            // 防止满二叉子树死循环
            TreeNode *prev = nullptr;
            while (!st.empty() || root != nullptr)
            {
                // 一直找到最左节点
                while (root)
                {
                    // 在循环中已经插入一次根节点
                    // 此时循环上的判断root!=nullptr可以防止两个相同的根节点同时插入栈中
                    st.push(root);
                    root = root->left;
                }

                // 获取到当前节点
                root = st.top();
                st.pop();

                // 如果当前节点不存在右子树
                // 或者已经获取过同一个右子树
                // 说明已经遍历完成，当前节点就是子树根节点
                if (root->right == nullptr || root->right == prev)
                {
                    ret.push_back(root->val);
                    prev = root;
                    // 将root置为空防止再一次获取最左节点
                    root = nullptr;
                }
                else
                {
                    // 存在右子树就还需要继续找
                    st.push(root); // 将弹出的根节点再插入到栈中
                    // 此时肯定不存在或者已经判断完左子树，所以直接走向右子树
                    root = root->right;
                }
            }

            return ret;
        }
    };
    ```

=== "迭代（非常规）"

    ```c++
    class Solution145_2_2
    {
    public:
        vector<int> postorderTraversal(TreeNode *root)
        {
            // 用栈模拟
            stack<TreeNode *> st;
            // 先插入根节点
            st.push(root);
            vector<int> ret;

            while (!st.empty())
            {
                // 获取栈顶节点
                TreeNode *cur = st.top();
                st.pop();
                // 处理逻辑
                if (cur != nullptr)
                    ret.push_back(cur->val);
                else
                    continue;

                // 中右左
                // 先插入左节点
                st.push(cur->left);
                // 再插入右节点
                st.push(cur->right);
            }

            reverse(ret.begin(), ret.end());

            return ret;
        }
    };
    ```

## 二叉树的广度优先搜索

### 力扣102.二叉树的层序遍历

[力扣102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

**问题描述：**

!!! quote

    给你二叉树的根节点`root`，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。

    示例 1：

    <img src="2. 二叉树基础题目.assets\tree1.jpg">

    ```c++
    输入：root = [3,9,20,null,null,15,7]
    输出：[[3],[9,20],[15,7]]
    ```

    示例 2：

    ```c++
    输入：root = [1]
    输出：[[1]]
    ```

    示例 3：

    ```c++
    输入：root = []
    输出：[]
    ```

**思路分析：**

二叉树的层序遍历就是利用队列，基本思路已经在[数据结构：二叉树（基础）](#)中提及，此处不再赘述，但是本题除了实现层序遍历二叉树外，还需要确定每一个节点所在的层，此时就需要使用到计数器，计数器由队列的大小进行初始化，起始是计数器为1，代表第一层只有一个节点，以此类推

**参考代码：**

```c++
class Solution102
{
public:
    vector<vector<int>> levelOrder(TreeNode *root)
    {
        // 记录当前层节点的个数
        int count = 0;
        vector<vector<int>> ret;

        queue<TreeNode *> que;

        que.push(root);
        while (!que.empty() && root != nullptr)
        {
            // 确定当前层节点的个数
            count = que.size();
            // 存储当前层的节点
            vector<int> temp;

            while (count--)
            {
                TreeNode *cur = que.front();
                que.pop();
                temp.push_back(cur->val);

                if (cur->left)
                    que.push(cur->left);
                if (cur->right)
                    que.push(cur->right);
            }

            ret.push_back(temp);
        }

        return ret;
    }
};
```