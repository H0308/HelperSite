# KMP算法

## 介绍

在计算机科学中，克努斯-莫里斯-普拉特字符串查找算法（英语：Knuth–Morris–Pratt algorithm，简称为KMP算法）可在一个字符串`S`内查找一个词`W`的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。

需要注意KMP算法的用途：其是在查找字符串时避免重新检查先前匹配成功的字符，本身并不是完全替代暴力解法的思路

## KMP算法优化原理

在暴力解法部分，基本思路就是模式串与文本串依次匹配，如果遇到不相同的字符时，回到文本串最开始匹配的位置的下一个位置再次进行文本串和模式串的匹配，但是在这个匹配过程中，当遇到不相同的字符时，其前面的字符一定是匹配成功的，所以可能存在部分的字符不需要再次进行比较，而是从某一个位置开始重新进行比较，在这种情况下就可以避免重新匹配先前匹配成功的字符

!!! info "模式串与文本串"

    模式串是待匹配的字符串，文本串是原始字符串，而整个过程中所做的事情就是在文本串中找匹配模式串的字符串的起始位置
    
    例如：
    
    文本串：`aabaabaafa`
    
    模式串：`aabaaf`
    
    则需要做的事情就是在`aabaabaafa`找到与`aabaaf`匹配的第一个字符的下标，在本例中就是3

而KMP算法之所以可以找到所谓的某一个位置就是利用了最长相等前后缀字符串的长度，在理解什么是最长相等前后缀字符串的长度之前，先介绍何为前缀字符串以及何为后缀字符串

## 前缀字符串与后缀字符串

前缀字符串：从第一个字符开始到指定位置结束的子字符串，如果是不包括尾字符的所有子字符串，则被称为真前缀

后缀字符串：从指定位置开始到最后一个字符结束的字符串，如果是不包括首字符的所有子字符串，则被称为真后缀

例如在示例`aabaaf`中，其前缀字符串和后缀字符串分别如下图所示：

<img src="KMP算法.assets/image-20241119203034087.png">

## 最长相等前后缀字符串的长度

对于一个字符串的每个前缀来说，最长相等前后缀是指该前缀字符串的前缀和后缀中最长的相等部分。例如，对于字符串`ababc`：

- 前缀`a`没有前缀也没有后缀，所以最长相等前后缀长度为0（没有相等的前后缀）
- 前缀`ab`的前缀为`a`，后缀为`b`，所以最长相等前后缀长度为0（没有相等的前后缀）
- 前缀`aba`的前缀为`a`，后缀为`a`时，最长相等前后缀长度为1（相等的前后缀是`a`）
- 前缀`abab`的前缀为`ab`，后缀为`ab`时，最长相等前后缀长度为2（相等的前后缀是`ab`）

## KMP算法优化过程

以下面的两个字符串为例：

文本串：`aabaabaafa`

模式串：`aabaaf`

匹配过程如下：

<img src="KMP算法.assets\匹配过程.gif">

从上面的示意图可以看出，当文本串中的字符和模式串的字符相同时，其比较方式与暴力方式一致，但是当遇到不一样的字符串时（后面称为冲突），暴力解法是让i回到开始时的下一个位置（即第二个`a`的下标位置），再从头进行匹配，但是KMP算法是让`j`跳到`b`所在位置继续向后进行匹配，并且`i`不回退

与暴力方式相同的部分不再解释，下面主要解释为什么KMP算法会跳到上面例子中`b`所在的位置

当遇到冲突时，说明前面的字符一定匹配成功，观察模式串中的子字符串`aabaa`，其有一个前缀字符串`aa`和后缀字符串`aa`，此时产生冲突的位置在后缀字符串的后面，则说明后缀字符串的两个`aa`已经完全匹配，因为该后缀字符串`aa`有一个相同的前缀字符串，所以该前缀一定也与产生冲突位置的前面的两个字符相同，此时前缀字符串后面一个字符的位置与产生冲突位置是对应的（都是相同子字符串的后一个位置），所以从这个字符开始匹配就可以做到避免一些重复的比较

而这个字符的下标位置实际上就是最长相等前后缀字符串的长度，但是并不只是这一次会利用到最长相等前后缀字符串的长度，在每一次产生冲突的时候都需要用到前缀表帮助回到指定的位置继续匹配，所以还需要一个数组存储以某个位置结尾的子字符串的最长相等前后缀字符串的长度，这个数组在KMP算法中也被称为前缀表

## 前缀表

前缀表就是一个长度与模式串相同的、保存着以当前位置为结尾的最长相等前后缀的长度的数组

前缀表的作用前面已经介绍了，下面介绍如何求出前缀表，这个也是KMP算法的精髓所在

在计算前缀表之前，一定要记住前缀表存储的数据表示的是「以当前位置为结尾的最长相等前后缀的长度」

求前缀表的思路一般分为4步：

1. 初始化相关变量
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况
4. 更新前缀表

例如对于字符串`s = aabaaf`来说，标记两个下标`prefix`从0开始，表示前缀字符串最后一个字符的位置，同时也表示最长相等前后缀的长度，`suffix`从1开始，表示后缀字符串最后一个字符的位置，则其前缀表中的内容计算方式如下：

!!! note

    1. 之所以让两个下标错开是为了产生比较，否则两个下标指向的字符始终是同一个字符从而导致每一个字符都是相等的
    2. 对于`prefix`和`suffix`之所以可以找出最长相等前后缀的长度，本质是因为`suffix`指向的是后缀字符串最后一个字符的位置，`prefix`指向的是前缀字符串最后一个字符的位置，如果两个指针走到了某一个位置，说明前面的字符已经进行了比较并且相等才能走到当前这一步，而因为`prefix`代表的是前缀字符串的最后一个位置，前缀字符串是从第一个字符开始计算的，所以其值（下标+1）也就是当前字符串的长度
    3. 注意`prefix`值填充的位置，第一次填充时，`prefix`值填充到第二个元素的位置，依次往后，因为如果只有一个字符构成子字符串时，其既没有前缀也没有后缀，所以最长相等前后缀长度为0，即`next[0] = 0`，第二个元素的位置也就是后缀字符串最后一个字符的位置，所以填充的位置为`next[suffix]`

- 前后缀相同的情况：`suffix = 1, prefix = 0`，当前`s[prefix] == s[suffix]`，所以存在最长相等前后缀，前缀为`a`，后缀为`a`，其长度为1；更新`prefix`为1；更新`next`数组第二个元素的值为1（注意不是更新`next`数组的第一个元素，因为对于第一个元素来说，其既没有前缀也没有后缀，所以最长相等前后缀长度为0）；向后移动`suffix`
- 前后缀不相同的情况：`suffix = 2, prefix = 1`，当前`s[prefix] != s[suffix]`，因为`prefix`和`suffix`分别代表的是前缀最后一个字符的位置和后缀最后一个字符的位置，所以当前字符不相同就说明遇到了不相等前缀字符串和后缀字符串，需要让`prefix`回退，即`prefix = next[prefix - 1]`（注意需要持续进行回退，因为不能保证回退一次之后的值与当前位置匹配）；如果`prefix-1`小于0时都无法匹配，此时说明没有相等的前缀和后缀，更新`next[suffix]`为0

## KMP算法求`next`数组代码

根据前面的代码，可以写出下面的求`next`数组的代码：

```C++
void getNext(vector<int> &next, string &needle)
{
    // 初始化相关变量
    int prefixEnd = 0;
    // 遍历
    // 后缀从1开始，形成比较
    for (int suffixEnd = 1; suffixEnd < needle.size(); suffixEnd++)
    {
        // 如果后缀字符和前缀字符不相等，说明遇到了不相等的子串
        // 此时prefixEnd就要向前移动找重新相同的位置
        // 如果字符串找到开始都没有找到说明此时没有最长相等前后缀
        while (prefixEnd - 1 >= 0 && needle[prefixEnd] != needle[suffixEnd])
        {
            prefixEnd = next[prefixEnd - 1];
        }

        // 如果二者相等，说明此时新增了最长相等前后缀
        // 更改最长相等前后缀的长度
        if (needle[prefixEnd] == needle[suffixEnd])
        {
            prefixEnd++;
        }

        // 更新当前next数组
        next[suffixEnd] = prefixEnd;
    }
}
```

## 力扣28.找出字符串中第一个匹配项的下标

[力扣28.找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

**问题描述：**

!!! quote
    给你两个字符串`haystack`和`needle`，请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从 0 开始）。如果`needle`不是`haystack`的一部分，则返回-1。

    示例 1：

    ```c++
    输入：haystack = "sadbutsad", needle = "sad"
    输出：0
    解释："sad" 在下标 0 和 6 处匹配。
    第一个匹配项的下标是 0 ，所以返回 0 。
    ```

    示例 2：

    ```c++
    输入：haystack = "leetcode", needle = "leeto"
    输出：-1
    解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
    ```

**思路分析：**

本题就可以利用到KMP算法优化暴力搜索

**参考代码：**

```c++
class Solution
{
public:
    void getNext(vector<int> &next, string &needle)
    {
        // 初始化相关变量
        int prefixEnd = 0;
        // 遍历
        // 后缀从1开始，形成比较
        for (int suffixEnd = 1; suffixEnd < needle.size(); suffixEnd++)
        {
            // 如果后缀字符和前缀字符不相等，说明遇到了不相等的子串
            // 此时prefixEnd就要向前移动找重新相同的位置
            // 如果字符串找到开始都没有找到说明此时没有最长相等前后缀
            while (prefixEnd - 1 >= 0 && needle[prefixEnd] != needle[suffixEnd])
            {
                // prefixEnd回到上一次的具有相等前后缀的位置
                prefixEnd = next[prefixEnd - 1];
            }

            // 如果二者相等，说明此时新增了最长相等前后缀
            // 更改最长相等前后缀的长度
            if (needle[prefixEnd] == needle[suffixEnd])
            {
                prefixEnd++;
            }

            // 更新当前next数组
            next[suffixEnd] = prefixEnd;
        }
    }

    int strStr(string haystack, string needle)
    {
        // 构建next数组
        vector<int> next(needle.size());
        // 填充next值
        getNext(next, needle);

        int j = 0;
        // 遍历文本串
        for (int i = 0; i < haystack.size(); i++)
        {
            // 如果出现不同，说明此时要找到最长相等前后缀的长度
            // 回退到长度对应的位置值重新比较
            while (j - 1 >= 0 && haystack[i] != needle[j])
            {
                j = next[j - 1];
            }

            // 如果相同，说明需要继续匹配
            if (haystack[i] == needle[j])
                j++;

            // 如果j此时走到了模式串的结尾，则i一定在下一个待匹配字符的位置
            // 此时要求的匹配的子串的起始位置，与当前的i构成的区间就是左闭右闭
            // 所以返回i - needle.size() + 1
            if (j == needle.size())
                return i - needle.size() + 1;
        }

        // 找不到返回-1
        return -1;
    }
};
```