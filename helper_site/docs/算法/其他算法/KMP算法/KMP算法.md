# KMP算法

## 介绍

在计算机科学中，克努斯-莫里斯-普拉特字符串查找算法（英语：Knuth–Morris–Pratt algorithm，简称为KMP算法）可在一个字符串`S`内查找一个词`W`的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。

需要注意KMP算法的用途：其是在查找字符串时避免重新检查先前匹配成功的字符，本身并不是完全替代暴力解法的思路

## KMP算法优化原理

在暴力解法部分，基本思路就是模式串与文本串依次匹配，如果遇到不相同的字符时，回到文本串最开始匹配的位置的下一个位置再次进行文本串和模式串的匹配，但是在这个匹配过程中，当遇到不相同的字符时，其前面的字符一定是匹配成功的，所以可能存在部分的字符不需要再次进行比较，而是从某一个位置开始重新进行比较，在这种情况下就可以避免重新匹配先前匹配成功的字符

!!! info "模式串与文本串"

    模式串是待匹配的字符串，文本串是原始字符串，而整个过程中所做的事情就是在文本串中找匹配模式串的字符串的起始位置
    
    例如：
    
    文本串：`aabaabaafa`
    
    模式串：`aabaaf`
    
    则需要做的事情就是在`aabaabaafa`找到与`aabaaf`匹配的第一个字符的下标，在本例中就是3

而KMP算法之所以可以找到所谓的某一个位置就是利用了最长相等前后缀字符串的长度，在理解什么是最长相等前后缀字符串的长度之前，先介绍何为前缀字符串以及何为后缀字符串

## 前缀字符串与后缀字符串

前缀字符串：从第一个字符开始到指定位置结束的子字符串，如果是不包括尾字符的所有子字符串，则被称为真前缀

后缀字符串：从指定位置开始到最后一个字符结束的字符串，如果是不包括首字符的所有子字符串，则被称为真后缀

例如在示例`aabaaf`中，其前缀字符串和后缀字符串分别如下图所示：

<img src="KMP算法.assets/image-20241119203034087.png">

## 最长相等前后缀字符串的长度

对于一个字符串的每个前缀来说，最长相等前后缀是指该前缀字符串的前缀和后缀中最长的相等部分。例如，对于字符串`ababc`：

- 前缀`a`没有前缀也没有后缀，所以最长相等前后缀长度为0（没有相等的前后缀）
- 前缀`ab`的前缀为`a`，后缀为`b`，所以最长相等前后缀长度为0（没有相等的前后缀）
- 前缀`aba`的前缀为`a`，后缀为`a`时，最长相等前后缀长度为1（相等的前后缀是`a`）
- 前缀`abab`的前缀为`ab`，后缀为`ab`时，最长相等前后缀长度为2（相等的前后缀是`ab`）

## KMP算法优化过程

以下面的两个字符串为例：

文本串：`aabaabaafa`

模式串：`aabaaf`

匹配过程如下：

<img src="KMP算法.assets\匹配过程.gif">

从上面的示意图可以看出，当文本串中的字符和模式串的字符相同时，其比较方式与暴力方式一致，但是当遇到不一样的字符串时（后面称为冲突），暴力解法是让i回到开始时的下一个位置（即第二个`a`的下标位置），再从头进行匹配，但是KMP算法是让`j`跳到`b`所在位置继续向后进行匹配，并且`i`不回退

与暴力方式相同的部分不再解释，下面主要解释为什么KMP算法会跳到上面例子中`b`所在的位置

首先，当遇到冲突时，说明前面的字符一定匹配成功，而在这些字符中，如果找到一个子字符串可以满足其与模式串中的第一个字符开始的子字符串相同，例如在上面示例中的`aab`和模式串中的`aab`中的`aa`，则此时就可以让`i`回到模式串中的这个子字符串的起始位置，但是如果回退`i`，则其时间复杂度和暴力就没有区别，所以还需要利用到前缀字符串和后缀字符串相等这一关键点

观察模式串中的子字符串`aabaa`，其有一个前缀字符串`aa`和后缀字符串`aa`，而此时产生冲突的位置在后缀字符串的后面，则说明前面的两个`aa`已经完全匹配，因为该后缀字符串`aa`有一个相同的前缀字符串，所以该前缀一定也与产生冲突位置的前面的两个字符相同，可以直接让`j`移动到前缀字符串的下一个位置再继续比较