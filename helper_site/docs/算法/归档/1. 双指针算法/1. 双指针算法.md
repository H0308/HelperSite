# 双指针算法

## 双指针算法介绍

双指针算法常见于数组和双向链表的题型

在数组中，双指针中的指针代表数组元素的下标，而不是真正的指针类型变量

在双向链表中，双指针中的指针即为真正意义上的指针，该指针一般是双向链表节点类型的指针

常见的双指针有两种形式：

1. 对撞指针：从结构的两端开始向中间移动，一般存在两种情况
    1. `left == right`：代表两个指针指向的时同一个位置
    2. `left > right`：代表连个指针已经相遇过一次，相遇的下一次形成交错
2. 快慢指针：所谓快慢指针即为一个指针走得快，一个指针走得慢
    1. 快慢指针一般的思路是：慢指针走一步，快指针走两步

## 双指针算法练习

### 目录

1. 移动零：[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)
2. 复写零：[1089. 复写零 - 力扣（LeetCode）](https://leetcode.cn/problems/duplicate-zeros/)
3. 快乐数：[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)
4. 盛最多水的容器：[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/)
5. 有效三角形个数：[611. 有效三角形的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-triangle-number/description/)
6. 查找总价格为目标值的两个商品：[LCR 179. 查找总价格为目标值的两个商品 - 力扣（LeetCode）](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)
7. 三数之和：[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)
8. 较小的三数之和：[259. 较小的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-smaller/)
9. 四数之和：[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

### 数组篇

#### 移动零

题目链接：[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)

!!! quote
    给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

    **请注意** ，必须在不复制数组的情况下原地对数组进行操作。

思路解析：

本题可以采用双指针算法进行解决，定义一个指针`cur`和`dest`，通过这两个指针构建出三个区间，分别是：

1. [0, `dest`] 代表已处理区间中的非0部分
2. [`dest`+1, `cur`-1] 代表已处理的区间中的0
3. [`cur`, `nums.size()`-1] 代表未处理的区间

当每一次的遍历移动数据后形成的区间满足上面三个区间的内容，则代表最后结果正确，如图所示：

<img src="1. 双指针算法.assets\image.png">

此时的区间[0, `dest`]为不存在的区间，所以不存在非0部分，而[`dest`+1, `cur`-1]也为不存在区间，[`cur`, `nums.size()`-1]区间中有一个未处理数据0

操作的基本思路为：

1. 当遇到0时：`dest`不动，`cur`向前走一步
2. 当遇到非0时：`dest`向前走一步，交换`dest`的数据和`cur`的数据
3. 交换完毕后：`cur`向前走一步

<img src="1. 双指针算法.assets\image1.png">

在上面的区间中[0, `dest`]区间中有一个数字1，[`dest`+1, `cur` - 1]区间中存在一个数字0，[`cur`, `nums.size()`-1]区间中均为未处理的数据

<img src="1. 双指针算法.assets\image2.png">

在上面的区间中[0, `dest`]区间中有数字1和3，[`dest`+1, `cur` - 1]区间中存在两个数字0，[`cur`, `nums.size()`-1]区间中均为未处理的数据

<img src="1. 双指针算法.assets\image3.png">

在上面的区间中[0, `dest`]区间中有数字1、3和12，[`dest`+1, `cur` - 1]区间中存在连个数字0，[`cur`, `nums.size()`-1]区间不存在，此时数组已经遍历交换完成，所有的数字零移到了数组的末尾，并且没有改变数组非0元素的相对位置

参考代码：

=== "版本1：标准写法"
    ```C++
    class Solution
    {
    public:
        void moveZeroes(vector<int> &nums)
        {
            // 记录已处理的区间中最后一个非零元素的位置
            int dest = -1;
            // 遍历数组
            int cur = 0;
            while (cur < nums.size())
            {
                // 遇到0不交换
                if (nums[cur] == 0)
                {
                    cur++;
                }
                else
                {
                    // 遇到非0元素交换dest下一个位置的数据和cur位置的数据
                    swap(nums[++dest], nums[cur++]);
                }
            }
        }
    };
    ```

=== "版本2：版本1简化版本"

    ```c++
    class Solution
    {
    public:
        void moveZeroes(vector<int> &nums)
        {
            for (int cur = 0, dest = -1; cur < nums.size(); cur++)
            {
                if (nums[cur])
                {
                    swap(nums[++dest], nums[cur]);
                }
            }
        }
    };
    ```

=== "版本3：起点均在0号元素"

    ```c++
    class Solution {
    public:
        void moveZeroes(vector<int>& nums) {
            int prev = 0, cur = 0;
            while(cur < nums.size())
            {
                if(nums[cur])
                    swap(nums[cur++], nums[prev++]);
                else
                    cur++;
            }
        }
    };
    ```

=== "版本4：Java版本"
    ```java
    class Solution {
        public void moveZeroes(int[] nums) {
            int prev = 0, cur = 0;
            while (cur < nums.length) {
                if (nums[cur] != 0) {
                    int temp = nums[cur];
                    nums[cur] = nums[prev];
                    nums[prev] = temp;
                    prev++;
                }
                cur++;
            }
        }
    }
    ```

#### 复写零

题目链接：[1089. 复写零 - 力扣（LeetCode）](https://leetcode.cn/problems/duplicate-zeros/)

!!! quote
    给你一个长度固定的整数数组 `arr` ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

    注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 **就地** 进行上述修改，不要从函数返回任何东西。

思路解析：

本题有两种思路：

1. 暴力复写
2. 双指针原地复写

下面针对两种方式依次引出最优解：

- 暴力复写

    暴力的方法很简单，因为是复写，所以只需要遇到0先将0位置后面的数据进行挪动覆盖，但是注意要从尾部开始挪动，挪动完毕后在当前位置的下一个位置插入一个数字0，让指针走两步

    暴力复写参考代码：

    ```c++
    class Solution
    {
    public:
        void duplicateZeros(vector<int> &arr)
        {
            for (int i = 0; i < arr.size(); i++)
            {
                if (arr[i] == 0 && arr.size() - 2 > 0)
                {
                    int j = arr.size() - 2;
                    while (j + 1 < arr.size() && j > i)
                    {
                        arr[j + 1] = arr[j];
                        j--;
                    }
                    if (i + 1 < arr.size())
                    {
                        arr[++i] = 0;
                    }
                }
            }
        }
    };
    ```

- 双指针原地复写

    对于双指针算法来说，有两种实现方式，第一种是异地复写，即开辟一个新空间，基本思路为遇到非0数字复写一次，遇到数字0复写两次，但是这个算法的空间复杂度为O(N)，所以考虑原地复写

    双指针——异地复写参考代码：

    ```c++
    class Solution
    {
    public:
        void duplicateZeros(vector<int> &arr)
        {
            vector<int> ret;
            ret.resize(arr.size());
            int cur = 0;
            int dest = 0;
            while (dest < ret.size())
            {
                if (arr[cur] == 0)
                {
                    dest++;
                    dest++;
                    cur++;
                }
                else
                {
                    ret[dest++] = arr[cur++];
                }
            }
            arr.assign(ret.begin(), ret.end());
        }
    };
    ```

    原地复写和异地复写的思路是一致的，但是原地复写不可以从源数组的第一个元素开始复写，这样会导致遇到数字0时后面的内容全部都覆盖为0，正确的做法是从最后一个待复写元素开始向最后一个位置进行复写，再依次往前遍历执行复写操作，复写具体操作为：

    1. 遇到非0数字向dest位置覆写当前cur位置的数字
    2. 遇到0数字向dest位置和dest-1位置复写两个0
    3. cur向前移动1步

    现在的问题就是如何找到最后一个待复写的元素，可以考虑一次正向遍历，但是在这一次遍历中不进行任何的复写操作，具体操作为：

    1. `cur`所在位置是非0的数字：`dest`移动一步
    2. `cur`所在位置是数字0：`dest`移动两步
    3. 判断`dest`是否到最后一个元素的位置
    4. `cur`移动一步

    !!! note

        注意，`dest`初始位置在-1，而不是0，因为`dest`需要指向的位置是最后一个元素的位置而不是最后一个元素的下一个位置

    遍历完成后`cur`所指向的位置即为最后一个待复写的元素，而`dest`所指向的位置即为最后一个元素的位置，如图所示：

    <img src="1. 双指针算法.assets/image4.png">

    但是此时需要注意一种特殊情况：

    <img src="1. 双指针算法.assets/image5.png" alt="image5" />

    当指向的待复写元素是0时，那么此时`dest`指向的位置已经超出了数组的范围，如果此时在`dest`位置复写时就会出现越界访问的情况，那么此时需要进行边界修正，修正方法如下：

    5. 在`dest-1`的位置处覆写数字0
    6. `cur`向前走动一步
    7. `dest`向前走动两步

    处理完边界情况后就可以进行正常的复写操作过程

    双指针——原地复写参考代码：

    ```c++
    class Solution
    {
    public:
        void duplicateZeros(vector<int> &arr)
        {
            int cur = 0, dest = -1;
            int sz = arr.size();
            // 找到结果数组中的最后一个重写的元素的位置
            while (cur < sz)
            {
                if (arr[cur] == 0)
                {
                    dest += 2;
                }
                else
                {
                    dest++;
                }

                if (dest >= sz - 1)
                {
                    break;
                }
                cur++;
            }

            // 修正边界情况
            if (dest == sz)
            {
                arr[dest - 1] = 0;
                cur--;
                dest -= 2;
            }

            // 覆写
            while (cur >= 0)
            {
                if (arr[cur])
                {
                    arr[dest--] = arr[cur--];
                }
                else
                {
                    arr[dest--] = 0;
                    arr[dest--] = 0;
                    cur--;
                }
            }
        }
    };
    ```

#### 快乐数

题目链接：[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)

!!! quote
    编写一个算法来判断一个数 `n` 是不是快乐数。
    
    **「快乐数」** 定义为：
    1. 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
    2. 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
    3. 如果这个过程 **结果为** 1，那么这个数就是快乐数。

    如果 `n` 是 **快乐数** 就返回 `true` ；不是，则返回 `false` 。

思路解析：

本题根据所给条件可以推出两种情况：

1. 结果为1
2. 结果不为1成环

<img src="1. 双指针算法.assets/image6.png" alt="image6" />

如果将结果为1的看作为环，那么可以将上面两种情况归纳为一种情况：最后的计算结果一定会在环中，如果结果为1，那么环中的所有数值均为1，如果结果不为1，那么环中即为其他数值，如图所示：

<img src="1. 双指针算法.assets/image7.png" alt="image7" />

通过将题目中对上面的结果进行抽象后，可以发现结果一定会成环，联系到题目：[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)可以考虑使用双指针算法中的快慢指针解决本题目，具体思路如下：

1. 定义一个慢指针`slow`和一个快指针`fast`
2. `slow`指针走一步，`fast`指针走两步
3. 因为整个过程一定会成环，所以`fast`和`slow`指针一定会在环中的某一个位置相遇，判断相遇位置的数值是否为1

!!! note
    本题提问：除了结果为1的另一种结果就是死循环，思考是否存在一种可能结果不是成环导致的死循环，而是无限增大导致的死循环

参考代码：

```c++
class Solution
{
public:
    int sum_digit(int num)
    {
        int sum = 0;
        while (num)
        {
            int temp = num % 10;
            sum += temp * temp;
            num /= 10;
        }
        return sum;
    }
    bool isHappy(int n)
    {
        int slow = n;
        int fast = sum_digit(n);
        while (slow != fast)
        {
            slow = sum_digit(slow);
            fast = sum_digit(sum_digit(fast));
        }

        return fast == 1;
    }
};
```

思考题目解析：

本题中并不会出现因为数值无限增大而导致死循环，即一定会成环，可以使用[鸽巢原理](https://www.helper-wiki.top/%E7%AE%97%E6%B3%95/1.%20%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%AF%87/7.%20%E4%BD%8D%E8%BF%90%E7%AE%97/7.%20%E4%BD%8D%E8%BF%90%E7%AE%97.html?h=%E9%B8%BD%E5%B7%A2#0101)进行分析：

题目中给到的提示数字范围为INT_MAX（32位系统下），假设现在一个有一个远大于INT_MAX的数值，例如9999999999(10个9)，此时该数值的和为$9^2\times 10$，即810，那么说明在计算快乐数时，所有的给定数值因为是小于等于INT_MAX，所以最后的结果都会出现在[1, 810]这个范围中（810个鸽子巢）。既然如此，根据鸽巢原理，假设数字变化的次数为811（811个鸽子），因为范围固定，那么最后一个数值肯定会再一次出现在[1, 810]这个范围中，此时就会出现结果循环，所以一定会出现至少一个数值是重复出现导致成环，所以不存在因为数值无限增大而导致死循环

#### 盛最多水的容器

题目链接：[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/)

!!! quote
    给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

    找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

    返回容器可以储存的最大水量。

    **说明：**你不能倾斜容器。

    <img src="1. 双指针算法.assets/image8.png" alt="image8" />

思路分析：

首先分析题目要求，本题基本意思是取出一个容器的两边高，根据两边高之间的距离作为容器的宽度，因为需要确保放入的水不会漏出容器并且不能倾斜容器（即往高的地方倾斜确保超过短高的部分流向长高），所以v = min{左侧高，右侧高} * distance(左侧高，右侧高)

本题最直观的解法就是暴力枚举，通过外层for循环枚举其中一条高，再固定内层for循环枚举另一条高，求出体积的最大值即可，但是直接使用暴力枚举的时间复杂度为$O(N^2)$会出现超时

第二种方法：双指针算法

使用双指针的原因：

根据体积的计算公式v = height * width以及单调递减性可以得出两种使得v减小的情况：

1. 当height固定时，width减小，则v就会减小
2. 当height减小时，width减小，则v就会减小

以区间`[ 6,2,5,4 ]`为例

<img src="1. 双指针算法.assets/image9.png" alt="image9" />

根据上面的规律可以得出，因为遍历数组的过程中一定会出现width在减小的情况，为了使最后的v不变或者变大，只有改变height，如果出现一侧高度比另一侧高度小时，为了使height增大，需要移动小的一侧高度从而找到更高的高度，此时可以考虑使用双指针算法，左指针`left`代表左侧高度，右侧`right`代表右侧高度，当width（`left`与`right`的距离）不断减小时，通过两个指针控制高度height的取值，直到找到最大的体积。

因为两个指针从两侧向中间移动确定高度，所以时间复杂度为O(N)

参考代码：

```c++
// 双指针解法
class Solution
{
public:
    int maxArea(vector<int> &height)
    {
        int maxV = 0;
        int left = 0;
        int right = height.size() - 1;
        // 不需要等于的情况，因为等于时left和right间的差值为0，体积为0
        while (left < right)
        {
            // 求出体积
            int v = min(height[left], height[right]) * (right - left);
            // 取出当前体积和上一次体积中的最大值
            maxV = max(maxV, v);
            // 更新left和right
            if (height[left] > height[right])
            {
                right--;
            }
            else
            {
                left++;
            }
        }

        return maxV;
    }
};
```

#### 有效三角形个数

题目链接：[611. 有效三角形的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-triangle-number/description/)

!!! quote
    给定一个包含非负整数的数组 `nums` ，返回其中可以组成三角形三条边的三元组个数。

思路解析：

本题最直观的解法就是通过三层`for`循环一次枚举出所有有效的三角形组合，但是此时的时间复杂度为$O(N^3)$，另外在判断是否能构成三角形时使用的三次判断，那么时间复杂度准确来说是$O(3N^3)$，如果此时对原数组进行排序，那么时间复杂度可以变为$O(Nlog_{2}{N}+N^3)$

之所以对数组排序后可以减小时间复杂度是因为下面的原因：

在判断三个整数是否可以构成三角形时，假设三边分别为a、b和c，此时需要判断任意两边之和是否大于第三边，即`a + b > c && a +c > b && b + c > a`。如果此时确定一个最大的数值，假设此处c最大，那么只需要判断`a + b > c`，对于其余两种情况来说，因为c已经大于b和a，那么c + b或者c + a均会大于其余两边。对于排序之后的数组来说可以很容易确定最大值的位置，将最大值作为第三边后就只需要判断其余两边之和是否大于这个最大值即可

因为数组已经进行了排序，此时可以采用二分算法进行求解，但是使用双指针的算法会更优

双指针思路：

因为数组已经排序，所以除去作为第三边的最大值，接着还有第二大的数值，将其作为right指针位置为第二条边，将left指针作为第一条边，如图所示：

<img src="1. 双指针算法.assets/image10.png" alt="image10" />

1. 如果`left位置的数值＋right位置的数值>c`，则说明可以构成三角形，而因为数组有序，所以`left`和`right`中间的数值均会出现`left+right>c`，所以直接计算个数即可，计算完个数后，因为`right`位置的情况已经枚举完，使`right--`即可
2. 如果`left+right<=c`，此时说明不可以构成三角形，但是不是更新最大值，因为如果更新最大值，那么此时全部要重新判断并且可能会漏算当前`right`作为第二条边的情况，所以需要更新`left`，因为`left`后面的数值比当前`left`位置的数值大，所以可能存在有效的三元组
3. 当`left`和`right`相遇时，说明最大值为9时的所有情况均被计算，注意left不可以等于right，此时根据题目描述并不算做三元组
4. 更新第三边，重复上面三步操作计算所有结果

<img src="1. 双指针算法.assets/image11.png" alt="image11" />

参考代码：

```c++
/*
 * @lc app=leetcode.cn id=611 lang=cpp
 *
 * [611] 有效三角形的个数
 */

// @lc code=start
// 双指针
class Solution
{
public:
    int triangleNumber(vector<int> &nums)
    {
        int ret = 0;
        sort(nums.begin(), nums.end());
        int sz = nums.size();
        for (int i = 0; i < sz; i++)
        {
            int left = 0;
            int right = sz - 2 - i;
            int max = nums[right + 1];
            while (left < right)
            {
                if (nums[left] + nums[right] > max)
                {
                    ret += right - left;
                    right--;
                }
                else
                {
                    left++;
                }
            }
        }

        return ret;
    }
};
// @lc code=end
```

也可以写成：

```c++
/*
 * @lc app=leetcode.cn id=611 lang=cpp
 *
 * [611] 有效三角形的个数
 */

// @lc code=start
// 双指针
class Solution
{
public:
    int triangleNumber(vector<int> &nums)
    {
        int ret = 0;
        sort(nums.begin(), nums.end());
        int sz = nums.size();
        // 因为构成三元组至少需要三个不同位置的数值，所以i要至少大于等于2，确保有三个不同位置的数值
        for (int i = sz - 1; i >= 2; i--)
        {
            int left = 0;
            int right = i - 1;
            while (left < right)
            {
                if (nums[left] + nums[right] > nums[i])
                    ret += right - left, right--; // 不写大括号时，需要使用逗号对两条语句进行分割
                else
                    left++;
            }
        }

        return ret;
    }
};
// @lc code=end
```

#### 查找总价格为目标值的两个商品

题目链接：[LCR 179. 查找总价格为目标值的两个商品 - 力扣（LeetCode）](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)

!!! quote
    购物车内的商品价格按照升序记录于数组 `price`。请在购物车中找到两个商品的价格总和刚好是 `target`。若存在多种情况，返回任一结果即可。

思路解析：

本题直观解法是暴力枚举，使用两层`for`循环计算所有和与`target`进行比较，相等时返回两个加数即可，但是这种方法会超时，所以考虑其他方法。

因为本题题干已经说明数组是升序，所以数组满足单调性，考虑使用双指针算法，两数加和与另外一个数值比较只会有下面的三种情况：

1. `sum < target`
2. `sum > target`
3. `sum == target`

数组有序后，定义一个`left`指针从左向右遍历，一个`right`指针从右向左遍历，第一种情况如果`left`位置的值+`right`位置的值小于`target`，说明此时`left`过小，因为`left`后面的数值比当前`left`的数值大，所以可能存在`left+right == target`；第二种情况，如果`left`位置的值+`right`位置的值小于`target`，说明此时`right`过大，因为`right`前面的数值比当前`right`的数值小，所以可能存在`left+right == target`；当找到`left + right == target`时，直接返回即可

参考代码：

```c++
/*
 * @lc app=leetcode.cn lang=cpp
 *
 * LCR 179 查找总价值为目标值的两个商品
 */

// @lc code=start
// 双指针
class Solution
{
public:
    vector<int> twoSum(vector<int> &price, int target)
    {
        int left = 0;
        int right = price.size() - 1;
        vector<int> ret;
        while (left <= right)
        {
            if (price[left] + price[right] > target)
            {
                right--;
            }
            else if (price[left] + price[right] < target)
            {
                left++;
            }
            else
            {
                ret.push_back(price[left]);
                ret.push_back(price[right]);
                break;
            }
        }

        return ret;
    }
};
// @lc code=end
```

也可以写成：

```c++
/*
 * @lc app=leetcode.cn lang=cpp
 *
 * LCR 179 查找总价值为目标值的两个商品
 */

// @lc code=start
class Solution
{
public:
    vector<int> twoSum(vector<int> &price, int target)
    {
        int left = 0, right = price.size() - 1;
        while (left < right)
        {
            int sum = price[left] + price[right];
            if (sum < target)
                left++; // 第一种情况
            else if (sum > target)
                right--; // 第二种情况
            else
                return {price[left], price[right]}; // 第三种情况
        }
        // 函数必须要有返回值
        return {};
    }
};
// @lc code=end
```

#### 三数之和

题目链接：[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

!!! quote
    给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。

    请你返回所有和为 `0` 且不重复的三元组。

    **注意：**答案中不可以包含重复的三元组。

思路解析：

本题如果直接使用暴力解法，那么可以考虑思路：排序+暴力枚举+使用`set`进行去重，但是这个思路的时间复杂度为O($N^3$)导致代码超时。在暴力的基础上可以考虑使用双指针算法对暴力枚举和`set`去重进行优化，思路如下：

!!! note
    之所以需要在开始处写排序是为了后面方便去重操作，如果数组无序，那么可能同样的数值会出现前当前位置的后面，从而增加去重的难度

因为双指针可以取出连个数值，所以需要一层循环用于固定第三个数作为基数，假设为`target`，而两个指针计算的和为`sum`，因为三个数计算的结果为0，所以有`nums[i]+nums[j]+nums[k] = 0`，将`nums[i]`移动到等式的右侧后变为`nums[j]+nums[k] = -nums[i]`，所以可以考虑定义一个`left`指针代表`nums[j]`的位置，一个`right`指针代表`nums[k]`的位置，定义一个`target = -nums[i]`，接下来就是判断`nums[left] + nums[right]`是否等于`target`。而因为数组已经经过了排序，所以可以参考[LCR 179. 查找总价格为目标值的两个商品 - 力扣（LeetCode）](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)中的思路：

1. 如果`left`位置的值+`right`位置的值小于`target`，说明此时`left`过小，因为`left`后面的数值比当前`left`的数值大，所以可能存在`left+right == target`
2. 如果`left`位置的值+`right`位置的值小于`target`，说明此时`right`过大，因为`right`前面的数值比当前`right`的数值小，所以可能存在`left+right == target`

但是本题并不是直接返回找到的组合，因为有存在多种组合的情况，所以需要额外进行下面的步骤：

1. 找出所有的有效组合：因为存在多种组合，所以在`left`和`right`相遇之前都可能存在有效组合，将`left`和`right`相遇作为循环结束的条件而不是直接跳出循环
2. 去除重复的组合：
    1. 对于`left`和`right`中遇到重复的情况，因为当前数组已经有序，所以相同的组合中的相同数值也会在数组中连续出现，如果左右指针均指向相同的数值，说明此时遇到了相同的组合，可以考虑当遇到和上一次数据相同时一直更新`left`和`right`直到二者各自遇到不同的数字再重复前面的步骤
    2. 对于基数出现重复的情况，如果当前作为基数的数字和上一次作为基数的数字相同时，那么更新生成基数的下标`i`，直到当前基数与上一次基数不同为止。此处需要注意，如果下标`i`是`for`循环中存在的循环下标更新的表达式，那么会出现两次下标`i`更新，所以需要去掉`for`循环中的下标更新表达式

参考代码：

```C++
/*
 * @lc app=leetcode.cn id=15 lang=cpp
 *
 * [15] 三数之和
 */

// @lc code=start
class Solution
{
public:
    vector<vector<int>> threeSum(vector<int> &nums)
    {
        vector<vector<int>> ret;

        // 排序
        sort(nums.begin(), nums.end());

        int sz = nums.size();
        for (int i = 0; i < sz;)
        {
            // 如果当前数值为正数，则不可能出现三数之和为0的情况
            if (nums[i] > 0)
            {
                break;
            }
            // 固定基数
            int target = -nums[i];
            // 定义双指针，确定区间
            int left = i + 1, right = sz - 1;
            while (left < right)
            {
                int sum = nums[left] + nums[right];
                // 两数求和思路
                if (sum > target)
                {
                    right--;
                }
                else if (sum < target)
                {
                    left++;
                }
                else
                {
                    // 找到数值后存储
                    ret.push_back({nums[i], nums[left], nums[right]});
                    // 更新到新加数
                    left++;
                    right--;
                    // 对left和right区间中去重，注意越界问题的处理
                    while (left < right && nums[left] == nums[left - 1])
                    {
                        left++;
                    }
                    while (right > left && nums[right] == nums[right + 1])
                    {
                        right--;
                    }
                }
            }
            // 更新i下标到新的基数位置，此处需要注意for循环中不可以再出现i++
            i++;
            // 对基数去重，注意越界问题的处理
            while (i < sz && nums[i] == nums[i - 1])
            {
                i++;
            }
        }
        return ret;
    }
};
// @lc code=end
```

#### 较小的三数之和

!!! note
    本题是VIP题目，只需要了解思路即可

题目链接：[259. 较小的三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum-smaller/)

!!! quote
    给定一个长度为 `n` 的整数数组和一个目标值 `target` ，寻找能够使条件 `nums[i] + nums[j] + nums[k] < target` 成立的三元组  `i, j, k` 个数（`0 <= i < j < k < n`）。

    **示例 1：**

    输入: `nums = [-2,0,1,3]`, `target = 2`

    输出: 2 

    解释: 因为一共有两个三元组满足累加和小于 2: `[-2,0,1]`
     `[-2,0,3]`

    **示例 2：**

    输入: `nums = []`, `target = 0`

    输出: 0 

    **示例 3：**

    输入: `nums = []`, `target = 0`

    输出: 0 

思路解析：

本题结合单调性以及两数之和的思路，先对数组进行排序使数组单调递增，因为题目需要找到`nums[i]+nums[j]+nums[k] < target`，化简为`nums[j]+nums[k] < target - nums[i]`，此时可以取出一个数值为基准值，即`nums[i]`，接着使用双指针算法求出剩余区间找出满足不等式`nums[j]+nums[k] < target - nums[i]`的`nums[j]`与`nums[k]`的组合个数，基本思路如下：

1. 取出`nums[i]`，求出`target-nums[i]`作为基准值
2. 当`nums[left]+nums[right] >= target - nums[i]`时，缩小右侧区间，因为数组满足单调递增，所以当前`left`位置后面的数值一定比`left`位置的数值大，所以改变`right`指针的位置，`right--`
3. 当`nums[left]+nums[right] < target - nums[i]`时，缩小左侧区间，因为数组满足单调递增，此时`left`指向的是当前区间中的最小值，而`right`指向的是当前区间中的最大值，如果`nums[left]+nums[right] >=  target - nums[i]`，`right`就需要向左移动缩小区间，而当`nums[left]+nums[right]`刚好小于`target-nums[i]`时，`right-left`区间中一定存在`nums[left]+nums[right]`小于`target-nums[i]`，因为左侧`left`没有移动，只是`right`在减小，所以`nums[left]+nums[right]`的结果也在减小，但是注意此处不要通过枚举的方式（`count++`）

```c++
/*
 * @lc app=leetcode.cn id=15 lang=cpp
 *
 * [258] 较小的三数之和
 */

// @lc code=start
// 双指针——计算个数
class Solution
{
public:
    int threeSumSmaller(vector<int> &nums, int target)
    {
        sort(nums.begin(), nums.end());
        int count = 0;
        int sz = nums.size();
        for (int i = 0; i < sz; i++)
        {
            int toCom = target - nums[i];
            int left = i + 1, right = sz - 1;
            while (left < right)
            {
                int sum = nums[left] + nums[right];
                // 两数求和思路
                if (sum >= toCom)
                {
                    right--;
                }
                else
                {
                    count += right - left; // 直接计算个数
                    left++;
                }
            }
        }
        return count;
    }
};
// @lc code=end
```

不要使用枚举的方式：

```c++
/*
 * @lc app=leetcode.cn id=15 lang=cpp
 *
 * [258] 较小的三数之和
 */

// @lc code=start
// 双指针——枚举情况
class Solution
{
public:
    int threeSumSmaller(vector<int> &nums, int target)
    {
        sort(nums.begin(), nums.end());
        int count = 0;
        int sz = nums.size();
        for (int i = 0; i < sz; i++)
        {
            int toCom = target - nums[i];
            int left = i + 1, right = sz - 1;
            while (left < sz)
            {
                while (left < right)
                {
                    int sum = nums[left] + nums[right];
                    // 两数求和思路
                    if (sum >= toCom)
                    {
                        right--;
                    }
                    else if (sum < toCom)
                    {
                        count++; // 枚举所有情况
                        right--;
                    }
                }
                // 更新left指针和right指针再进行一次遍历
                left++;
                right = sz - 1;
            }
        }
        return count;
    }
};
// @lc code=end
```

#### 四数之和

题目链接：[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

!!! quote
    给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

    1. `0 <= a, b, c, d < n`
    2. `a`、`b`、`c` 和 `d` **互不相同**
    3. `nums[a] + nums[b] + nums[c] + nums[d] == target`

    你可以按 **任意顺序** 返回答案 。

思路解析：

本题与三数之和的思路基本一致，即排序+双指针算法，根据表达式`nums[a]+nums[b]+nums[c]+nums[d] = target`，所以可以得出算式`nums[c]+nums[d] = target-nums[a]-nums[b]`，所以先确定两个基数`nums[a]`和`nums[b]`，再通过双指针算法得到`nums[c]和nums[d]`

!!! note
    注意本题有数据溢出的情况

参考代码：

```c++
/*
 * @lc app=leetcode.cn id=15 lang=cpp
 *
 * [15] 三数之和
 */

// @lc code=start
class Solution
{
public:
    vector<vector<int>> fourSum(vector<int> &nums, int target)
    {
        vector<vector<int>> ret;
        sort(nums.begin(), nums.end());
        int sz = nums.size();
        for (int i = 0; i < sz;)
        {
            //  三数之和思路
            for (int j = i + 1; j < sz;)
            {
                // 注意整型范围
                long long rest = (long long)target - nums[i] - nums[j];
                int left = j + 1;
                int right = sz - 1;
                // 两数之和思路
                while (left < right)
                {
                    int sum = nums[left] + nums[right];
                    if (sum > rest)
                    {
                        right--;
                    }
                    else if (sum < rest)
                    {
                        left++;
                    }
                    else
                    {
                        ret.push_back({nums[i], nums[j], nums[left], nums[right]});
                        left++;
                        right--;
                        while (left < right && nums[left] == nums[left - 1])
                        {
                            left++;
                        }
                        while (left < right && nums[right] == nums[right + 1])
                        {
                            right--;
                        }
                    }
                }
                j++;
                while (j < sz && nums[j] == nums[j - 1])
                {
                    j++;
                }
            }
            i++;
            while (i < sz && nums[i] == nums[i - 1])
            {
                i++;
            }
        }
        return ret;
    }
};
// @lc code=end
```