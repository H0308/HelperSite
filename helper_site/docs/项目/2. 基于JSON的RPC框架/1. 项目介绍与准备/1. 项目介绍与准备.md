# 项目介绍与准备

## 何为RPC

RPC（Remote Procedure Call）远程过程调用，是一种通过网络从远程计算机上请求服务，而不需要了解底层网络通信细节。RPC可以使用多种网络协议进行通信，如HTTP、TCP、UDP等，并且在TCP/IP网络四层模型中跨越了传输层和应用层，如下图所示：

<img src="1. 项目介绍与准备.assets\download.png">

## 功能介绍

在本次实现的项目中，首先就是要保证RPC本身的功能：本地调用远程方法。换句话说，客户端并不需要自己去实现某一个具体方法，而是通过调用服务端的方法来得到需要的结果，这个过程中也可以涉及到参数的传递，如下图所示：

<img src="1. 项目介绍与准备.assets\download1.png">

虽然上面的过程已经基本实现了RPC的功能，但是还需要考虑一些其他的问题，例如当前服务器只有一台，如果客户端请求的服务器离线了但是客户端并不知道这一点，这就导致客户端想请求服务就会失败，所以在本次项目中会考虑提供一个服务注册的功能，这个服务注册本质就是了解当前有哪些服务器可以提供哪些服务，而用于服务注册的服务器一旦知道了具体可以提供的服务就可以告知客户端，并且自己也可以将客户端的请求转发给具体的服务器来处理，这样就实现了一个<a href="javascript:;" class="custom-tooltip" data-title="简单理解就是由多个节点组成的⼀个系统，这些节点通常指的是服务器，将不同的业务或者同⼀个业务拆分分布在不同的节点上，通过协同⼯作解决⾼并发的问题，提⾼系统扩展性和可⽤性">分布式架构的RPC</a>。另外，基于这个服务器也可以实现负载均衡的功能，例如当一台服务器压力过大时可以将请求转发给其他拥有相同服务的服务器来处理，如下图所示：

<img src="1. 项目介绍与准备.assets\Snipaste_2025-04-24_14-52-07.png">

在上图中可以看到，客户端并不是直接请求到具体的服务器，而是请求到了服务注册中心，服务注册中心会根据客户端的请求来决定具体的服务器

但是，用于服务注册的服务器本身也是一台服务器，也可能存在崩溃的问题，所以在本次项目中除了单独提供一台服务器用于服务注册以外，还考虑将提供服务的每一台服务器设计为备用注册中心

另外，本次还考虑实现一个发布订阅的功能，简单来说就是允许客户端向服务端发送一个内容，从这个功能可以看出，客户端发送给服务端的内容需要被服务端保存，如果直接将客户端的内容存储到服务端，那么就会存在一台服务器上有各种各样的内容，查找起来也会非常麻烦，所以可以考虑设计一个主题（topic）功能，在这个功能中，客户端并不直接将内容发送给存储内容的服务器，而是先被主题服务器归类到某一个主题，再将该内容发送给对应主题的服务器，同时客户端本身也可以发布主题。最后，如果某一个客户端发布了某个主题的消息，那么其他订阅了同一个主题的客户端也需要收到这个消息，所以在本项目中除了对主题的操作以外，还需要有对消息的发布功能，整体功能如下图所示：

<img src="1. 项目介绍与准备.assets\Snipaste_2025-04-24_15-10-46.png">

基于上面的功能，现在将上面的功能进行合并，如下图所示：

<img src="1. 项目介绍与准备.assets\Snipaste_2025-04-24_15-12-33.png">

综上所述，本次项目需要实现的功能如下：

1. 基本RPC功能
2. 服务的注册与发现以及服务的下线/上线通知
3. 主题操作和消息发布功能

## 服务端模块介绍

本次实现的项目中服务端主要分为下面几个模块：

1. 网络服务模块（Network）：基于Muduo库实现底层网络服务器来处理客户端的请求
2. 应用层协议模块（Protocol）：因为TCP传输是面向字节流的，所以在大量的网络通信时必然会存在粘包问题，但是TCP本身无法解决这个问题，因为尽管是粘包，它也是一个数据，在TCP看来都属于有效载荷，但是这个数据是否是否是有效数据需要应用层来进行判断，所以就需要这个协议模块来处理这个问题。这一点在[序列化和反序列化与网络计算器](https://www.help-doc.top/Linux/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8/24.%20%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%A1%E7%AE%97%E5%99%A8.html#_5)部分也有所提及
3. 请求分发模块（Dispatcher）：在上面的功能介绍中提到本次实现的RPC框架除了RPC本身的功能外，还存在着另外两种功能，所以需要在处理客户端请求时判断客户端当前需要的功能，根据功能的类型决定调用哪一台服务器来处理，这个模块就是用来实现这个功能的
4. RPC功能模块（RpcServer）：这个模块就是用来实现RPC的基本功能
5. 服务注册模块（RegisterServer）：这个模块就是用来实现服务注册与发布、上线与下线通知的功能
6. 主题操作模块（TopicServer）：这个模块就是用来实现主题操作功能的，其中主题操作包括：创建主题、删除主题、取消主题、跟随主题和主题消息发布的功能
7. 服务器模块（MainServer）：整合上面的所有模块，实现整个服务器

### 网络服务模块

基于Muduo库设计，，对于Muduo库的介绍和使用可以参考[关于Muduo库](https://www.help-doc.top/%E5%85%B6%E5%AE%83/%E5%85%B3%E4%BA%8EMuduo%E5%BA%93/%E5%85%B3%E4%BA%8EMuduo%E5%BA%93.html#muduo)，关于Muduo库具体的设计原理，可以参考[仿Muduo库高并发服务器](#)

### 应用层协议模块

在协议设计中，常见有三种协议设计方案：

1. 通过特殊字符分割不同的数据：这个方案最大的缺点就在于特殊字符可能存在于消息中，这就需要对数据中的特殊字符进行转义，这个过程相对复杂，本次不考虑
2. 通过固定长度限制每一条消息的最大大小：这个方案最大的缺点就在于消息的长度是固定的，这就导致如果消息比较短的话就会浪费空间，本次不考虑
3. 采用`Length-Value`协议：通过长度字段来标记每一条消息的长度，这个方案的优点就在于可以灵活的控制消息的长度，本次采用这个方案

根据`Length-Value`协议的设计思想，本次设计的协议如下：

1. 有效数据的总长度（TotalLength）：大小为4字节，用于表示包括后续内容的长度，根据这个长度可以做到多个不同请求之间的拆分
2. 请求类型（RequestType）：大小为4字节，用于表示当前请求的类型，例如：RPC请求、服务注册请求、发布订阅请求
3. 请求/响应ID长度（IDLength）：大小为4字节，用于表示消息ID的长度
4. 请求/响应ID（ReqRespID）：大小为IDLength字节，用于表示消息的ID，这个ID用于标记一类请求和应答，因为客户端不会在收到上一条请求的应答之后才发送下一次请求，而是可能多次发送多个请求，而对于服务器来说，当其处理完毕返回给客户端应答时，客户端就需要知道这个应答是属于哪一个请求的。根据这个需求，这个ID必须是唯一的，所以本次采用`UUID`来作为消息ID，而`UUID`一般是一个字符串。即使是字符串，哪怕是固定的，为了保证之后的扩展性，依旧将其设计为可变长度，描述长度的字段就是IDLength
5. 有效数据（Body）：大小为总长度减去其他字段的长度，用于表示具体的请求或者响应内容

整个协议的设计如下图所示：

<img src="1. 项目介绍与准备.assets\Snipaste_2025-04-24_16-35-01.png">

### 请求分发模块

在本次项目中，处理请求并分发请求的逻辑如下：

1. 网络服务器模块接收到客户端发送的请求数据，此时收到的是原始数据
2. 应用层协议模块解析请求数据，此时收到的是解析后的请求数据
3. 请求分发模块根据请求数据的类型来判断当前的请求是属于哪一种类型，然后调用对应的模块来处理请求

整个过程如下图所示：

<img src="1. 项目介绍与准备.assets\Snipaste_2025-04-24_16-53-52.png">

### RPC功能模块

在RPC模块中，主要就是针对客户端发送的RPC服务请求做出RPC服务的响应，但是这个过程中涉及一些问题

首先就是服务器可以提供的服务的描述，这其中涉及到服务名称和服务参数，而服务器端对客户端的描述可能包含具体的结果值和返回值描述，这个描述在网络传输过程中也需要进行序列化和反序列化，而本次考虑的序列化和反序列化方案就是利用JSON格式的字符串，例如下面的例子：

```json
// RPC-request
{
    "method" : "Add",
    "parameters" : 
    { 
        "num1" : 11, 
        "num2" : 22 
    }
}

// RPC-response
{
    "rcode" : OK,
    "result": 33
}
{
    "rcode" : ERROR_INVALID_PARAMETERS
}
```

另外，因为函数的实现和函数的调用是分离的，那么在服务端一旦要执行客户端指定的服务就必须确保该服务是有效的，再判断客户端传递的参数是否合法，而客户端如何知道服务端提供的服务具体是如何描述的呢？这就需要服务端提供对服务的描述。那么一旦客户端知道了描述并且传入正确的参数以及服务端检测参数合法，服务端就可以调用对应的方法来执行服务得到结果返回给客户端。根据这个思路，在RPC功能模块中就需要有一张哈希表来表示指定服务和服务具体信息的映射关系，而这个服务具体信息是一个结构体，包括下面的字段：

1. 服务名称
2. 服务参数类型
3. 服务校验函数对象
4. 服务执行函数对象

但是，现在还有一个问题，前面提到的内容都是建立在客户端的请求已经传递给了对应的服务执行函数上，那么如何做到这一点呢？在前面服务分发模块提到客户端的请求最后会根据服务类型递交给对应的模块，那么假设已经确定请求类型为RPC功能请求，那么接下来需要做的任务就是将请求递交给RPC功能模块，所以在服务分发模块中`key`为RPC功能模块的`value`就应该是一个函数对象用来处理RPC功能请求并返回结果

## 客户端模块介绍

