# 功能模块设计（主题、客户端封装、服务端封装）

## 服务端

### 主题操作模块

#### 主题操作模块功能回顾及描述类基本结构搭建

对于服务端来说，主题操作实际上就是针对客户端的操作类型进行处理，包括主题创建、主题删除、主题订阅、主题取消订阅和主题消息发布，下面对每一个行为进行具体解释：

1. 主题创建：对于主题创建来说，本质就是一个连接到主题服务端的主题客户端需要向服务器发送一个主题创建的请求，对应的服务端需要将该主题保存并管理起来
2. 主题删除：对于主题删除来说，本质就是一个连接到主题服务端的主题客户端需要向服务器发送一个主题删除的请求，对应的服务端需要将该主题从管理列表中删除
3. 主题订阅：对于主题订阅来说，本质就是一个连接到主题服务端的主题客户端需要向服务器发送一个主题订阅的请求，对应的服务端需要将该主题的订阅者保存并管理起来
4. 主题取消订阅：对于主题取消订阅来说，本质就是一个连接到主题服务端的主题客户端需要向服务器发送一个主题取消订阅的请求，对应的服务端需要将该主题的订阅者从管理列表中删除
5. 主题消息发布：对于主题消息发布来说，本质就是一个连接到主题服务端的主题客户端需要向服务器发送一个主题消息发布的请求，对应的服务端需要将该主题消息发送给所有订阅该主题的客户端

根据上面的功能描述，首先对于主题创建来说，服务端需要保存当前主题，将来还需要通过该该主题找到所有订阅的客户端进行消息发布，所以需要一个类对主题进行描述，在该类中需要有主题名称、主题订阅者的连接这两个字段，所以基本结构如下：

```cpp
struct Topic
{
    std::string topic_name_;                         // 主题名称
    std::unordered_set<base_connection::BaseConnection::ptr> subscibers_; // 所有订阅者
};
```

但是，对于订阅者来说，服务端还需要知道这个订阅者订阅了哪些主题，便于在指定主题被删除时从所有订阅该主题的客户端中移除该主题，所以还需要一个类对订阅者进行描述，在该类中需要有订阅者的连接、订阅的主题这两个字段，所以基本结构如下：

```cpp
struct Subscriber
{
    using ptr = std::shared_ptr<Subscriber>;

    base_connection::BaseConnection::ptr con_;    // 客户端连接
    std::unordered_set<std::string> topic_names_; // 当前客户端订阅的所有主题
};
```

有了对订阅者的描述，接下来修改主题描述类中管理订阅者的成员如下：

```cpp
struct Topic
{
    std::string topic_name_;                         // 主题名称
    std::unordered_set<Subscriber::ptr> subscibers_; // 所有订阅者
};
```

#### 订阅者描述类

创建一个订阅者描述类对象时需要调用者传递当前订阅者的连接，在构造函数中对其进行初始化：

```cpp
Subscriber(const base_connection::BaseConnection::ptr &con)
    : con_(con)
{
}
```

接着，该类中需要提供针对订阅的主题集合进行管理的操作函数，包括添加和删除，为了保证线程安全，需要提供一个互斥锁：

```cpp
std::mutex manage_set_mtx_; // 保证管理的线程安全
```

接着设计添加和删除接口，思路比较简单，参考下面代码：

=== "添加主题"

    ```cpp
    // 主题创建（添加）
    void insertTopic(const std::string &topic_name)
    {
        std::unique_lock<std::mutex> lock(manage_set_mtx_);
        // 直接插入，如果存在就不进行处理
        // 使用emplace可能会构建对象，与insert相同
        topic_names_.emplace(topic_name);
    }
    ```

=== "删除主题"

    ```cpp
    // 主题删除（移除）
    void removeTopic(const std::string &topic_name)
    {
        std::unique_lock<std::mutex> lock(manage_set_mtx_);
        auto it = topic_names_.find(topic_name);
        if (it == topic_names_.end())
            return; // 不存在直接返回，不进行任何操作
        topic_names_.erase(topic_name);
    }
    ```

#### 主题描述类

创建一个主题描述类对象需要有一个参数，即主题名称，在构造函数中对其进行初始化：

```cpp
Topic(const std::string &topic_name)
    : topic_name_(topic_name)
{
}
```

接着，在该类中提供添加和删除订阅者的函数，先提供一个互斥锁成员保证线程安全：

```cpp
std::mutex manage_set_mtx_; // 保证管理的线程安全
```

接着设计添加和删除接口，参考下面代码：

=== "添加订阅者"

    ```cpp
    // 主题订阅（添加订阅者）
    void insertSubscriber(const Subscriber::ptr &subsciber)
    {
        std::unique_lock<std::mutex> lock(manage_set_mtx_);
        subscibers_.emplace(subsciber);
    }
    ```

=== "删除订阅者"

    ```cpp
    // 主题取消订阅（移除订阅者）
    void removeSubscriber(const Subscriber::ptr &subsciber)
    {
        std::unique_lock<std::mutex> lock(manage_set_mtx_);
        auto pos = subscibers_.find(subsciber);
        if (pos == subscibers_.end())
            return;
        subscibers_.erase(subsciber);
    }
    ```

除了上面的两个函数以外，还需要有一个函数，该函数的作用是进行消息发布，该函数的参数是消息的内容，基本思路就是遍历所有订阅者，然后将消息发送给所有订阅者，参考下面代码：

```cpp
// 主题信息的发布
void publicMessage(const base_message::BaseMessage::ptr &msg)
{
    std::unique_lock<std::mutex> lock(manage_set_mtx_);
    // 遍历连接集合发送消息
    for (auto &subscriber : subscibers_)
        if (subscriber)
            subscriber->con_->send(msg);
}
```

#### 主题操作模块功能实现

根据前面的功能描述，在主题操作模块中主要提供五种功能，而在这五种功能中，都需要涉及对主题的管理以及对订阅者的管理，所以首先需要两张哈希表，分别用于管理「订阅者的连接与订阅者描述类对象指针的映射关系」以及「每一个主题名称与主题描述类对象指针的映射关系」，如下：

```cpp
std::unordered_map<std::string, Topic::ptr> topics_; // 主题和订阅者的管理
std::unordered_map<base_connection::BaseConnection::ptr, Subscriber::ptr> con_subscriber_; // 订阅者和连接映射
```

对应的需要提供「添加指定主题」、「删除指定主题」、「进行主题订阅」、「取消主题订阅」以及「主题消息发布」这五个函数，下面分别对这五个函数的设计思路进行介绍：

1. 添加指定主题：查找消息基类中主题名称对应的主题描述类对象是否存在，如果存在就直接返回，否则就构建该主题对应的主题描述类对象，并将其添加到主题管理表中即可
2. 删除指定主题：获取到消息基类中指定的服务名称，如果服务名称存在就执行删除，否则直接返回。删除逻辑为：根据指定主题找到对应的主题描述类对象，接着获取到其中的订阅者管理集合，接着删除该主题以及遍历订阅者管理集合从每一个订阅者管理的主题集合中删除该主题
3. 进行主题订阅：主题订阅本质就是通知服务端有一个订阅客户端需要被管理，为了保证订阅可以成功，需要先确保具体的主题是否存在，如果主题不存在，则直接返回订阅失败，否则继续后面的逻辑，即创建一个订阅者描述类对象，接着将该订阅者添加到`con_subscriber_`，再将该订阅者添加到`Topic`的`subscibers_`中，并将订阅者订阅的主题添加`Subscriber`的`topic_names_`中完成整体的逻辑
4. 取消主题订阅：取消订阅的逻辑与进行主题订阅相反，此处不再赘述
5. 主题消息发布：根据指定的主题找到对应的主题描述类对象，再将消息基类的消息通过主题描述类对象的主题发布函数进行消息发布

根据上面的思路，分别设计这五个函数，参考下面代码：

=== "添加指定主题"

    ```cpp
    // 新增主题
    void createTopic(const request_message::TopicRequest::ptr &msg)
    {
        // 判断主题是否存在，如果不存在则创建新的Topic对象插入到集合中
        std::unique_lock<std::mutex> lock(manage_map_mtx_);
        std::string topic_name = msg->getTopicName();

        topics_.try_emplace(topic_name, std::make_shared<Topic>(topic_name));
    }
    ```

=== "删除指定主题"

    ```cpp
    // 主题删除
    void removeTopic(const request_message::TopicRequest::ptr &msg)
    {
        // 获取到指定的Topic对象指针
        std::unordered_set<Subscriber::ptr> subscribers;
        std::string topic_name = msg->getTopicName();
        {
            std::unique_lock<std::mutex> lock(manage_map_mtx_);
            // 根据获取到的Topic找到其中的管理订阅者连接的集合
            auto it_topic = topics_.find(topic_name);
            if (it_topic == topics_.end())
                return;
            // 根据订阅者集合获取到订阅该主题的所有连接
            subscribers = it_topic->second->subscibers_;
            // 再从主题管理集合中移除该主题
            topics_.erase(topic_name);
        }
        // 根据每一个连接找到对应的订阅者，在每一个订阅者中移除待删除的主题
        for (auto &subscriber : subscribers)
            subscriber->removeTopic(topic_name);
    }
    ```

=== "进行主题订阅"

    ```cpp
    // 主题订阅
    bool subscribeTopic(const base_connection::BaseConnection::ptr &con, const request_message::TopicRequest::ptr &msg)
    {
        // 找到指定的主题对应的Topic，向Topic中添加订阅者信息
        // 接着获取到指定的订阅者信息，向该订阅者管理的主题插入新增的主题信息
        Topic::ptr topic;
        Subscriber::ptr subscriber;
        std::string topic_name = msg->getTopicName();
        {
            std::unique_lock<std::mutex> lock(manage_map_mtx_);
            auto it_topic = topics_.find(topic_name);
            // 不存在则说明指定的主题不存在
            if (it_topic == topics_.end())
            {
                LOG(Level::Warning, "指定主题不存在，订阅失败");
                return false;
            }

            // 存在
            topic = it_topic->second;

            auto pos = con_subscriber_.try_emplace(con, std::make_shared<Subscriber>(con));
            subscriber = pos.first->second;
        }

        if (topic && subscriber)
        {
            topic->insertSubscriber(subscriber);
            subscriber->insertTopic(topic_name);
        }

        return true;
    }
    ```

=== "取消主题订阅"

    ```cpp
    // 取消订阅
    void cancelSubscribeTopic(const base_connection::BaseConnection::ptr &con, const request_message::TopicRequest::ptr &msg)
    {
        // 找到指定主题的Topic，从管理的订阅者中删除指定的连接
        // 接着在指定的订阅者管理的主题集合中移除指定主题
        Topic::ptr topic;
        Subscriber::ptr subscriber;
        std::string topic_name = msg->getTopicName();
        {
            std::unique_lock<std::mutex> lock(manage_map_mtx_);
            auto it_topic = topics_.find(topic_name);
            // 不存在则说明指定的主题不存在，此时需要报错防止后续行为异常
            if (it_topic != topics_.end())
                topic = it_topic->second; // 存在直接使用，不存在不处理

            auto it_sub = con_subscriber_.find(con);
            if (it_sub != con_subscriber_.end())
                subscriber = it_sub->second; // 存在直接使用，不存在不处理
        }

        if (topic && subscriber)
        {
            topic->removeSubscriber(subscriber);
            subscriber->removeTopic(topic_name);
        }
    }
    ```

=== "主题消息发布"

    ```cpp
    // 主题发布
    bool publishTopicMessage(const request_message::TopicRequest::ptr &msg)
    {
        // 找到指定主题对应的Topic，调用Topic中的消息发布接口发布消息
        Topic::ptr topic;
        std::string topic_name = msg->getTopicName();
        {
            std::unique_lock<std::mutex> lock(manage_map_mtx_);
            auto it_topic = topics_.find(topic_name);
            if (it_topic == topics_.end())
            {
                LOG(Level::Warning, "消息发布失败，不存在对应的主题");
                return false;
            }

            topic = it_topic->second;
        }

        if (topic)
            topic->publicMessage(msg);

        return true;
    }
    ```

有了上面的操作接口之后，接下来对于服务端来说就需要有对应处理客户端请求的函数，在该函数中实际上只需要根据客户端发送的请求类型来调用对应的处理函数即可，而对于上面五个操作来说，服务端需要返回给客户端的响应格式都是一致的，所以可以考虑将响应构建和发送单独放在一个函数中，对应地，还要有发送错误响应的函数，这两个函数的设计思路相对简单，只需要构建响应消息对象再填充主题响应需要的字段即可：

=== "发送正常响应"

    ```cpp
    // 发送主题操作响应
    void sendTopicResponse(const base_connection::BaseConnection::ptr &con, const base_message::BaseMessage::ptr &msg)
    {
        // 创建响应对象
        auto topic_resp = message_factory::MessageFactory::messageCreateFactory<response_message::TopicResponse>();
        // 设置字段
        topic_resp->setId(msg->getReqRespId());
        topic_resp->setMType(public_data::MType::Resp_topic);
        topic_resp->setRCode(public_data::RCode::RCode_fine);

        con->send(topic_resp);
    }
    ```

=== "发送错误响应"

    ```cpp
    // 错误主题操作响应
    void sendErrorResponse(const base_connection::BaseConnection::ptr &con, const base_message::BaseMessage::ptr &msg, public_data::RCode rcode)
    {
        // 创建响应对象
        auto topic_resp = message_factory::MessageFactory::messageCreateFactory<response_message::TopicResponse>();
        // 设置字段
        topic_resp->setId(msg->getReqRespId());
        topic_resp->setMType(public_data::MType::Resp_topic);
        topic_resp->setRCode(rcode);

        con->send(topic_resp);
    }
    ```
    
最后完善对客户端请求的处理函数：

```cpp
// 处理主题请求，注册到Dispatcher模块
void handleTopicRequest(const base_connection::BaseConnection::ptr &con, const request_message::TopicRequest::ptr &msg)
{
    // 获取到主题操作类型
    public_data::TopicOptype topic_optype = msg->getTopicOptype();
    bool ret = true;
    switch (topic_optype)
    {
    case public_data::TopicOptype::Topic_create:
        createTopic(msg); // 1. 主题创建
        break;
    case public_data::TopicOptype::Topic_remove:
        removeTopic(msg); // 2. 主题删除
        break;
    case public_data::TopicOptype::Topic_subscribe:
        ret = subscribeTopic(con, msg); // 3. 主题订阅
        break;
    case public_data::TopicOptype::Topic_cancel:
        cancelSubscribeTopic(con, msg); // 4. 主题取消订阅
        break;
    case public_data::TopicOptype::Topic_publish:
        ret = publishTopicMessage(msg); // 5. 主题发布
        break;
    default:
        sendErrorResponse(con, msg, public_data::RCode::RCode_invalid_opType);
        break;
    }

    if (!ret)
    {
        sendErrorResponse(con, msg, public_data::RCode::RCode_not_found_topic);
        return;
    }

    sendTopicResponse(con, msg);
}
```

除了处理请求的函数以外，服务端还需要对断开连接的订阅客户端进行资源处理，这个函数中的主要逻辑就是根据下线的连接判断是否是订阅者（即判断订阅者是否存在于`con_subscriber_`中），如果是订阅者就根据订阅者关联的所有主题找到对应的`Topic`，从`con_subscriber_`中移除订阅者，再从这些`Topic`中的`subscibers_`中移除下线的订阅者。代码如下：

```cpp
// 订阅者下线的处理
void handleConnectionShutdown(const base_connection::BaseConnection::ptr &con)
{
    // 根据下线的连接判断是否是订阅者
    // 如果是订阅者就根据订阅者关联的主题找到对应的Topic
    // 从Topic中的订阅者集合中移除下线的订阅者
    // 从连接和订阅者映射集合中移除订阅者
    Subscriber::ptr subscriber;
    std::unordered_set<Topic::ptr> topics;
    {
        std::unique_lock<std::mutex> lock(manage_map_mtx_);
        auto it_sub = con_subscriber_.find(con);

        subscriber = it_sub->second;
        for (auto &topic_name : it_sub->second->topic_names_)
        {
            auto it_topic = topics_.find(topic_name);
            topics.insert(it_topic->second);
        }

        con_subscriber_.erase(con);
    }
    for (auto &topic : topics)
        topic->removeSubscriber(subscriber);
}
```

至此，服务端主题操作模块设计完成

### 服务端封装

## 客户端

### 主题操作模块

对于客户端来说，就是提供主题操作的函数，即针对具体的主题类型向服务端发送对应的请求，但是需要注意的是，对于不同的主题，其可能对应的处理方式不同，所以需要建立主题名称和处理回调函数的映射关系，这个回调函数主要就是针对主题和对应的消息进行处理，所以参数一共有两个：主题名称和主题消息，类型设计如下：

```cpp
// 收到发布的消息时执行的回调函数类型
using publishCallback = std::function<void(const std::string &topic_name, const std::string &msg)>;
```

接着，提供一张哈希表用于建立主题名称和回调函数的映射关系：

```cpp
std::unordered_map<std::string, publishCallback> topic_callback_; // 不同的主题对应的处理回调函数映射
```

为了保证修改`topic_callback_`的线程安全，需要使用一个互斥锁：

```cpp
std::mutex manager_map_mtx_;
```

对应地，提供添加、删除和获取回调函数接口：

=== "添加回调函数"

    ```cpp
    // 添加回调函数接口
    void insertCallback(const std::string &topic_name, const publishCallback &cb)
    {
        std::unique_lock<std::mutex> lock(manager_map_mtx_);
        topic_callback_.try_emplace(topic_name, cb);
    }
    ```

=== "删除回调函数"

    ```cpp
    // 删除回调函数接口
    void removeCallback(const std::string &topic_name)
    {
        std::unique_lock<std::mutex> lock(manager_map_mtx_);
        topic_callback_.erase(topic_name);
    }
    ```

=== "获取回调函数"

    ```cpp
    // 获取回调函数接口
    const publishCallback findPublishCallback(const std::string &topic_name)
    {
        std::unique_lock<std::mutex> lock(manager_map_mtx_);
        auto it = topic_callback_.find(topic_name);
        if(it == topic_callback_.end())
        {
            LOG(Level::Warning, "不存在指定主题：{}对应的回调接口", topic_name);
            return publishCallback();
        }

        return it->second;
    }
    ```

因为客户端的请求消息大体都是类似的，除了消息类型为消息发布时需要携带消息内容以外，其他的请求消息只是请求类型不同，其他字段值都是一致的，所以可以考虑将消息的构建和发送封装到一个函数中，其他功能函数调用该请求发送函数即可

对于该请求发送函数，首先需要构建一个主题消息对象，分别填充其中的字段，包括主题名称和主题操作类型，接着调用请求管理模块的请求发送哈数发送对应的请求，最后检查响应消息的返回码，如果返回码为`RCode_fine`则表示请求成功，否则表示请求失败。需要注意的是，此处请求发送函数也必须使用**同步**的，因为必须要确保主题正常创建、删除、订阅、取消订阅以及消息发布成功，才能继续后续的操作。该函数实现如下：

```cpp
// 通用的请求发送接口
bool baseRequest(const base_connection::BaseConnection::ptr &con, const std::string &topic_name, const public_data::TopicOptype topic_optype, const std::string &content = "")
{
    // 1. 构造出主题请求对象，并填充相关字段
    auto topic_req = message_factory::MessageFactory::messageCreateFactory<request_message::TopicRequest>();
    topic_req->setId(uuid_generator::UuidGenerator::generate_uuid());
    topic_req->setMType(public_data::MType::Req_topic);
    topic_req->setTopicName(topic_name);
    topic_req->setTopicOptype(topic_optype);
    // 如果操作类型是主题消息发布，则还需要设置发布的消息
    if (topic_optype == public_data::TopicOptype::Topic_publish)
        topic_req->setMessage(content);

    // 2. 发送请求
    base_message::BaseMessage::ptr msg_resp;
    bool ret = requestor_->sendRequest(con, topic_req, msg_resp);
    if (!ret)
    {
        LOG(Level::Warning, "主题操作请求发送失败");
        return false;
    }

    // 3. 判断响应结果是否正确
    auto topic_resp = std::dynamic_pointer_cast<response_message::TopicResponse>(msg_resp);
    if (!topic_resp)
    {
        LOG(Level::Warning, "向下转型失败");
        return false;
    }
    if (topic_resp->getRCode() != public_data::RCode::RCode_fine)
    {
        LOG(Level::Warning, "主题{}操作错误：{}", topic_name, public_data::errReason(topic_resp->getRCode()));
        return false;
    }

    return true;
}
```

接着，分别实现功能函数：

=== "主题创建"

    ```cpp
    // 新增主题
    bool createTopic(const base_connection::BaseConnection::ptr &con, const std::string &topic_name)
    {
        return baseRequest(con, topic_name, public_data::TopicOptype::Topic_create);
    }
    ```

=== "主题删除"

    ```cpp
    // 删除主题
    bool removeTopic(const base_connection::BaseConnection::ptr &con, const std::string &topic_name)
    {
        return baseRequest(con, topic_name, public_data::TopicOptype::Topic_remove);
    }
    ```

接下来考虑主题订阅和取消订阅函数，对于主题订阅来说，当客户端想要订阅一个主题就需要指定一个处理该主题消息的回调函数，所以该函数除了需要设置主题名称以外，还需要外部传递一个回调函数，在函数内部首先需要将对应的消息处理函数插入到`topic_callback_`中，确保后续刚订阅主题就有消息时可以立即处理，接着调用请求发送函数发送主题订阅请求，检查该函数返回值决定当前函数的返回值，需要注意，如果请求发送失败，要移除对应的回调函数确保下一次可以正常使用其他回调函数。该函数实现如下：

```cpp
// 订阅主题
bool subscribeTopic(const base_connection::BaseConnection::ptr &con, const std::string &topic_name, const publishCallback &cb)
{
    // 先插入回调函数，防止后续刚订阅主题就有消息时可以立即处理
    insertCallback(topic_name, cb);
    bool ret = baseRequest(con, topic_name, public_data::TopicOptype::Topic_subscribe);
    if(!ret)
    {
        // 删除回调函数并返回
        removeCallback(topic_name);
        return false;
    }

    return true;
}
```

对应的，取消订阅函数只需要移除对应的回调函数再发送取消订阅请求即可：

```cpp
bool cancelSubscribeTopic(const base_connection::BaseConnection::ptr &con, const std::string &topic_name)
{
    // 先删除回调函数，确保取消之后都不处理消息
    removeCallback(topic_name);
    return baseRequest(con, topic_name, public_data::TopicOptype::Topic_cancel);
}
```

接着是消息发布函数，该函数只需要调用请求发送函数发送消息发布请求即可，但是需要注意，参数需要包含待发布的消息内容：

```cpp
// 主题发布
bool publishTopicMessage(const base_connection::BaseConnection::ptr &con, const std::string &topic_name, const std::string &content)
{
    return baseRequest(con, topic_name, public_data::TopicOptype::Topic_publish, content);
}
```

除了请求发送，客户端还需要做到接收服务端发送的消息（主题消息发布请求转发的内容），具体逻辑就是根据消息基类中的主题找到对应的回调函数处理该消息即可：

```cpp
// 处理收到发布的消息
void handleTopicMessagePublishRequest(const base_connection::BaseConnection::ptr &con, const request_message::TopicRequest::ptr &msg)
{
    // 判断操作类型是否是主题消息发布
    public_data::TopicOptype topic_optype = msg->getTopicOptype();
    if(topic_optype != public_data::TopicOptype::Topic_publish)
    {
        LOG(Level::Warning, "非主题消息发布操作类型，处理结束");
        return;
    }

    // 获取到主题名称
    std::string topic_name = msg->getTopicName();
    // 获取到主题消息
    std::string topic_msg = msg->getMessage();

    // 根据主题名称获取到对应的回调函数
    const publishCallback publish_cb = findPublishCallback(topic_name);
    // 调用回调函数进行处理
    if(!publish_cb)
    {
        LOG(Level::Warning, "主题{}对应的回调函数不存在", topic_name);
        return;
    }

    publish_cb(topic_name, topic_msg);
}
```

### 客户端封装

