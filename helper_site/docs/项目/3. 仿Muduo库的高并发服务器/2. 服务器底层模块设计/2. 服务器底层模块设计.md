# 服务器底层模块设计

## `Buffer`模块

### 基本结构

在前面的项目介绍中已经对`Buffer`模块的作用进行了详细的介绍，下面直接开始设计`Buffer`模块

对于一个应用层缓冲区来说，其发送的数据不只是文本数据，还有可能是二进制数据，所以在`Buffer`类中使用的容器不建议是string，而是考虑直接使用vector，对应的模版类型就是字符类型`char`即可

考虑完存储的容器之后，再考虑下一个问题：如何表示用于读取的位置和用于写入的位置？实际上这里就可以借鉴大部分容器的设计思路，使用两个指针分别表示可读位置起始和可写位置起始

根据上面的思路，可以设计出`Buffer`类的基本结构：

```cpp
class Buffer {
public:
    Buffer() : read_idx_(0), write_idx_(0) {}
private:
    std::vector<char> buffer_;
    uint64_t read_idx_;  // 读取起始位置（闭）
    uint64_t write_idx_; // 写入起始位置（闭）
};
```

但是，上面的基本结构存在一个问题，因为容器大小并没有初始化容量，如果直接使用下标去访问容器就会出现越界问题，所以可以考虑给一个默认容量值，使用该值对容器进行初始化：

```cpp
// 缓冲区默认大小
const int default_size = 1024;
Buffer()
    : // ...
    , buffer_(default_size)
{
}
```

### 接口设计

在本次项目中，`Buffer`类首先提供下面的接口：

1. 获取读位置：直接返回第一个元素的位置+`read_idx_`即可
2. 获取写位置：直接返回第一个元素的位置+`write_idx_`即可
3. 获取可读数据大小：返回`write_idx_ - read_idx_`即可
4. 获取缓冲区起始位置：直接返回第一个元素的地址即可
5. 获取可写空间大小

对于获取可写空间大小来说，需要考虑两部分：

1. 可写位置之后还有多少空间：`buffer_.size() - write_idx_`
2. 可读位置之前还有多少空间：`read_idx_`

这两部分加在一起才是实际上空闲的空间

接着，提供下面的接口：

1. 移动写指针：让读指针按照指定的长度移动，但是需要判断指定的长度是否已经超出缓冲区的容量
2. 移动读指针：让写指针按照指定的长度移动，但是需要判断指定的长度是否已经超出可读数据大小
3. 清空缓冲区：将读指针和写指针置为0即可
4. 确保缓冲区足够空间

对于确保缓冲区足够空间来说，需要考虑下面的情况：

1. 当指定长度小于写位置之后的空间大小：直接返回。如下图所示：

    <img src="2. 服务器底层模块设计.assets/image-20250629164513316.png">

2. 当指定长度小于写位置之后的空间大小与读位置之前的空间大小之和：移动缓冲区已有的数据到起始位置，更新读指针和写指针。如下图所示：

    <img src="2. 服务器底层模块设计.assets/image-20250629164600607.png">

3. 当指定长度大于写位置之后的空间大小与读位置之前的空间大小之和：直接扩容到指定大小即可。如下图所示：

    <img src="2. 服务器底层模块设计.assets/image-20250629164628847.png">

除了上面的接口外，还需要提供向缓冲区写入数据和从其中读取数据的接口，本次实现中提供两种接口：

1. 只读取/写入数据，不移动读取/写入指针
2. 读取/写入数据后，移动读取/写入指针

对于第二种接口，只需要调用第一种接口再调用上面实现的指针移动接口即可。所以下面考虑如何实现第一种接口

对于写入数据来说，本次提供针对三种类型的读取方式：

1. 针对任意类型`void*`
2. 针对string类型
3. 针对`Buffer`类型

因为后两种类型本质都可以获取到写入数据的起始指针，所以实际上只需要实现第一种类型的接口，后两种类型只需要复用即可。对于写入数据来说，首先需要确保有足够的空间来存储指定大小的数据，所以需要调用前面提到的确保缓冲区足够的接口，接着将数据拷贝到缓冲区的写位置开始即可。这里需要注意一点，`void*`在C语言中是不支持直接进行指针偏移的，所以需要先将`void*`强转成`char*`，然后再进行指针偏移，为了确保安全，本次将其强转成`const char*`。另外，如果指定长度为0，可以考虑直接返回，而不需要再执行后续的逻辑

有了发送`void*`数据的接口以后，接下来考虑针对string类型的，此处只需要获取到string中存储的数据即可，这里可以考虑直接使用`c_str()`接口，当然也可以考虑使用`data()`接口，但是使用`data()`接口无法保证文本字符串最后有`\0`结尾，而考虑到本次使用string类型时都是针对文本数据，所以使用`c_str()`接口。但是此处会遇到一个问题，因为`c_str()`接口返回的是`const char*`，而`void*`无法接收`const`数据，所以在拷贝数据时需要使用`const_cast`将其强转成`char*`

对于`Buffer`类型，相对比较容易，直接获取到可读数据的起始地址，再根据可读空间大小的接口，将数据通过`void*`的写入接口拷贝到缓冲区即可。此处思路很简单，但是如果上面的接口设计使用到了函数重载，那么就需要注意对于`Buffer`类型的接口来说一定要将可读数据的起始地址转换为`void*`类型，否则会因为可以隐式类型转换为string类型而错误调用了写入string类型数据的函数，尤其是如果实现了返回值是`const char*`版本的获取可读数据的起始地址的接口

实现完写入接口后，接下来实现读取接口，本次提供三种读取方式，针对两种类型：

1. 针对`void*`类型
2. 针对string类型
3. 针对string类型读取一行数据

同样，先设计`void*`接口，对于读取来说，需要判断指定读取的大小是否小于或者等于可读数据大小，如果不是就直接退出，如果满足就可以将指定长度的数据拷贝到输出型参数对应的空间中，但是需要注意，由于是`void*`，直接拷贝数据会出现问题，所以需要将其强制转换为`char*`，**注意此时不是`const char*`**

接着是针对string类型，对于string类型，可以正常调用针对`void*`数据的读取接口，这里需要注意，string并没有直接提供访问第一个元素地址并对其进行修改的接口，所以这里可以考虑使用下标访问到第一个元素，再对其进行取地址，但是**一定要注意先开辟好string容器的空间，再调用写入接口**，否则直接访问string容器内部的元素会出现越界访问的问题

最后是针对读取一行数据存储到string内部，这里考虑两种换行符，一种是`\n`，还有一种是`\r\n`，所以提供两个接口用于在字符串中查找这两种字符串，接着在读取函数中根据这两种字符位置截取子串即可读取到一行的数据，本次考虑将换行符同样读取存储到string类型的输出参数中

有了以上接口后，缓冲区类就基本设计完毕了

具体的实现代码可以查看：[Buffer类文件](https://github.com/H0308/ReactorServer/blob/main/reactor_server/net/buffer.h)

## `Socket`模块

## `TimingWheel`模块

## `Channel`模块

## `Poller`模块

## `EventLoop`模块

## `Connection`模块

## `Acceptor`模块

## `LoopThreadPool`模块

## `TcpServer`模块